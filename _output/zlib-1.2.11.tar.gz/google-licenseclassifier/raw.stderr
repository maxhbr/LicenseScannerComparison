2018/06/19 20:06:40 Classifying license(s): /zlib-1.2.11.tar.gz/configure
2018/06/19 20:06:40 Finished Classifying License "/zlib-1.2.11.tar.gz/configure": 87.996912ms
2018/06/19 20:06:40 Couldn't classify license(s)
2018/06/19 20:06:41 Classifying license(s): /zlib-1.2.11.tar.gz/zutil.c
2018/06/19 20:06:41 detected language: 4
2018/06/19 20:06:41 " zutil.c -- target dependent utility functions for the compression library\n * Copyright (C) 1995-2017 Jean-loup Gailly\n * For conditions of distribution and use, see copyright notice in zlib.h\n "
2018/06/19 20:06:41 " @(#) $Id$ "
2018/06/19 20:06:41 " Z_NEED_DICT       2  \n Z_STREAM_END      1  \n Z_OK              0  \n Z_ERRNO         (-1) \n Z_STREAM_ERROR  (-2) \n Z_DATA_ERROR    (-3) \n Z_MEM_ERROR     (-4) \n Z_BUF_ERROR     (-5) \n Z_VERSION_ERROR (-6) "
2018/06/19 20:06:41 " exported to allow conversion of error code to string for compress() and\n * uncompress()\n "
2018/06/19 20:06:41 " The Microsoft C Run-Time Library for Windows CE doesn't have\n     * errno.  We define it as a global variable to simplify porting.\n     * Its value is always 0 and should not be used.\n     "
2018/06/19 20:06:41 " ??? to be unrolled "
2018/06/19 20:06:41 " ??? to be unrolled "
2018/06/19 20:06:41 " Turbo C in 16-bit mode "
2018/06/19 20:06:41 " Turbo C malloc() does not allow dynamic allocation of 64K bytes\n * and farmalloc(64K) returns a pointer with an offset of 8, so we\n * must fix the pointer. Warning: the pointer must be put back to its\n * original form in order to free it, use zcfree().\n "
2018/06/19 20:06:41 " 10*64K = 640K "
2018/06/19 20:06:41 " This table is used to remember the original form of pointers\n * to large buffers (64K). Such pointers are normalized with a zero offset.\n * Since MSDOS is not a preemptive multitasking OS, this table is not\n * protected from concurrent access. This hack doesn't work anyway on\n * a protected system like OS/2. Use Microsoft C instead.\n "
2018/06/19 20:06:41 " If we allocate less than 65520 bytes, we assume that farmalloc\n     * will return a usable pointer which doesn't have to be normalized.\n     "
2018/06/19 20:06:41 " Normalize the pointer to seg:0 "
2018/06/19 20:06:41 " object < 64K "
2018/06/19 20:06:41 " Find the original pointer "
2018/06/19 20:06:41 " __TURBOC__ "
2018/06/19 20:06:41 " Microsoft C in 16-bit mode "
2018/06/19 20:06:41 " M_I86 "
2018/06/19 20:06:41 " SYS16BIT "
2018/06/19 20:06:41 " Any system without a special alloc function "
2018/06/19 20:06:41 " MY_ZCALLOC "
2018/06/19 20:06:41 " !Z_SOLO "
2018/06/19 20:06:41 Finished Classifying License "/zlib-1.2.11.tar.gz/zutil.c": 19.347383ms
2018/06/19 20:06:41 Couldn't classify license(s)
2018/06/19 20:06:42 Classifying license(s): /zlib-1.2.11.tar.gz/inffast.c
2018/06/19 20:06:42 detected language: 4
2018/06/19 20:06:42 " inffast.c -- fast decoding\n * Copyright (C) 1995-2017 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n "
2018/06/19 20:06:42 "\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state->mode == LEN\n        strm->avail_in >= 6\n        strm->avail_out >= 258\n        start >= strm->avail_out\n        state->bits < 8\n\n   On return, state->mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm->avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm->avail_out >= 258 for each loop to avoid checking for\n      output space.\n "
2018/06/19 20:06:42 " inflate()'s starting value for strm->avail_out "
2018/06/19 20:06:42 " local strm->next_in \n have enough input while in < last \n local strm->next_out \n inflate()'s initial strm->next_out \n while out < end, enough space available "
2018/06/19 20:06:42 " maximum distance from zlib header "
2018/06/19 20:06:42 " window size or zero if not using window \n valid bytes in the window \n window write index \n allocated sliding window, if wsize != 0 \n local strm->hold \n local strm->bits \n local strm->lencode \n local strm->distcode \n mask for first level of length codes \n mask for first level of distance codes \n retrieved table entry \n code bits, operation, extra bits, or \n  window position, window bytes to copy \n match length, unused bytes \n match distance \n where to copy match from "
2018/06/19 20:06:42 " copy state to local variables "
2018/06/19 20:06:42 " decode literals and length/distances until end-of-block or not enough\n       input data or output space "
2018/06/19 20:06:42 " literal "
2018/06/19 20:06:42 " length base "
2018/06/19 20:06:42 " number of extra bits "
2018/06/19 20:06:42 " distance base "
2018/06/19 20:06:42 " number of extra bits "
2018/06/19 20:06:42 " max distance in output \n see if copy from window \n distance back in window "
2018/06/19 20:06:42 " very common case "
2018/06/19 20:06:42 " some from window "
2018/06/19 20:06:42 " rest from output "
2018/06/19 20:06:42 " wrap around window "
2018/06/19 20:06:42 " some from end of window "
2018/06/19 20:06:42 " some from start of window "
2018/06/19 20:06:42 " rest from output "
2018/06/19 20:06:42 " contiguous in window "
2018/06/19 20:06:42 " some from window "
2018/06/19 20:06:42 " rest from output "
2018/06/19 20:06:42 " copy direct from output \n minimum length is three "
2018/06/19 20:06:42 " 2nd level distance code "
2018/06/19 20:06:42 " 2nd level length code "
2018/06/19 20:06:42 " end-of-block "
2018/06/19 20:06:42 " return unused bytes (on entry, bits < 8, so in won't go too far back) "
2018/06/19 20:06:42 " update state and return "
2018/06/19 20:06:42 "\n   inflate_fast() speedups that turned out slower (on a PowerPC G3 750CXe):\n   - Using bit fields for code structure\n   - Different op definition to avoid & for extra bits (do & for table bits)\n   - Three separate decoding do-loops for direct, window, and wnext == 0\n   - Special case for distance > 1 copies to do overlapped load and store copy\n   - Explicit branch predictions (based on measured branch probabilities)\n   - Deferring match copy and interspersed it with decoding subsequent codes\n   - Swapping literal/length else\n   - Swapping window/direct else\n   - Larger unrolled copy loops (three is about right)\n   - Moving len -= 3 statement into middle of loop\n "
2018/06/19 20:06:42 " !ASMINF "
2018/06/19 20:06:42 Finished Classifying License "/zlib-1.2.11.tar.gz/inffast.c": 24.090152ms
2018/06/19 20:06:42 Couldn't classify license(s)
2018/06/19 20:06:43 Classifying license(s): /zlib-1.2.11.tar.gz/gzclose.c
2018/06/19 20:06:43 detected language: 4
2018/06/19 20:06:43 " gzclose.c -- zlib gzclose() function\n * Copyright (C) 2004, 2010 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n "
2018/06/19 20:06:43 " gzclose() is in a separate file so that it is linked in only if it is used.\n   That way the other gzclose functions can be used instead to avoid linking in\n   unneeded compression or decompression routines. "
2018/06/19 20:06:43 Finished Classifying License "/zlib-1.2.11.tar.gz/gzclose.c": 1.219527ms
2018/06/19 20:06:43 Couldn't classify license(s)
2018/06/19 20:06:44 Classifying license(s): /zlib-1.2.11.tar.gz/inftrees.c
2018/06/19 20:06:44 detected language: 4
2018/06/19 20:06:44 " inftrees.c -- generate Huffman trees for efficient decoding\n * Copyright (C) 1995-2017 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n "
2018/06/19 20:06:44 "\n  If you use the zlib library in a product, an acknowledgment is welcome\n  in the documentation of your product. If for some reason you cannot\n  include such an acknowledgment, I would appreciate that you keep this\n  copyright string in the executable of your product.\n "
2018/06/19 20:06:44 "\n   Build a set of tables to decode the provided canonical Huffman code.\n   The code lengths are lens[0..codes-1].  The result starts at *table,\n   whose indices are 0..2^bits-1.  work is a writable array of at least\n   lens shorts, which is used as a work area.  type is the type of code\n   to be generated, CODES, LENS, or DISTS.  On return, zero is success,\n   -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table\n   on return points to the next available entry's address.  bits is the\n   requested root table index bits, and on return it is the actual root\n   table index bits.  It will differ if the request is greater than the\n   longest code or if it is less than the shortest code.\n "
2018/06/19 20:06:44 " a code's length in bits \n index of code symbols \n minimum and maximum code lengths \n number of index bits for root table \n number of index bits for current table \n code bits to drop for sub-table \n number of prefix codes available \n code entries in table used \n Huffman code \n for incrementing code, index \n index for replicating entries \n low bits for current root entry \n mask for low root bits \n table entry for duplication \n next available space in table \n base value table to use \n extra bits table to use \n use base and extra for symbol >= match \n number of codes of each length \n offsets in table for each length \n Length codes 257..285 base "
2018/06/19 20:06:44 " Length codes 257..285 extra "
2018/06/19 20:06:44 " Distance codes 0..29 base "
2018/06/19 20:06:44 " Distance codes 0..29 extra "
2018/06/19 20:06:44 "\n       Process a set of code lengths to create a canonical Huffman code.  The\n       code lengths are lens[0..codes-1].  Each length corresponds to the\n       symbols 0..codes-1.  The Huffman code is generated by first sorting the\n       symbols by length from short to long, and retaining the symbol order\n       for codes with equal lengths.  Then the code starts with all zero bits\n       for the first code of the shortest length, and the codes are integer\n       increments for the same length, and zeros are appended as the length\n       increases.  For the deflate format, these bits are stored backwards\n       from their more natural integer increment ordering, and so when the\n       decoding tables are built in the large loop below, the integer codes\n       are incremented backwards.\n\n       This routine assumes, but does not check, that all of the entries in\n       lens[] are in the range 0..MAXBITS.  The caller must assure this.\n       1..MAXBITS is interpreted as that code length.  zero means that that\n       symbol does not occur in this code.\n\n       The codes are sorted by computing a count of codes for each length,\n       creating from that a table of starting indices for each length in the\n       sorted table, and then entering the symbols in order in the sorted\n       table.  The sorted table is work[], with that space being provided by\n       the caller.\n\n       The length counts are used for other purposes as well, i.e. finding\n       the minimum and maximum length codes, determining if there are any\n       codes at all, checking for a valid set of lengths, and looking ahead\n       at length counts to determine sub-table sizes when building the\n       decoding tables.\n     "
2018/06/19 20:06:44 " accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) "
2018/06/19 20:06:44 " bound code lengths, force root to be within code lengths "
2018/06/19 20:06:44 " no symbols to code at all \n invalid code marker "
2018/06/19 20:06:44 " make a table to force an error "
2018/06/19 20:06:44 " no symbols, but wait for decoding to report error "
2018/06/19 20:06:44 " check for an over-subscribed or incomplete set of lengths "
2018/06/19 20:06:44 " over-subscribed "
2018/06/19 20:06:44 " incomplete set "
2018/06/19 20:06:44 " generate offsets into symbol table for each length for sorting "
2018/06/19 20:06:44 " sort symbols by length, by symbol order within each length "
2018/06/19 20:06:44 "\n       Create and fill in decoding tables.  In this loop, the table being\n       filled is at next and has curr index bits.  The code being used is huff\n       with length len.  That code is converted to an index by dropping drop\n       bits off of the bottom.  For codes where len is less than drop + curr,\n       those top drop + curr - len bits are incremented through all values to\n       fill the table with replicated entries.\n\n       root is the number of index bits for the root table.  When len exceeds\n       root, sub-tables are created pointed to by the root entry with an index\n       of the low root bits of huff.  This is saved in low to check for when a\n       new sub-table should be started.  drop is zero when the root table is\n       being filled, and drop is root when sub-tables are being filled.\n\n       When a new sub-table is needed, it is necessary to look ahead in the\n       code lengths to determine what size sub-table is needed.  The length\n       counts are used for this, and so count[] is decremented as codes are\n       entered in the tables.\n\n       used keeps track of how many table entries have been allocated from the\n       provided *table space.  It is checked for LENS and DIST tables against\n       the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n       the initial root table size constants.  See the comments in inftrees.h\n       for more information.\n\n       sym increments through all symbols, and the loop terminates when\n       all codes of length max, i.e. all codes, have been processed.  This\n       routine permits incomplete codes, so another loop after this one fills\n       in the rest of the decoding tables with invalid code markers.\n     "
2018/06/19 20:06:44 " set up for code type "
2018/06/19 20:06:44 " dummy value--not used "
2018/06/19 20:06:44 " DISTS "
2018/06/19 20:06:44 " initialize state for loop \n starting code \n starting code symbol \n starting code length \n current table to fill in \n current table index bits \n current bits to drop from code for index \n trigger new sub-table when len > root \n use root table entries \n mask for comparing low "
2018/06/19 20:06:44 " check available table space "
2018/06/19 20:06:44 " process all codes and make table entries "
2018/06/19 20:06:44 " create table entry "
2018/06/19 20:06:44 " end of block "
2018/06/19 20:06:44 " replicate for those indices with low len bits equal to huff "
2018/06/19 20:06:44 " save offset to next table "
2018/06/19 20:06:44 " backwards increment the len-bit code huff "
2018/06/19 20:06:44 " go to next symbol, update count, len "
2018/06/19 20:06:44 " create new sub-table if needed "
2018/06/19 20:06:44 " if first time, transition to sub-tables "
2018/06/19 20:06:44 " increment past last table \n here min is 1 << curr "
2018/06/19 20:06:44 " determine length of next table "
2018/06/19 20:06:44 " check for enough space "
2018/06/19 20:06:44 " point entry in root table to sub-table "
2018/06/19 20:06:44 " fill in remaining table entry if code is incomplete (guaranteed to have\n       at most one remaining entry, since if the code is incomplete, the\n       maximum code length that was allowed to get this far is one bit) "
2018/06/19 20:06:44 " invalid code marker "
2018/06/19 20:06:44 " set return parameters "
2018/06/19 20:06:44 Finished Classifying License "/zlib-1.2.11.tar.gz/inftrees.c": 47.59265ms
2018/06/19 20:06:44 Couldn't classify license(s)
2018/06/19 20:06:44 Classifying license(s): /zlib-1.2.11.tar.gz/examples/zpipe.c
2018/06/19 20:06:44 detected language: 4
2018/06/19 20:06:44 " zpipe.c: example of proper use of zlib's inflate() and deflate()\n   Not copyrighted -- provided to the public domain\n   Version 1.4  11 December 2005  Mark Adler "
2018/06/19 20:06:44 " Version history:\n   1.0  30 Oct 2004  First version\n   1.1   8 Nov 2004  Add void casting for unused return values\n                     Use switch statement for inflate() return values\n   1.2   9 Nov 2004  Add assertions to document zlib guarantees\n   1.3   6 Apr 2005  Remove incorrect assertion in inf()\n   1.4  11 Dec 2005  Add hack to avoid MSDOS end-of-line conversions\n                     Avoid some compiler warnings for input and output buffers\n "
2018/06/19 20:06:44 " Compress from file source to file dest until EOF on source.\n   def() returns Z_OK on success, Z_MEM_ERROR if memory could not be\n   allocated for processing, Z_STREAM_ERROR if an invalid compression\n   level is supplied, Z_VERSION_ERROR if the version of zlib.h and the\n   version of the library linked do not match, or Z_ERRNO if there is\n   an error reading or writing the files. "
2018/06/19 20:06:44 " allocate deflate state "
2018/06/19 20:06:44 " compress until end of file "
2018/06/19 20:06:44 " run deflate() on input until output buffer not full, finish\n           compression if all of source has been read in "
2018/06/19 20:06:44 " no bad return value \n state not clobbered "
2018/06/19 20:06:44 " all input will be used "
2018/06/19 20:06:44 " done when last data in file processed "
2018/06/19 20:06:44 " stream will be complete "
2018/06/19 20:06:44 " clean up and return "
2018/06/19 20:06:44 " Decompress from file source to file dest until stream ends or EOF.\n   inf() returns Z_OK on success, Z_MEM_ERROR if memory could not be\n   allocated for processing, Z_DATA_ERROR if the deflate data is\n   invalid or incomplete, Z_VERSION_ERROR if the version of zlib.h and\n   the version of the library linked do not match, or Z_ERRNO if there\n   is an error reading or writing the files. "
2018/06/19 20:06:44 " allocate inflate state "
2018/06/19 20:06:44 " decompress until deflate stream ends or end of file "
2018/06/19 20:06:44 " run inflate() on input until output buffer not full "
2018/06/19 20:06:44 " state not clobbered "
2018/06/19 20:06:44 " and fall through "
2018/06/19 20:06:44 " done when inflate() says it's done "
2018/06/19 20:06:44 " clean up and return "
2018/06/19 20:06:44 " report a zlib or i/o error "
2018/06/19 20:06:44 " compress or decompress from stdin to stdout "
2018/06/19 20:06:44 " avoid end-of-line conversions "
2018/06/19 20:06:44 " do compression if no arguments "
2018/06/19 20:06:44 " do decompression if -d specified "
2018/06/19 20:06:44 " otherwise, report usage "
2018/06/19 20:06:44 Finished Classifying License "/zlib-1.2.11.tar.gz/examples/zpipe.c": 19.608259ms
2018/06/19 20:06:44 Couldn't classify license(s)
2018/06/19 20:06:45 Classifying license(s): /zlib-1.2.11.tar.gz/examples/fitblk.c
2018/06/19 20:06:45 detected language: 4
2018/06/19 20:06:45 " fitblk.c: example of fitting compressed output to a specified size\n   Not copyrighted -- provided to the public domain\n   Version 1.1  25 November 2004  Mark Adler "
2018/06/19 20:06:45 " Version history:\n   1.0  24 Nov 2004  First version\n   1.1  25 Nov 2004  Change deflateInit2() to deflateInit()\n                     Use fixed-size, stack-allocated raw buffers\n                     Simplify code moving compression to subroutines\n                     Use assert() for internal errors\n                     Add detailed description of approach\n "
2018/06/19 20:06:45 " Approach to just fitting a requested compressed size:\n\n   fitblk performs three compression passes on a portion of the input\n   data in order to determine how much of that input will compress to\n   nearly the requested output block size.  The first pass generates\n   enough deflate blocks to produce output to fill the requested\n   output size plus a specfied excess amount (see the EXCESS define\n   below).  The last deflate block may go quite a bit past that, but\n   is discarded.  The second pass decompresses and recompresses just\n   the compressed data that fit in the requested plus excess sized\n   buffer.  The deflate process is terminated after that amount of\n   input, which is less than the amount consumed on the first pass.\n   The last deflate block of the result will be of a comparable size\n   to the final product, so that the header for that deflate block and\n   the compression ratio for that block will be about the same as in\n   the final product.  The third compression pass decompresses the\n   result of the second step, but only the compressed data up to the\n   requested size minus an amount to allow the compressed stream to\n   complete (see the MARGIN define below).  That will result in a\n   final compressed stream whose length is less than or equal to the\n   requested size.  Assuming sufficient input and a requested size\n   greater than a few hundred bytes, the shortfall will typically be\n   less than ten bytes.\n\n   If the input is short enough that the first compression completes\n   before filling the requested output size, then that compressed\n   stream is return with no recompression.\n\n   EXCESS is chosen to be just greater than the shortfall seen in a\n   two pass approach similar to the above.  That shortfall is due to\n   the last deflate block compressing more efficiently with a smaller\n   header on the second pass.  EXCESS is set to be large enough so\n   that there is enough uncompressed data for the second pass to fill\n   out the requested size, and small enough so that the final deflate\n   block of the second pass will be close in size to the final deflate\n   block of the third and final pass.  MARGIN is chosen to be just\n   large enough to assure that the final compression has enough room\n   to complete in all cases.\n "
2018/06/19 20:06:45 " print nastygram and leave "
2018/06/19 20:06:45 " intermediate uncompressed buffer size "
2018/06/19 20:06:45 " compress from file to def until provided buffer is full or end of\n   input reached; return last deflate() return value, or Z_ERRNO if\n   there was read error on the file "
2018/06/19 20:06:45 " recompress from inf's input to def's output; the input for inf and\n   the output for def are set in those structures before calling;\n   return last deflate() return value, or Z_MEM_ERROR if inflate()\n   was not able to allocate enough memory when it needed to "
2018/06/19 20:06:45 " decompress "
2018/06/19 20:06:45 " compress what was decompresed until done or no room "
2018/06/19 20:06:45 " empirically determined stream overage \n amount to back off for completion "
2018/06/19 20:06:45 " compress from stdin to fixed-size block on stdout "
2018/06/19 20:06:45 " return code \n requested fixed output block size \n bytes written by deflate() call \n intermediate and final stream \n close to desired size stream \n zlib deflate and inflate states "
2018/06/19 20:06:45 " get requested output size "
2018/06/19 20:06:45 " 8 is minimum zlib stream size "
2018/06/19 20:06:45 " allocate memory for buffers and compression engine "
2018/06/19 20:06:45 " compress from stdin until output full, or no more input "
2018/06/19 20:06:45 " if it all fit, then size was undersubscribed -- done! "
2018/06/19 20:06:45 " write block to stdout "
2018/06/19 20:06:45 " clean up and print results to stderr "
2018/06/19 20:06:45 " it didn't all fit -- set up for recompression "
2018/06/19 20:06:45 " do first recompression close to the right amount "
2018/06/19 20:06:45 " set up for next reocmpression "
2018/06/19 20:06:45 " do second and final recompression (third compression) \n assure stream will complete "
2018/06/19 20:06:45 " otherwise MARGIN too small "
2018/06/19 20:06:45 " done -- write block to stdout "
2018/06/19 20:06:45 " clean up and print results to stderr "
2018/06/19 20:06:45 Finished Classifying License "/zlib-1.2.11.tar.gz/examples/fitblk.c": 19.604003ms
2018/06/19 20:06:45 Couldn't classify license(s)
2018/06/19 20:06:46 Classifying license(s): /zlib-1.2.11.tar.gz/examples/gzlog.c
2018/06/19 20:06:46 detected language: 4
2018/06/19 20:06:46 "\n * gzlog.c\n * Copyright (C) 2004, 2008, 2012, 2016 Mark Adler, all rights reserved\n * For conditions of distribution and use, see copyright notice in gzlog.h\n * version 2.2, 14 Aug 2012\n "
2018/06/19 20:06:46 "\n   gzlog provides a mechanism for frequently appending short strings to a gzip\n   file that is efficient both in execution time and compression ratio.  The\n   strategy is to write the short strings in an uncompressed form to the end of\n   the gzip file, only compressing when the amount of uncompressed data has\n   reached a given threshold.\n\n   gzlog also provides protection against interruptions in the process due to\n   system crashes.  The status of the operation is recorded in an extra field\n   in the gzip file, and is only updated once the gzip file is brought to a\n   valid state.  The last data to be appended or compressed is saved in an\n   auxiliary file, so that if the operation is interrupted, it can be completed\n   the next time an append operation is attempted.\n\n   gzlog maintains another auxiliary file with the last 32K of data from the\n   compressed portion, which is preloaded for the compression of the subsequent\n   data.  This minimizes the impact to the compression ratio of appending.\n "
2018/06/19 20:06:46 "\n   Operations Concept:\n\n   Files (log name \"foo\"):\n   foo.gz -- gzip file with the complete log\n   foo.add -- last message to append or last data to compress\n   foo.dict -- dictionary of the last 32K of data for next compression\n   foo.temp -- temporary dictionary file for compression after this one\n   foo.lock -- lock file for reading and writing the other files\n   foo.repairs -- log file for log file recovery operations (not compressed)\n\n   gzip file structure:\n   - fixed-length (no file name) header with extra field (see below)\n   - compressed data ending initially with empty stored block\n   - uncompressed data filling out originally empty stored block and\n     subsequent stored blocks as needed (16K max each)\n   - gzip trailer\n   - no junk at end (no other gzip streams)\n\n   When appending data, the information in the first three items above plus the\n   foo.add file are sufficient to recover an interrupted append operation.  The\n   extra field has the necessary information to restore the start of the last\n   stored block and determine where to append the data in the foo.add file, as\n   well as the crc and length of the gzip data before the append operation.\n\n   The foo.add file is created before the gzip file is marked for append, and\n   deleted after the gzip file is marked as complete.  So if the append\n   operation is interrupted, the data to add will still be there.  If due to\n   some external force, the foo.add file gets deleted between when the append\n   operation was interrupted and when recovery is attempted, the gzip file will\n   still be restored, but without the appended data.\n\n   When compressing data, the information in the first two items above plus the\n   foo.add file are sufficient to recover an interrupted compress operation.\n   The extra field has the necessary information to find the end of the\n   compressed data, and contains both the crc and length of just the compressed\n   data and of the complete set of data including the contents of the foo.add\n   file.\n\n   Again, the foo.add file is maintained during the compress operation in case\n   of an interruption.  If in the unlikely event the foo.add file with the data\n   to be compressed is missing due to some external force, a gzip file with\n   just the previous compressed data will be reconstructed.  In this case, all\n   of the data that was to be compressed is lost (approximately one megabyte).\n   This will not occur if all that happened was an interruption of the compress\n   operation.\n\n   The third state that is marked is the replacement of the old dictionary with\n   the new dictionary after a compress operation.  Once compression is\n   complete, the gzip file is marked as being in the replace state.  This\n   completes the gzip file, so an interrupt after being so marked does not\n   result in recompression.  Then the dictionary file is replaced, and the gzip\n   file is marked as completed.  This state prevents the possibility of\n   restarting compression with the wrong dictionary file.\n\n   All three operations are wrapped by a lock/unlock procedure.  In order to\n   gain exclusive access to the log files, first a foo.lock file must be\n   exclusively created.  When all operations are complete, the lock is\n   released by deleting the foo.lock file.  If when attempting to create the\n   lock file, it already exists and the modify time of the lock file is more\n   than five minutes old (set by the PATIENCE define below), then the old\n   lock file is considered stale and deleted, and the exclusive creation of\n   the lock file is retried.  To assure that there are no false assessments\n   of the staleness of the lock file, the operations periodically touch the\n   lock file to update the modified date.\n\n   Following is the definition of the extra field with all of the information\n   required to enable the above append and compress operations and their\n   recovery if interrupted.  Multi-byte values are stored little endian\n   (consistent with the gzip format).  File pointers are eight bytes long.\n   The crc's and lengths for the gzip trailer are four bytes long.  (Note that\n   the length at the end of a gzip file is used for error checking only, and\n   for large files is actually the length modulo 2^32.)  The stored block\n   length is two bytes long.  The gzip extra field two-byte identification is\n   \"ap\" for append.  It is assumed that writing the extra field to the file is\n   an \"atomic\" operation.  That is, either all of the extra field is written\n   to the file, or none of it is, if the operation is interrupted right at the\n   point of updating the extra field.  This is a reasonable assumption, since\n   the extra field is within the first 52 bytes of the file, which is smaller\n   than any expected block size for a mass storage device (usually 512 bytes or\n   larger).\n\n   Extra field (35 bytes):\n   - Pointer to first stored block length -- this points to the two-byte length\n     of the first stored block, which is followed by the two-byte, one's\n     complement of that length.  The stored block length is preceded by the\n     three-bit header of the stored block, which is the actual start of the\n     stored block in the deflate format.  See the bit offset field below.\n   - Pointer to the last stored block length.  This is the same as above, but\n     for the last stored block of the uncompressed data in the gzip file.\n     Initially this is the same as the first stored block length pointer.\n     When the stored block gets to 16K (see the MAX_STORE define), then a new\n     stored block as added, at which point the last stored block length pointer\n     is different from the first stored block length pointer.  When they are\n     different, the first bit of the last stored block header is eight bits, or\n     one byte back from the block length.\n   - Compressed data crc and length.  This is the crc and length of the data\n     that is in the compressed portion of the deflate stream.  These are used\n     only in the event that the foo.add file containing the data to compress is\n     lost after a compress operation is interrupted.\n   - Total data crc and length.  This is the crc and length of all of the data\n     stored in the gzip file, compressed and uncompressed.  It is used to\n     reconstruct the gzip trailer when compressing, as well as when recovering\n     interrupted operations.\n   - Final stored block length.  This is used to quickly find where to append,\n     and allows the restoration of the original final stored block state when\n     an append operation is interrupted.\n   - First stored block start as the number of bits back from the final stored\n     block first length byte.  This value is in the range of 3..10, and is\n     stored as the low three bits of the final byte of the extra field after\n     subtracting three (0..7).  This allows the last-block bit of the stored\n     block header to be updated when a new stored block is added, for the case\n     when the first stored block and the last stored block are the same.  (When\n     they are different, the numbers of bits back is known to be eight.)  This\n     also allows for new compressed data to be appended to the old compressed\n     data in the compress operation, overwriting the previous first stored\n     block, or for the compressed data to be terminated and a valid gzip file\n     reconstructed on the off chance that a compression operation was\n     interrupted and the data to compress in the foo.add file was deleted.\n   - The operation in process.  This is the next two bits in the last byte (the\n     bits under the mask 0x18).  The are interpreted as 0: nothing in process,\n     1: append in process, 2: compress in process, 3: replace in process.\n   - The top three bits of the last byte in the extra field are reserved and\n     are currently set to zero.\n\n   Main procedure:\n   - Exclusively create the foo.lock file using the O_CREAT and O_EXCL modes of\n     the system open() call.  If the modify time of an existing lock file is\n     more than PATIENCE seconds old, then the lock file is deleted and the\n     exclusive create is retried.\n   - Load the extra field from the foo.gz file, and see if an operation was in\n     progress but not completed.  If so, apply the recovery procedure below.\n   - Perform the append procedure with the provided data.\n   - If the uncompressed data in the foo.gz file is 1MB or more, apply the\n     compress procedure.\n   - Delete the foo.lock file.\n\n   Append procedure:\n   - Put what to append in the foo.add file so that the operation can be\n     restarted if this procedure is interrupted.\n   - Mark the foo.gz extra field with the append operation in progress.\n   + Restore the original last-block bit and stored block length of the last\n     stored block from the information in the extra field, in case a previous\n     append operation was interrupted.\n   - Append the provided data to the last stored block, creating new stored\n     blocks as needed and updating the stored blocks last-block bits and\n     lengths.\n   - Update the crc and length with the new data, and write the gzip trailer.\n   - Write over the extra field (with a single write operation) with the new\n     pointers, lengths, and crc's, and mark the gzip file as not in process.\n     Though there is still a foo.add file, it will be ignored since nothing\n     is in process.  If a foo.add file is leftover from a previously\n     completed operation, it is truncated when writing new data to it.\n   - Delete the foo.add file.\n\n   Compress and replace procedures:\n   - Read all of the uncompressed data in the stored blocks in foo.gz and write\n     it to foo.add.  Also write foo.temp with the last 32K of that data to\n     provide a dictionary for the next invocation of this procedure.\n   - Rewrite the extra field marking foo.gz with a compression in process.\n   * If there is no data provided to compress (due to a missing foo.add file\n     when recovering), reconstruct and truncate the foo.gz file to contain\n     only the previous compressed data and proceed to the step after the next\n     one.  Otherwise ...\n   - Compress the data with the dictionary in foo.dict, and write to the\n     foo.gz file starting at the bit immediately following the last previously\n     compressed block.  If there is no foo.dict, proceed anyway with the\n     compression at slightly reduced efficiency.  (For the foo.dict file to be\n     missing requires some external failure beyond simply the interruption of\n     a compress operation.)  During this process, the foo.lock file is\n     periodically touched to assure that that file is not considered stale by\n     another process before we're done.  The deflation is terminated with a\n     non-last empty static block (10 bits long), that is then located and\n     written over by a last-bit-set empty stored block.\n   - Append the crc and length of the data in the gzip file (previously\n     calculated during the append operations).\n   - Write over the extra field with the updated stored block offsets, bits\n     back, crc's, and lengths, and mark foo.gz as in process for a replacement\n     of the dictionary.\n   @ Delete the foo.add file.\n   - Replace foo.dict with foo.temp.\n   - Write over the extra field, marking foo.gz as complete.\n\n   Recovery procedure:\n   - If not a replace recovery, read in the foo.add file, and provide that data\n     to the appropriate recovery below.  If there is no foo.add file, provide\n     a zero data length to the recovery.  In that case, the append recovery\n     restores the foo.gz to the previous compressed + uncompressed data state.\n     For the the compress recovery, a missing foo.add file results in foo.gz\n     being restored to the previous compressed-only data state.\n   - Append recovery:\n     - Pick up append at + step above\n   - Compress recovery:\n     - Pick up compress at * step above\n   - Replace recovery:\n     - Pick up compress at @ step above\n   - Log the repair with a date stamp in foo.repairs\n "
2018/06/19 20:06:46 " rename, fopen, fprintf, fclose \n malloc, free \n strlen, strrchr, strcpy, strncpy, strcmp \n open \n lseek, read, write, close, unlink, sleep, \n ftruncate, fsync \n errno \n time, ctime \n stat \n utimes \n crc32 "
2018/06/19 20:06:46 " header for external access "
2018/06/19 20:06:46 " Macro for debugging to deterministically force recovery operations "
2018/06/19 20:06:46 " longjmp \n where to go back to \n which point to bail at (1..8) \n number of times through to wait "
2018/06/19 20:06:46 " how old the lock file can be in seconds before considering it stale "
2018/06/19 20:06:46 " maximum stored block size in Kbytes -- must be in 1..63 "
2018/06/19 20:06:46 " number of stored Kbytes to trigger compression (must be >= 32 to allow\n   dictionary construction, and <= 204 * MAX_STORE, in order for >> 10 to\n   discard the stored block headers contribution of five bytes each) "
2018/06/19 20:06:46 " size of a deflate dictionary (this cannot be changed) "
2018/06/19 20:06:46 " values for the operation (2 bits) "
2018/06/19 20:06:46 " macros to extract little-endian integers from an unsigned byte buffer "
2018/06/19 20:06:46 " macros to store integers into a byte buffer in little-endian order "
2018/06/19 20:06:46 " internal structure for log information \n should be three non-zero characters "
2018/06/19 20:06:46 " contains LOGID to detect inadvertent overwrites \n file descriptor for .gz file, opened read/write \n allocated path, e.g. \"/var/log/foo\" or \"foo\" \n end of path, for appending suffices such as \".gz\" \n offset of first stored block first length byte \n location of first block id in bits back from first \n bytes currently in last stored block \n offset of last stored block first length byte \n crc of compressed data \n length (modulo 2^32) of compressed data \n crc of total data \n length (modulo 2^32) of total data \n last modify time of our lock file "
2018/06/19 20:06:46 " gzip header for gzlog "
2018/06/19 20:06:46 " magic gzip id \n compression method is deflate \n there is an extra field (no file name) \n no modification time provided \n no extra flags, no OS specified \n extra field with \"ap\" subfield \n 35 is EXTRA, 39 is EXTRA + 4 "
2018/06/19 20:06:46 " should be 16 "
2018/06/19 20:06:46 " initial gzip extra field content (52 == HEAD + EXTRA + 1) "
2018/06/19 20:06:46 " offset of first stored block length \n offset of last stored block length \n compressed data crc and length \n total data crc and length \n final stored block data length \n op is NO_OP, last bit 8 bits back "
2018/06/19 20:06:46 " should be 35 "
2018/06/19 20:06:46 " initial gzip data and trailer "
2018/06/19 20:06:46 " empty stored block (last) \n crc \n uncompressed length "
2018/06/19 20:06:46 " Exclusively create foo.lock in order to negotiate exclusive access to the\n   foo.* files.  If the modify time of an existing lock file is greater than\n   PATIENCE seconds in the past, then consider the lock file to have been\n   abandoned, delete it, and try the exclusive create again.  Save the lock\n   file modify time for verification of ownership.  Return 0 on success, or -1\n   on failure, usually due to an access restriction or invalid path.  Note that\n   if stat() or unlink() fails, it may be due to another process noticing the\n   abandoned lock file a smidge sooner and deleting it, so those are not\n   flagged as an error. "
2018/06/19 20:06:46 " relinquish the CPU for two seconds while waiting "
2018/06/19 20:06:46 " Update the modify time of the lock file to now, in order to prevent another\n   task from thinking that the lock is stale.  Save the lock file modify time\n   for verification of ownership. "
2018/06/19 20:06:46 " Check the log file modify time against what is expected.  Return true if\n   this is not our lock.  If it is our lock, touch it to keep it. "
2018/06/19 20:06:46 " Unlock a previously acquired lock, but only if it's ours. "
2018/06/19 20:06:46 " Check the gzip header and read in the extra field, filling in the values in\n   the log structure.  Return op on success or -1 if the gzip header was not as\n   expected.  op is the current operation in progress last written to the extra\n   field.  This assumes that the gzip file has already been opened, with the\n   file descriptor log->fd. "
2018/06/19 20:06:46 " Write over the extra field contents, marking the operation as op.  Use fsync\n   to assure that the device is written to, and in the requested order.  This\n   operation, and only this operation, is assumed to be atomic in order to\n   assure that the log is recoverable in the event of an interruption at any\n   point in the process.  Return -1 if the write to foo.gz failed. "
2018/06/19 20:06:46 " Rewrite the last block header bits and subsequent zero bits to get to a byte\n   boundary, setting the last block bit if last is true, and then write the\n   remainder of the stored block header (length and one's complement).  Leave\n   the file pointer after the end of the last stored block data.  Return -1 if\n   there is a read or write failure on the foo.gz file "
2018/06/19 20:06:46 " determine the locations of the bytes and bits to modify "
2018/06/19 20:06:46 " bytes back from log->last \n mask for block last-bit "
2018/06/19 20:06:46 " get the byte to modify (one or two back) into buf[0] -- don't need to\n       read the byte if the last-bit is eight bits back, since in that case\n       the entire byte will be modified "
2018/06/19 20:06:46 " change the last-bit of the last stored block as requested -- note\n       that all bits above the last-bit are set to zero, per the type bits\n       of a stored block being 00 and per the convention that the bits to\n       bring the stream to a byte boundary are also zeros "
2018/06/19 20:06:46 " write the modified stored block header and lengths, move the file\n       pointer to after the last stored block data "
2018/06/19 20:06:46 " Append len bytes from data to the locked and open log file.  len may be zero\n   if recovering and no .add file was found.  In that case, the previous state\n   of the foo.gz file is restored.  The data is appended uncompressed in\n   deflate stored blocks.  Return -1 if there was an error reading or writing\n   the foo.gz file. "
2018/06/19 20:06:46 " set the last block last-bit and length, in case recovering an\n       interrupted append, then position the file pointer to append to the\n       block "
2018/06/19 20:06:46 " append, adding stored blocks and updating the offset of the last stored\n       block as needed, and update the total crc and length "
2018/06/19 20:06:46 " append as much as we can to the last block "
2018/06/19 20:06:46 " if we need to, add a new empty stored block "
2018/06/19 20:06:46 " mark current block as not last "
2018/06/19 20:06:46 " point to new, empty stored block "
2018/06/19 20:06:46 " mark last block as last, update its length "
2018/06/19 20:06:46 " write the new crc and length trailer, and truncate just in case (could\n       be recovering from partial append with a missing foo.add file) "
2018/06/19 20:06:46 " write the extra field, marking the log file as done, delete .add file "
2018/06/19 20:06:46 " ignore error, since may not exist "
2018/06/19 20:06:46 " Replace the foo.dict file with the foo.temp file.  Also delete the foo.add\n   file, since the compress operation may have been interrupted before that was\n   done.  Returns 1 if memory could not be allocated, or -1 if reading or\n   writing foo.gz fails, or if the rename fails for some reason other than\n   foo.temp not existing.  foo.temp not existing is a permitted error, since\n   the replace operation may have been interrupted after the rename is done,\n   but before foo.gz is marked as complete. "
2018/06/19 20:06:46 " delete foo.add file "
2018/06/19 20:06:46 " ignore error, since may not exist "
2018/06/19 20:06:46 " rename foo.name to foo.dict, replacing foo.dict if it exists "
2018/06/19 20:06:46 " mark the foo.gz file as done "
2018/06/19 20:06:46 " Compress the len bytes at data and append the compressed data to the\n   foo.gz deflate data immediately after the previous compressed data.  This\n   overwrites the previous uncompressed data, which was stored in foo.add\n   and is the data provided in data[0..len-1].  If this operation is\n   interrupted, it picks up at the start of this routine, with the foo.add\n   file read in again.  If there is no data to compress (len == 0), then we\n   simply terminate the foo.gz file after the previously compressed data,\n   appending a final empty stored block and the gzip trailer.  Return -1 if\n   reading or writing the log.gz file failed, or -2 if there was a memory\n   allocation failure. "
2018/06/19 20:06:46 " compress and append compressed data "
2018/06/19 20:06:46 " set up for deflate, allocating memory "
2018/06/19 20:06:46 " read in dictionary (last 32K of data that was compressed) "
2018/06/19 20:06:46 " prime deflate with last bits of previous block, position write\n           pointer to write those bits and overwrite what follows "
2018/06/19 20:06:46 " compress, finishing with a partial non-last empty static block "
2018/06/19 20:06:46 " in case int smaller than size_t "
2018/06/19 20:06:46 " find start of empty static block -- scanning backwards the first one\n           bit is the second bit of the block, if the last byte is zero, then\n           we know the byte before that has a one in the top bit, since an\n           empty static block is ten bits long "
2018/06/19 20:06:46 " guaranteed to terminate, since *buf != 0 "
2018/06/19 20:06:46 " update compressed crc and length "
2018/06/19 20:06:46 " no data to compress -- fix up existing gzip stream "
2018/06/19 20:06:46 " complete and truncate gzip stream "
2018/06/19 20:06:46 " mark as being in the replace operation "
2018/06/19 20:06:46 " execute the replace operation and mark the file as done "
2018/06/19 20:06:46 " log a repair record to the .repairs file "
2018/06/19 20:06:46 " Recover the interrupted operation op.  First read foo.add for recovering an\n   append or compress operation.  Return -1 if there was an error reading or\n   writing foo.gz or reading an existing foo.add, or -2 if there was a memory\n   allocation failure. "
2018/06/19 20:06:46 " log recovery "
2018/06/19 20:06:46 " load foo.add file if expected and present "
2018/06/19 20:06:46 " recover the interrupted operation "
2018/06/19 20:06:46 " log status "
2018/06/19 20:06:46 " clean up "
2018/06/19 20:06:46 " Close the foo.gz file (if open) and release the lock. "
2018/06/19 20:06:46 " Open foo.gz, verify the header, and load the extra field contents, after\n   first creating the foo.lock file to gain exclusive access to the foo.*\n   files.  If foo.gz does not exist or is empty, then write the initial header,\n   extra, and body content of an empty foo.gz log file.  If there is an error\n   creating the lock file due to access restrictions, or an error reading or\n   writing the foo.gz file, or if the foo.gz file is not a proper log file for\n   this object (e.g. not a gzip file or does not contain the expected extra\n   field), then return true.  If there is an error, the lock is released.\n   Otherwise, the lock is left in place. "
2018/06/19 20:06:46 " release open file resource if left over -- can occur if lock lost\n       between gzlog_open() and gzlog_write() "
2018/06/19 20:06:46 " negotiate exclusive access "
2018/06/19 20:06:46 " open the log file, foo.gz "
2018/06/19 20:06:46 " if new, initialize foo.gz with an empty log, delete old dictionary "
2018/06/19 20:06:46 " verify log file and load extra field information "
2018/06/19 20:06:46 " check for interrupted process and if so, recover "
2018/06/19 20:06:46 " touch the lock file to prevent another process from grabbing it "
2018/06/19 20:06:46 " See gzlog.h for the description of the external methods below "
2018/06/19 20:06:46 " check arguments "
2018/06/19 20:06:46 " allocate and initialize log structure "
2018/06/19 20:06:46 " save path and end of path for name construction "
2018/06/19 20:06:46 " allow for \".repairs\" "
2018/06/19 20:06:46 " gain exclusive access and verify log file -- may perform a\n       recovery operation if needed "
2018/06/19 20:06:46 " return pointer to log structure "
2018/06/19 20:06:46 " gzlog_compress() return values:\n    0: all good\n   -1: file i/o error (usually access issue)\n   -2: memory allocation failure\n   -3: invalid log pointer argument "
2018/06/19 20:06:46 " check arguments "
2018/06/19 20:06:46 " see if we lost the lock -- if so get it again and reload the extra\n       field information (it probably changed), recover last operation if\n       necessary "
2018/06/19 20:06:46 " create space for uncompressed data "
2018/06/19 20:06:46 " do statement here is just a cheap trick for error handling "
2018/06/19 20:06:46 " read in the uncompressed data "
2018/06/19 20:06:46 " write the uncompressed data to the .add file "
2018/06/19 20:06:46 " write the dictionary for the next compress to the .temp file "
2018/06/19 20:06:46 " roll back to compressed data, mark the compress in progress "
2018/06/19 20:06:46 " compress and append the data (clears mark) "
2018/06/19 20:06:46 " broke out of do above on i/o error "
2018/06/19 20:06:46 " gzlog_write() return values:\n    0: all good\n   -1: file i/o error (usually access issue)\n   -2: memory allocation failure\n   -3: invalid log pointer argument "
2018/06/19 20:06:46 " check arguments "
2018/06/19 20:06:46 " see if we lost the lock -- if so get it again and reload the extra\n       field information (it probably changed), recover last operation if\n       necessary "
2018/06/19 20:06:46 " create and write .add file "
2018/06/19 20:06:46 " mark log file with append in progress "
2018/06/19 20:06:46 " append data (clears mark) "
2018/06/19 20:06:46 " check to see if it's time to compress -- if not, then done "
2018/06/19 20:06:46 " time to compress "
2018/06/19 20:06:46 " gzlog_close() return values:\n    0: ok\n   -3: invalid log pointer argument "
2018/06/19 20:06:46 " check arguments "
2018/06/19 20:06:46 " close the log file and release the lock "
2018/06/19 20:06:46 " free structure and return "
2018/06/19 20:06:46 Finished Classifying License "/zlib-1.2.11.tar.gz/examples/gzlog.c": 77.391022ms
2018/06/19 20:06:46 Couldn't classify license(s)
2018/06/19 20:06:47 Classifying license(s): /zlib-1.2.11.tar.gz/examples/gzlog.h
2018/06/19 20:06:47 detected language: 4
2018/06/19 20:06:47 " gzlog.h\n  Copyright (C) 2004, 2008, 2012 Mark Adler, all rights reserved\n  version 2.2, 14 Aug 2012\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the author be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n\n  Mark Adler    madler@alumni.caltech.edu\n "
2018/06/19 20:06:47 " Version History:\n   1.0  26 Nov 2004  First version\n   2.0  25 Apr 2008  Complete redesign for recovery of interrupted operations\n                     Interface changed slightly in that now path is a prefix\n                     Compression now occurs as needed during gzlog_write()\n                     gzlog_write() now always leaves the log file as valid gzip\n   2.1   8 Jul 2012  Fix argument checks in gzlog_compress() and gzlog_write()\n   2.2  14 Aug 2012  Clean up signed comparisons\n "
2018/06/19 20:06:47 "\n   The gzlog object allows writing short messages to a gzipped log file,\n   opening the log file locked for small bursts, and then closing it.  The log\n   object works by appending stored (uncompressed) data to the gzip file until\n   1 MB has been accumulated.  At that time, the stored data is compressed, and\n   replaces the uncompressed data in the file.  The log file is truncated to\n   its new size at that time.  After each write operation, the log file is a\n   valid gzip file that can decompressed to recover what was written.\n\n   The gzlog operations can be interupted at any point due to an application or\n   system crash, and the log file will be recovered the next time the log is\n   opened with gzlog_open().\n "
2018/06/19 20:06:47 " gzlog object type "
2018/06/19 20:06:47 " Open a gzlog object, creating the log file if it does not exist.  Return\n   NULL on error.  Note that gzlog_open() could take a while to complete if it\n   has to wait to verify that a lock is stale (possibly for five minutes), or\n   if there is significant contention with other instantiations of this object\n   when locking the resource.  path is the prefix of the file names created by\n   this object.  If path is \"foo\", then the log file will be \"foo.gz\", and\n   other auxiliary files will be created and destroyed during the process:\n   \"foo.dict\" for a compression dictionary, \"foo.temp\" for a temporary (next)\n   dictionary, \"foo.add\" for data being added or compressed, \"foo.lock\" for the\n   lock file, and \"foo.repairs\" to log recovery operations performed due to\n   interrupted gzlog operations.  A gzlog_open() followed by a gzlog_close()\n   will recover a previously interrupted operation, if any. "
2018/06/19 20:06:47 " Write to a gzlog object.  Return zero on success, -1 if there is a file i/o\n   error on any of the gzlog files (this should not happen if gzlog_open()\n   succeeded, unless the device has run out of space or leftover auxiliary\n   files have permissions or ownership that prevent their use), -2 if there is\n   a memory allocation failure, or -3 if the log argument is invalid (e.g. if\n   it was not created by gzlog_open()).  This function will write data to the\n   file uncompressed, until 1 MB has been accumulated, at which time that data\n   will be compressed.  The log file will be a valid gzip file upon successful\n   return. "
2018/06/19 20:06:47 " Force compression of any uncompressed data in the log.  This should be used\n   sparingly, if at all.  The main application would be when a log file will\n   not be appended to again.  If this is used to compress frequently while\n   appending, it will both significantly increase the execution time and\n   reduce the compression ratio.  The return codes are the same as for\n   gzlog_write(). "
2018/06/19 20:06:47 " Close a gzlog object.  Return zero on success, -3 if the log argument is\n   invalid.  The log object is freed, and so cannot be referenced again. "
2018/06/19 20:06:47 Finished Classifying License "/zlib-1.2.11.tar.gz/examples/gzlog.h": 18.120965ms
2018/06/19 20:06:48 Classifying license(s): /zlib-1.2.11.tar.gz/examples/enough.c
2018/06/19 20:06:48 detected language: 4
2018/06/19 20:06:48 " enough.c -- determine the maximum size of inflate's Huffman code tables over\n * all possible valid and complete Huffman codes, subject to a length limit.\n * Copyright (C) 2007, 2008, 2012 Mark Adler\n * Version 1.4  18 August 2012  Mark Adler\n "
2018/06/19 20:06:48 " Version history:\n   1.0   3 Jan 2007  First version (derived from codecount.c version 1.4)\n   1.1   4 Jan 2007  Use faster incremental table usage computation\n                     Prune examine() search on previously visited states\n   1.2   5 Jan 2007  Comments clean up\n                     As inflate does, decrease root for short codes\n                     Refuse cases where inflate would increase root\n   1.3  17 Feb 2008  Add argument for initial root table size\n                     Fix bug for initial root table size == max - 1\n                     Use a macro to compute the history index\n   1.4  18 Aug 2012  Avoid shifts more than bits in type (caused endless loop!)\n                     Clean up comparisons of different types\n                     Clean up code indentation\n "
2018/06/19 20:06:48 "\n   Examine all possible Huffman codes for a given number of symbols and a\n   maximum code length in bits to determine the maximum table size for zilb's\n   inflate.  Only complete Huffman codes are counted.\n\n   Two codes are considered distinct if the vectors of the number of codes per\n   length are not identical.  So permutations of the symbol assignments result\n   in the same code for the counting, as do permutations of the assignments of\n   the bit values to the codes (i.e. only canonical codes are counted).\n\n   We build a code from shorter to longer lengths, determining how many symbols\n   are coded at each length.  At each step, we have how many symbols remain to\n   be coded, what the last code length used was, and how many bit patterns of\n   that length remain unused. Then we add one to the code length and double the\n   number of unused patterns to graduate to the next code length.  We then\n   assign all portions of the remaining symbols to that code length that\n   preserve the properties of a correct and eventually complete code.  Those\n   properties are: we cannot use more bit patterns than are available; and when\n   all the symbols are used, there are exactly zero possible bit patterns\n   remaining.\n\n   The inflate Huffman decoding algorithm uses two-level lookup tables for\n   speed.  There is a single first-level table to decode codes up to root bits\n   in length (root == 9 in the current inflate implementation).  The table\n   has 1 << root entries and is indexed by the next root bits of input.  Codes\n   shorter than root bits have replicated table entries, so that the correct\n   entry is pointed to regardless of the bits that follow the short code.  If\n   the code is longer than root bits, then the table entry points to a second-\n   level table.  The size of that table is determined by the longest code with\n   that root-bit prefix.  If that longest code has length len, then the table\n   has size 1 << (len - root), to index the remaining bits in that set of\n   codes.  Each subsequent root-bit prefix then has its own sub-table.  The\n   total number of table entries required by the code is calculated\n   incrementally as the number of codes at each bit length is populated.  When\n   all of the codes are shorter than root bits, then root is reduced to the\n   longest code length, resulting in a single, smaller, one-level table.\n\n   The inflate algorithm also provides for small values of root (relative to\n   the log2 of the number of symbols), where the shortest code has more bits\n   than root.  In that case, root is increased to the length of the shortest\n   code.  This program, by design, does not handle that case, so it is verified\n   that the number of symbols is less than 2^(root + 1).\n\n   In order to speed up the examination (by about ten orders of magnitude for\n   the default arguments), the intermediate states in the build-up of a code\n   are remembered and previously visited branches are pruned.  The memory\n   required for this will increase rapidly with the total number of symbols and\n   the maximum code length in bits.  However this is a very small price to pay\n   for the vast speedup.\n\n   First, all of the possible Huffman codes are counted, and reachable\n   intermediate states are noted by a non-zero count in a saved-results array.\n   Second, the intermediate states that lead to (root + 1) bit or longer codes\n   are used to look at all sub-codes from those junctures for their inflate\n   memory usage.  (The amount of memory used is not affected by the number of\n   codes of root bits or less in length.)  Third, the visited states in the\n   construction of those sub-codes and the associated calculation of the table\n   size is recalled in order to avoid recalculating from the same juncture.\n   Beginning the code examination at (root + 1) bit codes, which is enabled by\n   identifying the reachable nodes, accounts for about six of the orders of\n   magnitude of improvement for the default arguments.  About another four\n   orders of magnitude come from not revisiting previous states.  Out of\n   approximately 2x10^16 possible Huffman codes, only about 2x10^6 sub-codes\n   need to be examined to cover all of the possible table memory usage cases\n   for the default arguments of 286 symbols limited to 15-bit codes.\n\n   Note that an unsigned long long type is used for counting.  It is quite easy\n   to exceed the capacity of an eight-byte integer with a large number of\n   symbols and a large maximum code length, so multiple-precision arithmetic\n   would need to replace the unsigned long long arithmetic in that case.  This\n   program will abort if an overflow occurs.  The big_t type identifies where\n   the counting takes place.\n\n   An unsigned long long type is also used for calculating the number of\n   possible codes remaining at the maximum length.  This limits the maximum\n   code length to the number of bits in a long long minus the number of bits\n   needed to represent the symbols in a flat code.  The code_t type identifies\n   where the bit pattern counting takes place.\n "
2018/06/19 20:06:48 " special data types \n type for code counting \n type for bit pattern counting \n type for been here check \n length of bit vector in char's \n allocated bit vector "
2018/06/19 20:06:48 " The array for saving results, num[], is indexed with this triplet:\n\n      syms: number of symbols remaining to code\n      left: number of available bit patterns at length len\n      len: number of bits in the codes currently being assigned\n\n   Those indices are constrained thusly when saving results:\n\n      syms: 3..totsym (totsym == total symbols to code)\n      left: 2..syms - 1, but only the evens (so syms == 8 -> 2, 4, 6)\n      len: 1..max - 1 (max == maximum code length in bits)\n\n   syms == 2 is not saved since that immediately leads to a single code.  left\n   must be even, since it represents the number of available bit patterns at\n   the current length, which is double the number at the previous length.\n   left ends at syms-1 since left == syms immediately results in a single code.\n   (left > sym is not allowed since that would result in an incomplete code.)\n   len is less than max, since the code completes immediately when len == max.\n\n   The offset into the array is calculated for the three indices with the\n   first one (syms) being outermost, and the last one (len) being innermost.\n   We build the array with length max-1 lists for the len index, with syms-3\n   of those for each symbol.  There are totsym-2 of those, with each one\n   varying in length as a function of sym.  See the calculation of index in\n   count() for the index, and the calculation of size in main() for the size\n   of the array.\n\n   For the deflate example of 286 symbols limited to 15-bit codes, the array\n   has 284,284 entries, taking up 2.17 MB for an 8-byte big_t.  More than\n   half of the space allocated for saved results is actually used -- not all\n   possible triplets are reached in the generation of valid Huffman codes.\n "
2018/06/19 20:06:48 " The array for tracking visited states, done[], is itself indexed identically\n   to the num[] array as described above for the (syms, left, len) triplet.\n   Each element in the array is further indexed by the (mem, rem) doublet,\n   where mem is the amount of inflate table space used so far, and rem is the\n   remaining unused entries in the current inflate sub-table.  Each indexed\n   element is simply one bit indicating whether the state has been visited or\n   not.  Since the ranges for mem and rem are not known a priori, each bit\n   vector is of a variable size, and grows as needed to accommodate the visited\n   states.  mem and rem are used to calculate a single index in a triangular\n   array.  Since the range of mem is expected in the default case to be about\n   ten times larger than the range of rem, the array is skewed to reduce the\n   memory usage, with eight times the range for mem than for rem.  See the\n   calculations for offset and bit in beenhere() for the details.\n\n   For the deflate example of 286 symbols limited to 15-bit codes, the bit\n   vectors grow to total approximately 21 MB, in addition to the 4.3 MB done[]\n   array itself.\n "
2018/06/19 20:06:48 " Globals to avoid propagating constants or constant pointers recursively \n maximum allowed bit length for the codes \n size of base code table in bits \n largest code table so far \n number of elements in num and done \n number of symbols assigned to each bit length \n saved results array for code counting \n states already evaluated array "
2018/06/19 20:06:48 " Index function for num[] and done[] "
2018/06/19 20:06:48 " Free allocated space.  Uses globals code, num, and done. "
2018/06/19 20:06:48 " Return the number of possible Huffman codes using bit patterns of lengths\n   len through max inclusive, coding syms symbols, with left bit patterns of\n   length len unused -- return -1 if there is an overflow in the counting.\n   Keep a record of previous results in num to prevent repeating the same\n   calculation.  Uses the globals max and num. "
2018/06/19 20:06:48 " number of possible codes from this juncture \n value returned from count() \n least number of syms to use at this juncture \n most number of syms to use at this juncture \n number of bit patterns to use in next call \n index of this case in *num "
2018/06/19 20:06:48 " see if only one possible code "
2018/06/19 20:06:48 " note and verify the expected state "
2018/06/19 20:06:48 " see if we've done this one already "
2018/06/19 20:06:48 " we have -- return the saved result "
2018/06/19 20:06:48 " we need to use at least this many bit patterns so that the code won't be\n       incomplete at the next length (more bit patterns than symbols) "
2018/06/19 20:06:48 " we can use at most this many bit patterns, lest there not be enough\n       available for the remaining symbols at the maximum length (if there were\n       no limit to the code length, this would become: most = left - 1) "
2018/06/19 20:06:48 " count all possible codes from this juncture and add them up "
2018/06/19 20:06:48 " overflow "
2018/06/19 20:06:48 " verify that all recursive calls are productive "
2018/06/19 20:06:48 " save the result and return it "
2018/06/19 20:06:48 " Return true if we've been here before, set to true if not.  Set a bit in a\n   bit vector to indicate visiting this state.  Each (syms,len,left) state\n   has a variable size bit vector indexed by (mem,rem).  The bit vector is\n   lengthened if needed to allow setting the (mem,rem) bit. "
2018/06/19 20:06:48 " index for this state's bit vector \n offset in this state's bit vector \n mask for this state's bit \n length of the bit vector in bytes \n new or enlarged bit vector "
2018/06/19 20:06:48 " point to vector for (syms,left,len), bit in vector for (mem,rem) "
2018/06/19 20:06:48 " see if we've been here "
2018/06/19 20:06:48 " done this! "
2018/06/19 20:06:48 " we haven't been here before -- set the bit to show we have now "
2018/06/19 20:06:48 " see if we need to lengthen the vector in order to set the bit "
2018/06/19 20:06:48 " if we have one already, enlarge it, zero out the appended space "
2018/06/19 20:06:48 " otherwise we need to make a new vector and zero it out "
2018/06/19 20:06:48 " in either case, bail if we can't get the memory "
2018/06/19 20:06:48 " install the new vector "
2018/06/19 20:06:48 " set the bit "
2018/06/19 20:06:48 " Examine all possible codes from the given node (syms, len, left).  Compute\n   the amount of memory required to build inflate's decoding tables, where the\n   number of code structures used so far is mem, and the number remaining in\n   the current sub-table is rem.  Uses the globals max, code, root, large, and\n   done. "
2018/06/19 20:06:48 " least number of syms to use at this juncture \n most number of syms to use at this juncture \n number of bit patterns to use in next call "
2018/06/19 20:06:48 " see if we have a complete code "
2018/06/19 20:06:48 " set the last code entry "
2018/06/19 20:06:48 " complete computation of memory used by this code "
2018/06/19 20:06:48 " if this is a new maximum, show the entries used and the sub-code "
2018/06/19 20:06:48 " remove entries as we drop back down in the recursion "
2018/06/19 20:06:48 " prune the tree if we can "
2018/06/19 20:06:48 " we need to use at least this many bit patterns so that the code won't be\n       incomplete at the next length (more bit patterns than symbols) "
2018/06/19 20:06:48 " we can use at most this many bit patterns, lest there not be enough\n       available for the remaining symbols at the maximum length (if there were\n       no limit to the code length, this would become: most = left - 1) "
2018/06/19 20:06:48 " occupy least table spaces, creating new sub-tables as needed "
2018/06/19 20:06:48 " examine codes from here, updating table space as we go "
2018/06/19 20:06:48 " remove entries as we drop back down in the recursion "
2018/06/19 20:06:48 " Look at all sub-codes starting with root + 1 bits.  Look at only the valid\n   intermediate code states (syms, left, len).  For each completed code,\n   calculate the amount of memory required by inflate to build the decoding\n   tables. Find the maximum amount of memory required and show the code that\n   requires that maximum.  Uses the globals max, root, and num. "
2018/06/19 20:06:48 " number of remaing symbols for this node \n number of unused bit patterns at this length \n index of this case in *num "
2018/06/19 20:06:48 " clear code "
2018/06/19 20:06:48 " look at all (root + 1) bit and longer codes \n base table \n otherwise, there's only a base table "
2018/06/19 20:06:48 " look at all reachable (root + 1) bit nodes, and the\n                   resulting codes (complete at root + 2 or more) "
2018/06/19 20:06:48 " reachable node "
2018/06/19 20:06:48 " also look at root bit codes with completions at root + 1\n                   bits (not saved in num, since complete), just in case "
2018/06/19 20:06:48 " done "
2018/06/19 20:06:48 "\n   Examine and show the total number of possible Huffman codes for a given\n   maximum number of symbols, initial root table size, and maximum code length\n   in bits -- those are the command arguments in that order.  The default\n   values are 286, 9, and 15 respectively, for the deflate literal/length code.\n   The possible codes are counted for each number of coded symbols from two to\n   the maximum.  The counts for each of those and the total number of codes are\n   shown.  The maximum number of inflate table entires is then calculated\n   across all possible codes.  Each new maximum number of table entries and the\n   associated sub-code (starting at root + 1 == 10 bits) is shown.\n\n   To count and examine Huffman codes that are not length-limited, provide a\n   maximum length equal to the number of symbols minus one.\n\n   For the deflate literal/length code, use \"enough\".  For the deflate distance\n   code, use \"enough 30 6\".\n\n   This uses the %llu printf format to print big_t numbers, which assumes that\n   big_t is an unsigned long long.  If the big_t type is changed (for example\n   to a multiple precision type), the method of printing will also need to be\n   updated.\n "
2018/06/19 20:06:48 " total number of symbols to code \n number of symbols to code for this run \n return value of count() \n accumulated number of codes over n \n for counting bits in code_t "
2018/06/19 20:06:48 " set up globals for cleanup() "
2018/06/19 20:06:48 " get arguments -- default to the deflate literal/length code "
2018/06/19 20:06:48 " if not restricting the code length, the longest is syms - 1 "
2018/06/19 20:06:48 " determine the number of bits in a code_t "
2018/06/19 20:06:48 " make sure that the calculation of most will not overflow "
2018/06/19 20:06:48 " reject impossible code requests "
2018/06/19 20:06:48 " allocate code vector "
2018/06/19 20:06:48 " determine size of saved results array, checking for overflows,\n       allocate and clear the array (set all to zero with calloc()) "
2018/06/19 20:06:48 " iff max == 1 \n won't be saving any results "
2018/06/19 20:06:48 " count possible codes for all numbers of symbols, add up counts "
2018/06/19 20:06:48 " overflow "
2018/06/19 20:06:48 " allocate and clear done array for beenhere() "
2018/06/19 20:06:48 " find and show maximum inflate table usage \n reduce root to max length "
2018/06/19 20:06:48 " done "
2018/06/19 20:06:48 Finished Classifying License "/zlib-1.2.11.tar.gz/examples/enough.c": 106.608979ms
2018/06/19 20:06:48 Couldn't classify license(s)
2018/06/19 20:06:49 Classifying license(s): /zlib-1.2.11.tar.gz/examples/gzappend.c
2018/06/19 20:06:49 detected language: 4
2018/06/19 20:06:49 " gzappend -- command to append to a gzip file\n\n  Copyright (C) 2003, 2012 Mark Adler, all rights reserved\n  version 1.2, 11 Oct 2012\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the author be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n\n  Mark Adler    madler@alumni.caltech.edu\n "
2018/06/19 20:06:49 "\n * Change history:\n *\n * 1.0  19 Oct 2003     - First version\n * 1.1   4 Nov 2003     - Expand and clarify some comments and notes\n *                      - Add version and copyright to help\n *                      - Send help to stdout instead of stderr\n *                      - Add some preemptive typecasts\n *                      - Add L to constants in lseek() calls\n *                      - Remove some debugging information in error messages\n *                      - Use new data_type definition for zlib 1.2.1\n *                      - Simplfy and unify file operations\n *                      - Finish off gzip file in gztack()\n *                      - Use deflatePrime() instead of adding empty blocks\n *                      - Keep gzip file clean on appended file read errors\n *                      - Use in-place rotate instead of auxiliary buffer\n *                        (Why you ask?  Because it was fun to write!)\n * 1.2  11 Oct 2012     - Fix for proper z_const usage\n *                      - Check for input buffer malloc failure\n "
2018/06/19 20:06:49 "\n   gzappend takes a gzip file and appends to it, compressing files from the\n   command line or data from stdin.  The gzip file is written to directly, to\n   avoid copying that file, in case it's large.  Note that this results in the\n   unfriendly behavior that if gzappend fails, the gzip file is corrupted.\n\n   This program was written to illustrate the use of the new Z_BLOCK option of\n   zlib 1.2.x's inflate() function.  This option returns from inflate() at each\n   block boundary to facilitate locating and modifying the last block bit at\n   the start of the final deflate block.  Also whether using Z_BLOCK or not,\n   another required feature of zlib 1.2.x is that inflate() now provides the\n   number of unusued bits in the last input byte used.  gzappend will not work\n   with versions of zlib earlier than 1.2.1.\n\n   gzappend first decompresses the gzip file internally, discarding all but\n   the last 32K of uncompressed data, and noting the location of the last block\n   bit and the number of unused bits in the last byte of the compressed data.\n   The gzip trailer containing the CRC-32 and length of the uncompressed data\n   is verified.  This trailer will be later overwritten.\n\n   Then the last block bit is cleared by seeking back in the file and rewriting\n   the byte that contains it.  Seeking forward, the last byte of the compressed\n   data is saved along with the number of unused bits to initialize deflate.\n\n   A deflate process is initialized, using the last 32K of the uncompressed\n   data from the gzip file to initialize the dictionary.  If the total\n   uncompressed data was less than 32K, then all of it is used to initialize\n   the dictionary.  The deflate output bit buffer is also initialized with the\n   last bits from the original deflate stream.  From here on, the data to\n   append is simply compressed using deflate, and written to the gzip file.\n   When that is complete, the new CRC-32 and uncompressed length are written\n   as the trailer of the gzip file.\n "
2018/06/19 20:06:49 " print an error message and terminate with extreme prejudice "
2018/06/19 20:06:49 " return the greatest common divisor of a and b using Euclid's algorithm,\n   modified to be fast when one argument much greater than the other, and\n   coded to avoid unnecessary swapping "
2018/06/19 20:06:49 " rotate list[0..len-1] left by rot positions, in place "
2018/06/19 20:06:49 " normalize rot and handle degenerate cases "
2018/06/19 20:06:49 " pointer to last entry in list "
2018/06/19 20:06:49 " do simple left shift by one "
2018/06/19 20:06:49 " do simple right shift by one "
2018/06/19 20:06:49 " otherwise do rotate as a set of cycles in place \n number of cycles "
2018/06/19 20:06:49 " start index is arbitrary \n save entry to be overwritten "
2018/06/19 20:06:49 " next step in cycle \n go right rot positions \n (pointer better not wrap) \n all but one shifted \n shift left "
2018/06/19 20:06:49 " complete the circle "
2018/06/19 20:06:49 " structure for gzip file read operations "
2018/06/19 20:06:49 " file descriptor \n 1 << size is bytes in buf \n bytes available at next \n buffer \n next byte in buffer \n file name for error messages "
2018/06/19 20:06:49 " reload buffer "
2018/06/19 20:06:49 " read from file in, exit if end-of-file "
2018/06/19 20:06:49 " skip over n bytes of in "
2018/06/19 20:06:49 " read a four-byte unsigned integer, little-endian, from in "
2018/06/19 20:06:49 " skip over gzip header "
2018/06/19 20:06:49 " decompress gzip file \"name\", return strm with a deflate stream ready to\n   continue compression of the data in the gzip file, and return a file\n   descriptor pointing to where to write the compressed data -- the deflate\n   stream is initialized to compress using level \"level\" "
2018/06/19 20:06:49 " open gzip file "
2018/06/19 20:06:49 " skip gzip header "
2018/06/19 20:06:49 " prepare to decompress "
2018/06/19 20:06:49 " decompress the deflate stream, saving append information "
2018/06/19 20:06:49 " if needed, get more input "
2018/06/19 20:06:49 " set up output to next available section of sliding window "
2018/06/19 20:06:49 " inflate and check for errors "
2018/06/19 20:06:49 " update crc and sliding window pointer "
2018/06/19 20:06:49 " process end of block "
2018/06/19 20:06:49 " save the location of the end of the compressed data "
2018/06/19 20:06:49 " check gzip trailer and save total for deflate "
2018/06/19 20:06:49 " if not at end of file, warn "
2018/06/19 20:06:49 " clear last block bit "
2018/06/19 20:06:49 " if window wrapped, build dictionary from window by rotating "
2018/06/19 20:06:49 " set up deflate stream with window, crc, total_in, and leftover bits "
2018/06/19 20:06:49 " clean up and return "
2018/06/19 20:06:49 " append file \"name\" to gzip file gd using deflate stream strm -- if last\n   is true, then finish off the deflate stream at the end "
2018/06/19 20:06:49 " open file to compress and append "
2018/06/19 20:06:49 " allocate buffers "
2018/06/19 20:06:49 " compress input file and append to gzip file "
2018/06/19 20:06:49 " get more input "
2018/06/19 20:06:49 " compress and write all available output "
2018/06/19 20:06:49 " write trailer after last entry "
2018/06/19 20:06:49 " clean up and return "
2018/06/19 20:06:49 " process the compression level option if present, scan the gzip file, and\n   append the specified files, or append the data from stdin if no other file\n   names are provided on the command line -- the gzip file must be writable\n   and seekable "
2018/06/19 20:06:49 " ignore command name "
2018/06/19 20:06:49 " provide usage if no arguments "
2018/06/19 20:06:49 " set compression level "
2018/06/19 20:06:49 " prepare to append to gzip file "
2018/06/19 20:06:49 " append files on command line, or from stdin if none "
2018/06/19 20:06:49 Finished Classifying License "/zlib-1.2.11.tar.gz/examples/gzappend.c": 29.110535ms
2018/06/19 20:06:50 Classifying license(s): /zlib-1.2.11.tar.gz/examples/gzjoin.c
2018/06/19 20:06:50 detected language: 4
2018/06/19 20:06:50 " gzjoin -- command to join gzip files into one gzip file\n\n  Copyright (C) 2004, 2005, 2012 Mark Adler, all rights reserved\n  version 1.2, 14 Aug 2012\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the author be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n\n  Mark Adler    madler@alumni.caltech.edu\n "
2018/06/19 20:06:50 "\n * Change history:\n *\n * 1.0  11 Dec 2004     - First version\n * 1.1  12 Jun 2005     - Changed ssize_t to long for portability\n * 1.2  14 Aug 2012     - Clean up for z_const usage\n "
2018/06/19 20:06:50 "\n   gzjoin takes one or more gzip files on the command line and writes out a\n   single gzip file that will uncompress to the concatenation of the\n   uncompressed data from the individual gzip files.  gzjoin does this without\n   having to recompress any of the data and without having to calculate a new\n   crc32 for the concatenated uncompressed data.  gzjoin does however have to\n   decompress all of the input data in order to find the bits in the compressed\n   data that need to be modified to concatenate the streams.\n\n   gzjoin does not do an integrity check on the input gzip files other than\n   checking the gzip header and decompressing the compressed data.  They are\n   otherwise assumed to be complete and correct.\n\n   Each joint between gzip files removes at least 18 bytes of previous trailer\n   and subsequent header, and inserts an average of about three bytes to the\n   compressed data in order to connect the streams.  The output gzip file\n   has a minimal ten-byte gzip header with no file name or modification time.\n\n   This program was written to illustrate the use of the Z_BLOCK option of\n   inflate() and the crc32_combine() function.  gzjoin will not compile with\n   versions of zlib earlier than 1.2.3.\n "
2018/06/19 20:06:50 " fputs(), fprintf(), fwrite(), putc() \n exit(), malloc(), free() \n open() \n close(), read(), lseek() "
2018/06/19 20:06:50 " crc32(), crc32_combine(), inflateInit2(), inflate(), inflateEnd() "
2018/06/19 20:06:50 " exit with an error (return a value to allow use in an expression) "
2018/06/19 20:06:50 " -- simple buffered file input with access to the buffer -- "
2018/06/19 20:06:50 " must be a power of two and fit in unsigned "
2018/06/19 20:06:50 " bin buffered input file type "
2018/06/19 20:06:50 " name of file for error messages \n file descriptor \n bytes remaining at next \n next byte to read \n allocated buffer of length CHUNK "
2018/06/19 20:06:50 " close a buffered file and free allocated memory "
2018/06/19 20:06:50 " open a buffered file for input, return a pointer to type bin, or NULL on\n   failure "
2018/06/19 20:06:50 " load buffer from file, return -1 on read error, 0 or 1 on success, with\n   1 indicating that end-of-file was reached "
2018/06/19 20:06:50 " get a byte from the file, bail if end of file "
2018/06/19 20:06:50 " get a four-byte little-endian unsigned integer from file "
2018/06/19 20:06:50 " skip bytes in file "
2018/06/19 20:06:50 " check pointer "
2018/06/19 20:06:50 " easy case -- skip bytes in buffer "
2018/06/19 20:06:50 " skip what's in buffer, discard buffer contents "
2018/06/19 20:06:50 " seek past multiples of CHUNK bytes "
2018/06/19 20:06:50 " exact number of chunks: seek all the way minus one byte to check\n               for end-of-file with a read "
2018/06/19 20:06:50 " skip the integral chunks, update skip with remainder "
2018/06/19 20:06:50 " read more input and skip remainder "
2018/06/19 20:06:50 " -- end of buffered input functions -- "
2018/06/19 20:06:50 " skip the gzip header from file in "
2018/06/19 20:06:50 " verify gzip magic header and compression method "
2018/06/19 20:06:50 " get and verify flags "
2018/06/19 20:06:50 " skip modification time, extra flags, and os "
2018/06/19 20:06:50 " skip extra field if present "
2018/06/19 20:06:50 " skip file name if present "
2018/06/19 20:06:50 " skip comment if present "
2018/06/19 20:06:50 " skip header crc if present "
2018/06/19 20:06:50 " write a four-byte little-endian unsigned integer to out "
2018/06/19 20:06:50 " Load up zlib stream from buffered input, bail if end of file "
2018/06/19 20:06:50 " Write header for gzip file to out and initialize trailer. "
2018/06/19 20:06:50 " Copy the compressed data from name, zeroing the last block bit of the last\n   block if clr is true, and adding empty blocks as needed to get to a byte\n   boundary.  If clr is false, then the last block becomes the last block of\n   the output, and the gzip trailer is written.  crc and tot maintains the\n   crc and length (modulo 2^32) of the output for the trailer.  The resulting\n   gzip file is written to out.  gzinit() must be called before the first call\n   of gzcopy() to write the gzip header and to initialize crc and tot. "
2018/06/19 20:06:50 " return value from zlib functions \n where the \"last block\" bit is in byte \n true if processing the last block \n buffered input file \n start of compressed data in buffer \n buffer for uncompressed data -- discarded \n length of uncompressed data (support > 4 GB) \n zlib inflate stream "
2018/06/19 20:06:50 " open gzip file and skip header "
2018/06/19 20:06:50 " allocate buffer for uncompressed data and initialize raw inflate\n       stream "
2018/06/19 20:06:50 " inflate and copy compressed data, clear last-block bit if requested "
2018/06/19 20:06:50 " if input used and output done, write used input and get more "
2018/06/19 20:06:50 " decompress -- return early when end-of-block reached "
2018/06/19 20:06:50 " update length of uncompressed data "
2018/06/19 20:06:50 " check for block boundary (only get this when block copied out) "
2018/06/19 20:06:50 " if that was the last block, then done "
2018/06/19 20:06:50 " number of unused bits in last byte "
2018/06/19 20:06:50 " find the next last-block bit "
2018/06/19 20:06:50 " next last-block bit is in last used byte "
2018/06/19 20:06:50 " next last-block bit is in next unused byte "
2018/06/19 20:06:50 " don't have that byte yet -- get it "
2018/06/19 20:06:50 " update buffer with unused input "
2018/06/19 20:06:50 " copy used input, write empty blocks to get to byte boundary "
2018/06/19 20:06:50 " already at byte boundary, or last file: write last byte "
2018/06/19 20:06:50 " append empty blocks to last byte \n assure unused bits are zero "
2018/06/19 20:06:50 " odd -- append an empty stored block "
2018/06/19 20:06:50 " two more bits in block header "
2018/06/19 20:06:50 " even -- append 1, 2, or 3 empty fixed blocks "
2018/06/19 20:06:50 " update crc and tot "
2018/06/19 20:06:50 " clean up "
2018/06/19 20:06:50 " write trailer if this is the last gzip file "
2018/06/19 20:06:50 " join the gzip files on the command line, write result to stdout "
2018/06/19 20:06:50 " running crc and total uncompressed length "
2018/06/19 20:06:50 " skip command name "
2018/06/19 20:06:50 " show usage if no arguments "
2018/06/19 20:06:50 " join gzip files on command line and write to stdout "
2018/06/19 20:06:50 " done "
2018/06/19 20:06:50 Finished Classifying License "/zlib-1.2.11.tar.gz/examples/gzjoin.c": 22.533705ms
2018/06/19 20:06:50 Classifying license(s): /zlib-1.2.11.tar.gz/examples/README.examples
2018/06/19 20:06:50 Finished Classifying License "/zlib-1.2.11.tar.gz/examples/README.examples": 3.630231ms
2018/06/19 20:06:50 Couldn't classify license(s)
2018/06/19 20:06:51 Classifying license(s): /zlib-1.2.11.tar.gz/examples/zlib_how.html
2018/06/19 20:06:51 detected language: 15
2018/06/19 20:06:51 "  Copyright (c) 2004, 2005 Mark Adler.  "
2018/06/19 20:06:51 " "
2018/06/19 20:06:51 " "
2018/06/19 20:06:51 " "
2018/06/19 20:06:51 " "
2018/06/19 20:06:51 " "
2018/06/19 20:06:51 " "
2018/06/19 20:06:51 " "
2018/06/19 20:06:51 " "
2018/06/19 20:06:51 " "
2018/06/19 20:06:51 " "
2018/06/19 20:06:51 " "
2018/06/19 20:06:51 " "
2018/06/19 20:06:51 " "
2018/06/19 20:06:51 " "
2018/06/19 20:06:51 " "
2018/06/19 20:06:51 " "
2018/06/19 20:06:51 " "
2018/06/19 20:06:51 Finished Classifying License "/zlib-1.2.11.tar.gz/examples/zlib_how.html": 3.076103ms
2018/06/19 20:06:51 Couldn't classify license(s)
2018/06/19 20:06:52 Classifying license(s): /zlib-1.2.11.tar.gz/examples/zran.c
2018/06/19 20:06:52 detected language: 4
2018/06/19 20:06:52 " zran.c -- example of zlib/gzip stream indexing and random access\n * Copyright (C) 2005, 2012 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n   Version 1.1  29 Sep 2012  Mark Adler "
2018/06/19 20:06:52 " Version History:\n 1.0  29 May 2005  First version\n 1.1  29 Sep 2012  Fix memory reallocation error\n "
2018/06/19 20:06:52 " Illustrate the use of Z_BLOCK, inflatePrime(), and inflateSetDictionary()\n   for random access of a compressed file.  A file containing a zlib or gzip\n   stream is provided on the command line.  The compressed stream is decoded in\n   its entirety, and an index built with access points about every SPAN bytes\n   in the uncompressed output.  The compressed file is left open, and can then\n   be read randomly, having to decompress on the average SPAN/2 uncompressed\n   bytes before getting to the desired block of data.\n\n   An access point can be created at the start of any deflate block, by saving\n   the starting file offset and bit of that block, and the 32K bytes of\n   uncompressed data that precede that block.  Also the uncompressed offset of\n   that block is saved to provide a referece for locating a desired starting\n   point in the uncompressed stream.  build_index() works by decompressing the\n   input zlib or gzip stream a block at a time, and at the end of each block\n   deciding if enough uncompressed data has gone by to justify the creation of\n   a new access point.  If so, that point is saved in a data structure that\n   grows as needed to accommodate the points.\n\n   To use the index, an offset in the uncompressed data is provided, for which\n   the latest access point at or preceding that offset is located in the index.\n   The input file is positioned to the specified location in the index, and if\n   necessary the first few bits of the compressed data is read from the file.\n   inflate is initialized with those bits and the 32K of uncompressed data, and\n   the decompression then proceeds until the desired offset in the file is\n   reached.  Then the decompression continues to read the desired uncompressed\n   data from the file.\n\n   Another approach would be to generate the index on demand.  In that case,\n   requests for random access reads from the compressed data would try to use\n   the index, but if a read far enough past the end of the index is required,\n   then further index entries would be generated and added.\n\n   There is some fair bit of overhead to starting inflation for the random\n   access, mainly copying the 32K byte dictionary.  So if small pieces of the\n   file are being accessed, it would make sense to implement a cache to hold\n   some lookahead and avoid many calls to extract() for small lengths.\n\n   Another way to build an index would be to use inflateCopy().  That would\n   not be constrained to have access points at block boundaries, but requires\n   more memory per access point, and also cannot be saved to file due to the\n   use of pointers in the state.  The approach here allows for storage of the\n   index in a file.\n "
2018/06/19 20:06:52 " desired distance between access points \n sliding window size \n file input buffer size "
2018/06/19 20:06:52 " access point entry "
2018/06/19 20:06:52 " corresponding offset in uncompressed data \n offset in input file of first full byte \n number of bits (1-7) from byte at in - 1, or 0 \n preceding 32K of uncompressed data "
2018/06/19 20:06:52 " access point list "
2018/06/19 20:06:52 " number of list entries filled in \n number of list entries allocated \n allocated list "
2018/06/19 20:06:52 " Deallocate an index built by build_index() "
2018/06/19 20:06:52 " Add an entry to the access point list.  If out of memory, deallocate the\n   existing list and return NULL. "
2018/06/19 20:06:52 " if list is empty, create it (start with eight points) "
2018/06/19 20:06:52 " if list is full, make it bigger "
2018/06/19 20:06:52 " fill in entry and increment how many we have "
2018/06/19 20:06:52 " return list, possibly reallocated "
2018/06/19 20:06:52 " Make one entire pass through the compressed stream and build an index, with\n   access points about every span bytes of uncompressed output -- span is\n   chosen to balance the speed of random access against the memory requirements\n   of the list, about 32K bytes per access point.  Note that data after the end\n   of the first zlib or gzip stream in the file is ignored.  build_index()\n   returns the number of access points on success (>= 1), Z_MEM_ERROR for out\n   of memory, Z_DATA_ERROR for an error in the input file, or Z_ERRNO for a\n   file read error.  On success, *built points to the resulting index. "
2018/06/19 20:06:52 " our own total counters to avoid 4GB limit \n totout value of last access point \n access points being generated "
2018/06/19 20:06:52 " initialize inflate "
2018/06/19 20:06:52 " automatic zlib or gzip decoding "
2018/06/19 20:06:52 " inflate the input, maintain a sliding window, and build an index -- this\n       also validates the integrity of the compressed data using the check\n       information at the end of the gzip or zlib stream "
2018/06/19 20:06:52 " will be allocated by first addpoint() "
2018/06/19 20:06:52 " get some compressed data from input file "
2018/06/19 20:06:52 " process all of that, or until end of stream "
2018/06/19 20:06:52 " reset sliding window if necessary "
2018/06/19 20:06:52 " inflate until out of input, output, or at end of block --\n               update the total input and output counters "
2018/06/19 20:06:52 " return at end of block "
2018/06/19 20:06:52 " if at end of block, consider adding an index entry (note that if\n               data_type indicates an end-of-block, then all of the\n               uncompressed data from that block has been delivered, and none\n               of the compressed data after that block has been consumed,\n               except for up to seven bits) -- the totout == 0 provides an\n               entry point after the zlib or gzip header, and assures that the\n               index always has at least one access point; we avoid creating an\n               access point after the last block by checking bit 6 of data_type\n             "
2018/06/19 20:06:52 " clean up and return index (release unused entries in list) "
2018/06/19 20:06:52 " return error "
2018/06/19 20:06:52 " Use the index to read len bytes from offset into buf, return bytes read or\n   negative for error (Z_DATA_ERROR or Z_MEM_ERROR).  If data is requested past\n   the end of the uncompressed data, then extract() will return a value less\n   than len, indicating how much as actually read into buf.  This function\n   should not return a data error unless the file was modified since the index\n   was generated.  extract() may also return Z_ERRNO if there is an error on\n   reading or seeking the input file. "
2018/06/19 20:06:52 " proceed only if something reasonable to do "
2018/06/19 20:06:52 " find where in stream to start "
2018/06/19 20:06:52 " initialize file and inflate state to start there "
2018/06/19 20:06:52 " raw inflate "
2018/06/19 20:06:52 " skip uncompressed bytes until offset reached, then satisfy request "
2018/06/19 20:06:52 " while skipping to offset "
2018/06/19 20:06:52 " define where to put uncompressed data, and how much \n at offset now "
2018/06/19 20:06:52 " only do this once "
2018/06/19 20:06:52 " skip WINSIZE bytes "
2018/06/19 20:06:52 " last skip "
2018/06/19 20:06:52 " uncompress until avail_out filled, or end of stream "
2018/06/19 20:06:52 " normal inflate "
2018/06/19 20:06:52 " if reach end of stream, then don't keep trying to get more "
2018/06/19 20:06:52 " do until offset reached and requested data read, or stream ends "
2018/06/19 20:06:52 " compute number of uncompressed bytes read after offset "
2018/06/19 20:06:52 " clean up and return bytes read or error "
2018/06/19 20:06:52 " Demonstrate the use of build_index() and extract() by processing the file\n   provided on the command line, and the extracting 16K from about 2/3rds of\n   the way through the uncompressed output, and writing that to stdout. "
2018/06/19 20:06:52 " open input file "
2018/06/19 20:06:52 " build index "
2018/06/19 20:06:52 " use index by reading some bytes from an arbitrary offset "
2018/06/19 20:06:52 " clean up and exit "
2018/06/19 20:06:52 Finished Classifying License "/zlib-1.2.11.tar.gz/examples/zran.c": 24.085218ms
2018/06/19 20:06:52 Couldn't classify license(s)
2018/06/19 20:06:53 Classifying license(s): /zlib-1.2.11.tar.gz/examples/gun.c
2018/06/19 20:06:53 detected language: 4
2018/06/19 20:06:53 " gun.c -- simple gunzip to give an example of the use of inflateBack()\n * Copyright (C) 2003, 2005, 2008, 2010, 2012 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n   Version 1.7  12 August 2012  Mark Adler "
2018/06/19 20:06:53 " Version history:\n   1.0  16 Feb 2003  First version for testing of inflateBack()\n   1.1  21 Feb 2005  Decompress concatenated gzip streams\n                     Remove use of \"this\" variable (C++ keyword)\n                     Fix return value for in()\n                     Improve allocation failure checking\n                     Add typecasting for void * structures\n                     Add -h option for command version and usage\n                     Add a bunch of comments\n   1.2  20 Mar 2005  Add Unix compress (LZW) decompression\n                     Copy file attributes from input file to output file\n   1.3  12 Jun 2005  Add casts for error messages [Oberhumer]\n   1.4   8 Dec 2006  LZW decompression speed improvements\n   1.5   9 Feb 2008  Avoid warning in latest version of gcc\n   1.6  17 Jan 2010  Avoid signed/unsigned comparison warnings\n   1.7  12 Aug 2012  Update for z_const usage in zlib 1.2.8\n "
2018/06/19 20:06:53 "\n   gun [ -t ] [ name ... ]\n\n   decompresses the data in the named gzip files.  If no arguments are given,\n   gun will decompress from stdin to stdout.  The names must end in .gz, -gz,\n   .z, -z, _z, or .Z.  The uncompressed data will be written to a file name\n   with the suffix stripped.  On success, the original file is deleted.  On\n   failure, the output file is deleted.  For most failures, the command will\n   continue to process the remaining names on the command line.  A memory\n   allocation failure will abort the command.  If -t is specified, then the\n   listed files or stdin will be tested as gzip files for integrity (without\n   checking for a proper suffix), no output will be written, and no files\n   will be deleted.\n\n   Like gzip, gun allows concatenated gzip streams and will decompress them,\n   writing all of the uncompressed data to the output.  Unlike gzip, gun allows\n   an empty file on input, and will produce no error writing an empty output\n   file.\n\n   gun will also decompress files made by Unix compress, which uses LZW\n   compression.  These files are automatically detected by virtue of their\n   magic header bytes.  Since the end of Unix compress stream is marked by the\n   end-of-file, they cannot be concantenated.  If a Unix compress stream is\n   encountered in an input file, it is the last stream in that file.\n\n   Like gunzip and uncompress, the file attributes of the original compressed\n   file are maintained in the final uncompressed file, to the extent that the\n   user permissions allow it.\n\n   On my Mac OS X PowerPC G4, gun is almost twice as fast as gunzip (version\n   1.2.4) is on the same file, when gun is linked with zlib 1.2.2.  Also the\n   LZW decompression provided by gun is about twice as fast as the standard\n   Unix uncompress command.\n "
2018/06/19 20:06:53 " external functions and related types and constants \n fprintf() \n malloc(), free() \n strerror(), strcmp(), strlen(), memcpy() \n errno \n open() \n read(), write(), close(), chown(), unlink() "
2018/06/19 20:06:53 " stat(), chmod() \n utime() \n inflateBackInit(), inflateBack(), \n inflateBackEnd(), crc32() "
2018/06/19 20:06:53 " function declaration "
2018/06/19 20:06:53 " buffer constants \n input and output buffer sizes \n limits i/o chunks for 16-bit int case "
2018/06/19 20:06:53 " structure for infback() to pass to input function in() -- it maintains the\n   input file and a buffer of size SIZE "
2018/06/19 20:06:53 " Load input buffer, assumed to be empty, and return bytes loaded and a\n   pointer to them.  read() is called until the buffer is full, or until it\n   returns end-of-file or error.  Return 0 on error. "
2018/06/19 20:06:53 " structure for infback() to pass to output function out() -- it maintains the\n   output file, a running CRC-32 check on the output and the total number of\n   bytes output, both for checking against the gzip trailer.  (The length in\n   the gzip trailer is stored modulo 2^32, so it's ok if a long is 32 bits and\n   the output is greater than 4 GB.) "
2018/06/19 20:06:53 " true if checking crc and total "
2018/06/19 20:06:53 " Write output buffer and update the CRC-32 and total bytes written.  write()\n   is called until all of the output is written or an error is encountered.\n   On success out() returns 0.  For a write failure, out() returns 1.  If the\n   output file descriptor is -1, then nothing is written.\n "
2018/06/19 20:06:53 " next input byte macro for use inside lunpipe() and gunpipe() "
2018/06/19 20:06:53 " memory for gunpipe() and lunpipe() --\n   the first 256 entries of prefix[] and suffix[] are never used, could\n   have offset the index, but it's faster to waste the memory "
2018/06/19 20:06:53 " input buffer \n output buffer \n index to LZW prefix string \n one-character LZW suffix \n buffer for reversed match or gzip\n                                           32K sliding window "
2018/06/19 20:06:53 " throw out what's left in the current bits byte buffer (this is a vestigial\n   aspect of the compressed data format derived from an implementation that\n   made use of a special VAX machine instruction!) "
2018/06/19 20:06:53 " Decompress a compress (LZW) file from indp to outfile.  The compress magic\n   header (two bytes) has already been read and verified.  There are have bytes\n   of buffered input at next.  strm is used for passing error information back\n   to gunpipe().\n\n   lunpipe() will return Z_OK on success, Z_BUF_ERROR for an unexpected end of\n   file, read error, or write error (a write error indicated by strm->next_in\n   not equal to Z_NULL), or Z_DATA_ERROR for invalid input.\n "
2018/06/19 20:06:53 " last byte read by NEXT(), or -1 if EOF \n bytes left in current chunk \n bits left in rem \n unused bits from input \n current bits per code \n code, table traversal index \n mask for current bits codes \n maximum bits per code for this stream \n compress flags, then block compress flag \n last valid entry in prefix/suffix tables \n current code \n previous code \n last character written for previous code \n next position for reversed string \n bytes in output buffer \n output structure "
2018/06/19 20:06:53 " set up output "
2018/06/19 20:06:53 " process remainder of compress header -- a flags byte "
2018/06/19 20:06:53 " 9 doesn't really mean 9 "
2018/06/19 20:06:53 " true if block compress "
2018/06/19 20:06:53 " clear table "
2018/06/19 20:06:53 " set up: get first 9-bit code, which is the first decompressed byte, but\n       don't create a table entry until the next code "
2018/06/19 20:06:53 " no compressed data is ok "
2018/06/19 20:06:53 " low 8 bits of code \n missing a bit "
2018/06/19 20:06:53 " code must be < 256 "
2018/06/19 20:06:53 " remaining 7 bits "
2018/06/19 20:06:53 " 7 bytes left in this chunk \n write first decompressed byte "
2018/06/19 20:06:53 " decode codes "
2018/06/19 20:06:53 " if the table will be full after this, increment the code size "
2018/06/19 20:06:53 " get a code of length bits \n decrement chunk modulo bits "
2018/06/19 20:06:53 " low bits of code \n EOF is end of compressed data \n write remaining buffered output "
2018/06/19 20:06:53 " signal write error "
2018/06/19 20:06:53 " middle (or high) bits of code "
2018/06/19 20:06:53 " need more bits \n can't end in middle of code "
2018/06/19 20:06:53 " high bits of code "
2018/06/19 20:06:53 " mask to current code length \n number of unused bits \n unused bits from last byte "
2018/06/19 20:06:53 " process clear code (256) "
2018/06/19 20:06:53 " initialize bits and mask "
2018/06/19 20:06:53 " empty table \n get next code "
2018/06/19 20:06:53 " special code to reuse last match \n save the current code "
2018/06/19 20:06:53 " Be picky on the allowed code here, and make sure that the code\n               we drop through (prev) will be a valid index so that random\n               input does not cause an exception.  The code != end + 1 check is\n               empirically derived, and not checked in the original uncompress\n               code.  If this ever causes a problem, that check could be safely\n               removed.  Leaving this check in greatly improves gun's ability\n               to detect random or corrupted input after a compress header.\n               In any case, the prev > end check must be retained. "
2018/06/19 20:06:53 " walk through linked list to generate output in reverse order "
2018/06/19 20:06:53 " link new table entry "
2018/06/19 20:06:53 " set previous code for next iteration "
2018/06/19 20:06:53 " write output in forward order "
2018/06/19 20:06:53 " signal write error "
2018/06/19 20:06:53 " loop for next code with final and prev as the last match, rem and\n           left provide the first 0..7 bits of the next code, end is the last\n           valid table entry "
2018/06/19 20:06:53 " Decompress a gzip file from infile to outfile.  strm is assumed to have been\n   successfully initialized with inflateBackInit().  The input file may consist\n   of a series of gzip streams, in which case all of them will be decompressed\n   to the output file.  If outfile is -1, then the gzip stream(s) integrity is\n   checked and nothing is written.\n\n   The return value is a zlib error code: Z_MEM_ERROR if out of memory,\n   Z_DATA_ERROR if the header or the compressed data is invalid, or if the\n   trailer CRC-32 check or length doesn't match, Z_BUF_ERROR if the input ends\n   prematurely or a write error occurs, or Z_ERRNO if junk (not a another gzip\n   stream) follows a valid gzip stream.\n "
2018/06/19 20:06:53 " setup input buffer "
2018/06/19 20:06:53 " decompress concatenated gzip streams \n no input data read in yet \n looking for first gzip header \n so Z_BUF_ERROR means EOF "
2018/06/19 20:06:53 " look for the two magic header bytes for a gzip stream "
2018/06/19 20:06:53 " empty gzip stream is ok "
2018/06/19 20:06:53 " not a gzip or compress header "
2018/06/19 20:06:53 " next non-header is junk "
2018/06/19 20:06:53 " process a compress (LZW) file -- can't be concatenated after this "
2018/06/19 20:06:53 " process remainder of gzip header "
2018/06/19 20:06:53 " only deflate method allowed "
2018/06/19 20:06:53 " header flags \n discard mod time, xflgs, os "
2018/06/19 20:06:53 " extra field "
2018/06/19 20:06:53 " file name "
2018/06/19 20:06:53 " comment "
2018/06/19 20:06:53 " header crc "
2018/06/19 20:06:53 " set up output "
2018/06/19 20:06:53 " decompress data to output "
2018/06/19 20:06:53 " so Z_BUF_ERROR means EOF "
2018/06/19 20:06:53 " check trailer "
2018/06/19 20:06:53 " crc error "
2018/06/19 20:06:53 " length error "
2018/06/19 20:06:53 " go back and look for another gzip stream "
2018/06/19 20:06:53 " clean up and return "
2018/06/19 20:06:53 " Copy file attributes, from -> to, as best we can.  This is best effort, so\n   no errors are reported.  The mode bits, including suid, sgid, and the sticky\n   bit are copied (if allowed), the owner's user id and group id are copied\n   (again if allowed), and the access and modify times are copied. "
2018/06/19 20:06:53 " get all of from's Unix meta data, return if not a regular file "
2018/06/19 20:06:53 " set to's mode bits, ignore errors "
2018/06/19 20:06:53 " copy owner's user and group, ignore errors "
2018/06/19 20:06:53 " copy access and modify times, ignore errors "
2018/06/19 20:06:53 " Decompress the file inname to the file outnname, of if test is true, just\n   decompress without writing and check the gzip trailer for integrity.  If\n   inname is NULL or an empty string, read from stdin.  If outname is NULL or\n   an empty string, write to stdout.  strm is a pre-initialized inflateBack\n   structure.  When appropriate, copy the file attributes from inname to\n   outname.\n\n   gunzip() returns 1 if there is an out-of-memory error or an unexpected\n   return code from gunpipe().  Otherwise it returns 0.\n "
2018/06/19 20:06:53 " open files "
2018/06/19 20:06:53 " stdin "
2018/06/19 20:06:53 " stdout "
2018/06/19 20:06:53 " decompress "
2018/06/19 20:06:53 " interpret result "
2018/06/19 20:06:53 " copy attributes "
2018/06/19 20:06:53 " Process the gun command line arguments.  See the command syntax near the\n   beginning of this source file. "
2018/06/19 20:06:53 " initialize inflateBack state for repeated use \n reuse LZW match buffer "
2018/06/19 20:06:53 " decompress each file to the same name with the suffix removed "
2018/06/19 20:06:53 " clean up "
2018/06/19 20:06:53 Finished Classifying License "/zlib-1.2.11.tar.gz/examples/gun.c": 74.03573ms
2018/06/19 20:06:53 Couldn't classify license(s)
2018/06/19 20:06:53 Classifying license(s): /zlib-1.2.11.tar.gz/INDEX
2018/06/19 20:06:54 Finished Classifying License "/zlib-1.2.11.tar.gz/INDEX": 10.498465ms
2018/06/19 20:06:54 Couldn't classify license(s)
2018/06/19 20:06:54 Classifying license(s): /zlib-1.2.11.tar.gz/CMakeLists.txt
2018/06/19 20:06:54 Finished Classifying License "/zlib-1.2.11.tar.gz/CMakeLists.txt": 28.141483ms
2018/06/19 20:06:54 Couldn't classify license(s)
2018/06/19 20:06:55 Classifying license(s): /zlib-1.2.11.tar.gz/gzguts.h
2018/06/19 20:06:55 detected language: 4
2018/06/19 20:06:55 " gzguts.h -- zlib internal header definitions for gz* operations\n * Copyright (C) 2004, 2005, 2010, 2011, 2012, 2013, 2016 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n "
2018/06/19 20:06:55 " for compatibility with old definition "
2018/06/19 20:06:55 " vsnprintf may exist on some MS-DOS compilers (DJGPP?),\n   but for now we just assume it doesn't. "
2018/06/19 20:06:55 " In Win32, vsnprintf is available as the \"non-ANSI\" _vsnprintf. "
2018/06/19 20:06:55 " unlike snprintf (which is required in C99), _snprintf does not guarantee\n   null termination of the result -- however this is only used in gzlib.c where\n   the result is assured to fit in the space provided "
2018/06/19 20:06:55 " since \"static\" is used to mean two completely different things in C, we\n   define \"local\" for the non-static meaning of \"static\", for readability\n   (compile with -Dlocal if your debugger can't find static symbols) "
2018/06/19 20:06:55 " gz* functions always use library allocation functions "
2018/06/19 20:06:55 " get errno and strerror definition "
2018/06/19 20:06:55 " provide prototypes for these when building zlib without LFS "
2018/06/19 20:06:55 " default memLevel "
2018/06/19 20:06:55 " default i/o buffer size -- double this for output when reading (this and\n   twice this must be able to fit in an unsigned type) "
2018/06/19 20:06:55 " gzip modes, also provide a little integrity check on the passed structure "
2018/06/19 20:06:55 " mode set to GZ_WRITE after the file is opened "
2018/06/19 20:06:55 " values for gz_state how \n look for a gzip header \n copy input directly \n decompress a gzip stream "
2018/06/19 20:06:55 " internal gzip file state data structure "
2018/06/19 20:06:55 " exposed contents for gzgetc() macro \n \"x\" for exposed \n x.have: number of bytes available at x.next \n x.next: next output data to deliver or write \n x.pos: current position in uncompressed data \n used for both reading and writing \n see gzip modes above \n file descriptor \n path or fd for error messages \n buffer size, zero if not allocated yet \n requested buffer size, default is GZBUFSIZE \n input buffer (double-sized when writing) \n output buffer (double-sized when reading) \n 0 if processing gzip, 1 if transparent \n just for reading \n 0: get header, 1: copy, 2: decompress \n where the gzip data started, for rewinding \n true if end of input file reached \n true if read requested past end \n just for writing \n compression level \n compression strategy \n seek request \n amount to skip (already rewound if backwards) \n true if seek request pending \n error information \n error code \n error message \n zlib inflate or deflate stream \n stream structure in-place (not a pointer) "
2018/06/19 20:06:55 " shared functions "
2018/06/19 20:06:55 " GT_OFF(x), where x is an unsigned value, is true if x > maximum z_off64_t\n   value -- needed when comparing unsigned to z_off64_t, which is signed\n   (possible z_off64_t types off_t, off64_t, and long are all signed) "
2018/06/19 20:06:55 Finished Classifying License "/zlib-1.2.11.tar.gz/gzguts.h": 12.08708ms
2018/06/19 20:06:55 Couldn't classify license(s)
2018/06/19 20:06:56 Classifying license(s): /zlib-1.2.11.tar.gz/crc32.h
2018/06/19 20:06:56 detected language: 4
2018/06/19 20:06:56 " crc32.h -- tables for rapid CRC calculation\n * Generated automatically by crc32.c\n "
2018/06/19 20:06:56 Finished Classifying License "/zlib-1.2.11.tar.gz/crc32.h": 3.038237ms
2018/06/19 20:06:56 Couldn't classify license(s)
2018/06/19 20:06:57 Classifying license(s): /zlib-1.2.11.tar.gz/qnx/package.qpg
2018/06/19 20:06:57 Finished Classifying License "/zlib-1.2.11.tar.gz/qnx/package.qpg": 21.038171ms
2018/06/19 20:06:57 Couldn't classify license(s)
2018/06/19 20:06:57 Classifying license(s): /zlib-1.2.11.tar.gz/make_vms.com
2018/06/19 20:06:58 Finished Classifying License "/zlib-1.2.11.tar.gz/make_vms.com": 89.413021ms
2018/06/19 20:06:58 Couldn't classify license(s)
2018/06/19 20:06:58 Classifying license(s): /zlib-1.2.11.tar.gz/zlib.3.pdf
2018/06/19 20:06:58 Finished Classifying License "/zlib-1.2.11.tar.gz/zlib.3.pdf": 84.847348ms
2018/06/19 20:06:58 Couldn't classify license(s)
2018/06/19 20:06:59 Classifying license(s): /zlib-1.2.11.tar.gz/zlib.h
2018/06/19 20:06:59 detected language: 4
2018/06/19 20:06:59 " zlib.h -- interface of the 'zlib' general purpose compression library\n  version 1.2.11, January 15th, 2017\n\n  Copyright (C) 1995-2017 Jean-loup Gailly and Mark Adler\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n\n  Jean-loup Gailly        Mark Adler\n  jloup@gzip.org          madler@alumni.caltech.edu\n\n\n  The data format used by the zlib library is described by RFCs (Request for\n  Comments) 1950 to 1952 in the files http://tools.ietf.org/html/rfc1950\n  (zlib format), rfc1951 (deflate format) and rfc1952 (gzip format).\n"
2018/06/19 20:06:59 "\n    The 'zlib' compression library provides in-memory compression and\n  decompression functions, including integrity checks of the uncompressed data.\n  This version of the library supports only one compression method (deflation)\n  but other algorithms will be added later and will have the same stream\n  interface.\n\n    Compression can be done in a single step if the buffers are large enough,\n  or can be done by repeated calls of the compression function.  In the latter\n  case, the application must provide more input and/or consume the output\n  (providing more output space) before each call.\n\n    The compressed data format used by default by the in-memory functions is\n  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped\n  around a deflate stream, which is itself documented in RFC 1951.\n\n    The library also supports reading and writing files in gzip (.gz) format\n  with an interface similar to that of stdio using the functions that start\n  with \"gz\".  The gzip format is different from the zlib format.  gzip is a\n  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.\n\n    This library can optionally read and write gzip and raw deflate streams in\n  memory as well.\n\n    The zlib format was designed to be compact and fast for use in memory\n  and on communications channels.  The gzip format was designed for single-\n  file compression on file systems, has a larger header than zlib to maintain\n  directory information, and uses a different, slower check method than zlib.\n\n    The library does not install any signal handler.  The decoder checks\n  the consistency of the compressed data, so the library should never crash\n  even in the case of corrupted input.\n"
2018/06/19 20:06:59 " next input byte \n number of bytes available at next_in \n total number of input bytes read so far "
2018/06/19 20:06:59 " next output byte will go here \n remaining free space at next_out \n total number of bytes output so far "
2018/06/19 20:06:59 " last error message, NULL if no error \n not visible by applications "
2018/06/19 20:06:59 " used to allocate the internal state \n used to free the internal state \n private data object passed to zalloc and zfree "
2018/06/19 20:06:59 " best guess about the data type: binary or text\n                           for deflate, or the decoding state for inflate "
2018/06/19 20:06:59 " Adler-32 or CRC-32 value of the uncompressed data \n reserved for future use "
2018/06/19 20:06:59 "\n     gzip header information passed to and from zlib routines.  See RFC 1952\n  for more details on the meanings of these fields.\n"
2018/06/19 20:06:59 " true if compressed data believed to be text \n modification time \n extra flags (not used when writing a gzip file) \n operating system \n pointer to extra field or Z_NULL if none \n extra field length (valid if extra != Z_NULL) \n space at extra (only when reading header) \n pointer to zero-terminated file name or Z_NULL \n space at name (only when reading header) \n pointer to zero-terminated comment or Z_NULL \n space at comment (only when reading header) \n true if there was or will be a header crc \n true when done reading gzip header (not used\n                           when writing a gzip file) "
2018/06/19 20:06:59 "\n     The application must update next_in and avail_in when avail_in has dropped\n   to zero.  It must update next_out and avail_out when avail_out has dropped\n   to zero.  The application must initialize zalloc, zfree and opaque before\n   calling the init function.  All other fields are set by the compression\n   library and must not be updated by the application.\n\n     The opaque value provided by the application will be passed as the first\n   parameter for calls of zalloc and zfree.  This can be useful for custom\n   memory management.  The compression library attaches no meaning to the\n   opaque value.\n\n     zalloc must return Z_NULL if there is not enough memory for the object.\n   If zlib is used in a multi-threaded application, zalloc and zfree must be\n   thread safe.  In that case, zlib is thread-safe.  When zalloc and zfree are\n   Z_NULL on entry to the initialization function, they are set to internal\n   routines that use the standard library functions malloc() and free().\n\n     On 16-bit systems, the functions zalloc and zfree must be able to allocate\n   exactly 65536 bytes, but will not be required to allocate more than this if\n   the symbol MAXSEG_64K is defined (see zconf.h).  WARNING: On MSDOS, pointers\n   returned by zalloc for objects of exactly 65536 bytes *must* have their\n   offset normalized to zero.  The default allocation function provided by this\n   library ensures this (see zutil.c).  To reduce memory requirements and avoid\n   any allocation of 64K objects, at the expense of compression ratio, compile\n   the library with -DMAX_WBITS=14 (see zconf.h).\n\n     The fields total_in and total_out can be used for statistics or progress\n   reports.  After compression, total_in holds the total size of the\n   uncompressed data and may be saved for use by the decompressor (particularly\n   if the decompressor wants to decompress everything in a single step).\n"
2018/06/19 20:06:59 " constants "
2018/06/19 20:06:59 " Allowed flush values; see deflate() and inflate() below for details "
2018/06/19 20:06:59 " Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n "
2018/06/19 20:06:59 " compression levels "
2018/06/19 20:06:59 " compression strategy; see deflateInit2() below for details "
2018/06/19 20:06:59 " for compatibility with 1.2.2 and earlier "
2018/06/19 20:06:59 " Possible values of the data_type field for deflate() "
2018/06/19 20:06:59 " The deflate compression method (the only one supported in this version) "
2018/06/19 20:06:59 " for initializing zalloc, zfree, opaque "
2018/06/19 20:06:59 " for compatibility with versions < 1.0.2 "
2018/06/19 20:06:59 " basic functions "
2018/06/19 20:06:59 " The application can compare zlibVersion and ZLIB_VERSION for consistency.\n   If the first character differs, the library code actually used is not\n   compatible with the zlib.h header file used by the application.  This check\n   is automatically made by deflateInit and inflateInit.\n "
2018/06/19 20:06:59 "\nZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));\n\n     Initializes the internal stream state for compression.  The fields\n   zalloc, zfree and opaque must be initialized before by the caller.  If\n   zalloc and zfree are set to Z_NULL, deflateInit updates them to use default\n   allocation functions.\n\n     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:\n   1 gives best speed, 9 gives best compression, 0 gives no compression at all\n   (the input data is simply copied a block at a time).  Z_DEFAULT_COMPRESSION\n   requests a default compromise between speed and compression (currently\n   equivalent to level 6).\n\n     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough\n   memory, Z_STREAM_ERROR if level is not a valid compression level, or\n   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible\n   with the version assumed by the caller (ZLIB_VERSION).  msg is set to null\n   if there is no error message.  deflateInit does not perform any compression:\n   this will be done by deflate().\n"
2018/06/19 20:06:59 "\n    deflate compresses as much data as possible, and stops when the input\n  buffer becomes empty or the output buffer becomes full.  It may introduce\n  some output latency (reading input without producing any output) except when\n  forced to flush.\n\n    The detailed semantics are as follows.  deflate performs one or both of the\n  following actions:\n\n  - Compress more input starting at next_in and update next_in and avail_in\n    accordingly.  If not all input can be processed (because there is not\n    enough room in the output buffer), next_in and avail_in are updated and\n    processing will resume at this point for the next call of deflate().\n\n  - Generate more output starting at next_out and update next_out and avail_out\n    accordingly.  This action is forced if the parameter flush is non zero.\n    Forcing flush frequently degrades the compression ratio, so this parameter\n    should be set only when necessary.  Some output may be provided even if\n    flush is zero.\n\n    Before the call of deflate(), the application should ensure that at least\n  one of the actions is possible, by providing more input and/or consuming more\n  output, and updating avail_in or avail_out accordingly; avail_out should\n  never be zero before the call.  The application can consume the compressed\n  output when it wants, for example when the output buffer is full (avail_out\n  == 0), or after each call of deflate().  If deflate returns Z_OK and with\n  zero avail_out, it must be called again after making room in the output\n  buffer because there might be more output pending. See deflatePending(),\n  which can be used if desired to determine whether or not there is more ouput\n  in that case.\n\n    Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to\n  decide how much data to accumulate before producing output, in order to\n  maximize compression.\n\n    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is\n  flushed to the output buffer and the output is aligned on a byte boundary, so\n  that the decompressor can get all input data available so far.  (In\n  particular avail_in is zero after the call if enough output space has been\n  provided before the call.) Flushing may degrade compression for some\n  compression algorithms and so it should be used only when necessary.  This\n  completes the current deflate block and follows it with an empty stored block\n  that is three bits plus filler bits to the next byte, followed by four bytes\n  (00 00 ff ff).\n\n    If flush is set to Z_PARTIAL_FLUSH, all pending output is flushed to the\n  output buffer, but the output is not aligned to a byte boundary.  All of the\n  input data so far will be available to the decompressor, as for Z_SYNC_FLUSH.\n  This completes the current deflate block and follows it with an empty fixed\n  codes block that is 10 bits long.  This assures that enough bytes are output\n  in order for the decompressor to finish the block before the empty fixed\n  codes block.\n\n    If flush is set to Z_BLOCK, a deflate block is completed and emitted, as\n  for Z_SYNC_FLUSH, but the output is not aligned on a byte boundary, and up to\n  seven bits of the current block are held to be written as the next byte after\n  the next deflate block is completed.  In this case, the decompressor may not\n  be provided enough bits at this point in order to complete decompression of\n  the data provided so far to the compressor.  It may need to wait for the next\n  block to be emitted.  This is for advanced applications that need to control\n  the emission of deflate blocks.\n\n    If flush is set to Z_FULL_FLUSH, all output is flushed as with\n  Z_SYNC_FLUSH, and the compression state is reset so that decompression can\n  restart from this point if previous compressed data has been damaged or if\n  random access is desired.  Using Z_FULL_FLUSH too often can seriously degrade\n  compression.\n\n    If deflate returns with avail_out == 0, this function must be called again\n  with the same value of the flush parameter and more output space (updated\n  avail_out), until the flush is complete (deflate returns with non-zero\n  avail_out).  In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that\n  avail_out is greater than six to avoid repeated flush markers due to\n  avail_out == 0 on return.\n\n    If the parameter flush is set to Z_FINISH, pending input is processed,\n  pending output is flushed and deflate returns with Z_STREAM_END if there was\n  enough output space.  If deflate returns with Z_OK or Z_BUF_ERROR, this\n  function must be called again with Z_FINISH and more output space (updated\n  avail_out) but no more input data, until it returns with Z_STREAM_END or an\n  error.  After deflate has returned Z_STREAM_END, the only possible operations\n  on the stream are deflateReset or deflateEnd.\n\n    Z_FINISH can be used in the first deflate call after deflateInit if all the\n  compression is to be done in a single step.  In order to complete in one\n  call, avail_out must be at least the value returned by deflateBound (see\n  below).  Then deflate is guaranteed to return Z_STREAM_END.  If not enough\n  output space is provided, deflate will not return Z_STREAM_END, and it must\n  be called again as described above.\n\n    deflate() sets strm->adler to the Adler-32 checksum of all input read\n  so far (that is, total_in bytes).  If a gzip stream is being generated, then\n  strm->adler will be the CRC-32 checksum of the input read so far.  (See\n  deflateInit2 below.)\n\n    deflate() may update strm->data_type if it can make a good guess about\n  the input data type (Z_BINARY or Z_TEXT).  If in doubt, the data is\n  considered binary.  This field is only for information purposes and does not\n  affect the compression algorithm in any manner.\n\n    deflate() returns Z_OK if some progress has been made (more input\n  processed or more output produced), Z_STREAM_END if all input has been\n  consumed and all output has been produced (only when flush is set to\n  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example\n  if next_in or next_out was Z_NULL or the state was inadvertently written over\n  by the application), or Z_BUF_ERROR if no progress is possible (for example\n  avail_in or avail_out was zero).  Note that Z_BUF_ERROR is not fatal, and\n  deflate() can be called again with more input and more output space to\n  continue compressing.\n"
2018/06/19 20:06:59 "\n     All dynamically allocated data structures for this stream are freed.\n   This function discards any unprocessed input and does not flush any pending\n   output.\n\n     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the\n   stream state was inconsistent, Z_DATA_ERROR if the stream was freed\n   prematurely (some input or output was discarded).  In the error case, msg\n   may be set but then points to a static string (which must not be\n   deallocated).\n"
2018/06/19 20:06:59 "\nZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));\n\n     Initializes the internal stream state for decompression.  The fields\n   next_in, avail_in, zalloc, zfree and opaque must be initialized before by\n   the caller.  In the current version of inflate, the provided input is not\n   read or consumed.  The allocation of a sliding window will be deferred to\n   the first call of inflate (if the decompression does not complete on the\n   first call).  If zalloc and zfree are set to Z_NULL, inflateInit updates\n   them to use default allocation functions.\n\n     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough\n   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the\n   version assumed by the caller, or Z_STREAM_ERROR if the parameters are\n   invalid, such as a null pointer to the structure.  msg is set to null if\n   there is no error message.  inflateInit does not perform any decompression.\n   Actual decompression will be done by inflate().  So next_in, and avail_in,\n   next_out, and avail_out are unused and unchanged.  The current\n   implementation of inflateInit() does not process any header information --\n   that is deferred until inflate() is called.\n"
2018/06/19 20:06:59 "\n    inflate decompresses as much data as possible, and stops when the input\n  buffer becomes empty or the output buffer becomes full.  It may introduce\n  some output latency (reading input without producing any output) except when\n  forced to flush.\n\n  The detailed semantics are as follows.  inflate performs one or both of the\n  following actions:\n\n  - Decompress more input starting at next_in and update next_in and avail_in\n    accordingly.  If not all input can be processed (because there is not\n    enough room in the output buffer), then next_in and avail_in are updated\n    accordingly, and processing will resume at this point for the next call of\n    inflate().\n\n  - Generate more output starting at next_out and update next_out and avail_out\n    accordingly.  inflate() provides as much output as possible, until there is\n    no more input data or no more space in the output buffer (see below about\n    the flush parameter).\n\n    Before the call of inflate(), the application should ensure that at least\n  one of the actions is possible, by providing more input and/or consuming more\n  output, and updating the next_* and avail_* values accordingly.  If the\n  caller of inflate() does not provide both available input and available\n  output space, it is possible that there will be no progress made.  The\n  application can consume the uncompressed output when it wants, for example\n  when the output buffer is full (avail_out == 0), or after each call of\n  inflate().  If inflate returns Z_OK and with zero avail_out, it must be\n  called again after making room in the output buffer because there might be\n  more output pending.\n\n    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,\n  Z_BLOCK, or Z_TREES.  Z_SYNC_FLUSH requests that inflate() flush as much\n  output as possible to the output buffer.  Z_BLOCK requests that inflate()\n  stop if and when it gets to the next deflate block boundary.  When decoding\n  the zlib or gzip format, this will cause inflate() to return immediately\n  after the header and before the first block.  When doing a raw inflate,\n  inflate() will go ahead and process the first block, and will return when it\n  gets to the end of that block, or when it runs out of data.\n\n    The Z_BLOCK option assists in appending to or combining deflate streams.\n  To assist in this, on return inflate() always sets strm->data_type to the\n  number of unused bits in the last byte taken from strm->next_in, plus 64 if\n  inflate() is currently decoding the last block in the deflate stream, plus\n  128 if inflate() returned immediately after decoding an end-of-block code or\n  decoding the complete header up to just before the first byte of the deflate\n  stream.  The end-of-block will not be indicated until all of the uncompressed\n  data from that block has been written to strm->next_out.  The number of\n  unused bits may in general be greater than seven, except when bit 7 of\n  data_type is set, in which case the number of unused bits will be less than\n  eight.  data_type is set as noted here every time inflate() returns for all\n  flush options, and so can be used to determine the amount of currently\n  consumed input in bits.\n\n    The Z_TREES option behaves as Z_BLOCK does, but it also returns when the\n  end of each deflate block header is reached, before any actual data in that\n  block is decoded.  This allows the caller to determine the length of the\n  deflate block header for later use in random access within a deflate block.\n  256 is added to the value of strm->data_type when inflate() returns\n  immediately after reaching the end of the deflate block header.\n\n    inflate() should normally be called until it returns Z_STREAM_END or an\n  error.  However if all decompression is to be performed in a single step (a\n  single call of inflate), the parameter flush should be set to Z_FINISH.  In\n  this case all pending input is processed and all pending output is flushed;\n  avail_out must be large enough to hold all of the uncompressed data for the\n  operation to complete.  (The size of the uncompressed data may have been\n  saved by the compressor for this purpose.)  The use of Z_FINISH is not\n  required to perform an inflation in one step.  However it may be used to\n  inform inflate that a faster approach can be used for the single inflate()\n  call.  Z_FINISH also informs inflate to not maintain a sliding window if the\n  stream completes, which reduces inflate's memory footprint.  If the stream\n  does not complete, either because not all of the stream is provided or not\n  enough output space is provided, then a sliding window will be allocated and\n  inflate() can be called again to continue the operation as if Z_NO_FLUSH had\n  been used.\n\n     In this implementation, inflate() always flushes as much output as\n  possible to the output buffer, and always uses the faster approach on the\n  first call.  So the effects of the flush parameter in this implementation are\n  on the return value of inflate() as noted below, when inflate() returns early\n  when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of\n  memory for a sliding window when Z_FINISH is used.\n\n     If a preset dictionary is needed after this call (see inflateSetDictionary\n  below), inflate sets strm->adler to the Adler-32 checksum of the dictionary\n  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets\n  strm->adler to the Adler-32 checksum of all output produced so far (that is,\n  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described\n  below.  At the end of the stream, inflate() checks that its computed Adler-32\n  checksum is equal to that saved by the compressor and returns Z_STREAM_END\n  only if the checksum is correct.\n\n    inflate() can decompress and check either zlib-wrapped or gzip-wrapped\n  deflate data.  The header type is detected automatically, if requested when\n  initializing with inflateInit2().  Any information contained in the gzip\n  header is not retained unless inflateGetHeader() is used.  When processing\n  gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output\n  produced so far.  The CRC-32 is checked against the gzip trailer, as is the\n  uncompressed length, modulo 2^32.\n\n    inflate() returns Z_OK if some progress has been made (more input processed\n  or more output produced), Z_STREAM_END if the end of the compressed data has\n  been reached and all uncompressed output has been produced, Z_NEED_DICT if a\n  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was\n  corrupted (input stream not conforming to the zlib format or incorrect check\n  value, in which case strm->msg points to a string with a more specific\n  error), Z_STREAM_ERROR if the stream structure was inconsistent (for example\n  next_in or next_out was Z_NULL, or the state was inadvertently written over\n  by the application), Z_MEM_ERROR if there was not enough memory, Z_BUF_ERROR\n  if no progress was possible or if there was not enough room in the output\n  buffer when Z_FINISH is used.  Note that Z_BUF_ERROR is not fatal, and\n  inflate() can be called again with more input and more output space to\n  continue decompressing.  If Z_DATA_ERROR is returned, the application may\n  then call inflateSync() to look for a good compression block if a partial\n  recovery of the data is to be attempted.\n"
2018/06/19 20:06:59 "\n     All dynamically allocated data structures for this stream are freed.\n   This function discards any unprocessed input and does not flush any pending\n   output.\n\n     inflateEnd returns Z_OK if success, or Z_STREAM_ERROR if the stream state\n   was inconsistent.\n"
2018/06/19 20:06:59 " Advanced functions "
2018/06/19 20:06:59 "\n    The following functions are needed only in some special applications.\n"
2018/06/19 20:06:59 "\nZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,\n                                     int  level,\n                                     int  method,\n                                     int  windowBits,\n                                     int  memLevel,\n                                     int  strategy));\n\n     This is another version of deflateInit with more compression options.  The\n   fields next_in, zalloc, zfree and opaque must be initialized before by the\n   caller.\n\n     The method parameter is the compression method.  It must be Z_DEFLATED in\n   this version of the library.\n\n     The windowBits parameter is the base two logarithm of the window size\n   (the size of the history buffer).  It should be in the range 8..15 for this\n   version of the library.  Larger values of this parameter result in better\n   compression at the expense of memory usage.  The default value is 15 if\n   deflateInit is used instead.\n\n     For the current implementation of deflate(), a windowBits value of 8 (a\n   window size of 256 bytes) is not supported.  As a result, a request for 8\n   will result in 9 (a 512-byte window).  In that case, providing 8 to\n   inflateInit2() will result in an error when the zlib header with 9 is\n   checked against the initialization of inflate().  The remedy is to not use 8\n   with deflateInit2() with this initialization, or at least in that case use 9\n   with inflateInit2().\n\n     windowBits can also be -8..-15 for raw deflate.  In this case, -windowBits\n   determines the window size.  deflate() will then generate raw deflate data\n   with no zlib header or trailer, and will not compute a check value.\n\n     windowBits can also be greater than 15 for optional gzip encoding.  Add\n   16 to windowBits to write a simple gzip header and trailer around the\n   compressed data instead of a zlib wrapper.  The gzip header will have no\n   file name, no extra data, no comment, no modification time (set to zero), no\n   header crc, and the operating system will be set to the appropriate value,\n   if the operating system was determined at compile time.  If a gzip stream is\n   being written, strm->adler is a CRC-32 instead of an Adler-32.\n\n     For raw deflate or gzip encoding, a request for a 256-byte window is\n   rejected as invalid, since only the zlib header provides a means of\n   transmitting the window size to the decompressor.\n\n     The memLevel parameter specifies how much memory should be allocated\n   for the internal compression state.  memLevel=1 uses minimum memory but is\n   slow and reduces compression ratio; memLevel=9 uses maximum memory for\n   optimal speed.  The default value is 8.  See zconf.h for total memory usage\n   as a function of windowBits and memLevel.\n\n     The strategy parameter is used to tune the compression algorithm.  Use the\n   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a\n   filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no\n   string match), or Z_RLE to limit match distances to one (run-length\n   encoding).  Filtered data consists mostly of small values with a somewhat\n   random distribution.  In this case, the compression algorithm is tuned to\n   compress them better.  The effect of Z_FILTERED is to force more Huffman\n   coding and less string matching; it is somewhat intermediate between\n   Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY.  Z_RLE is designed to be almost as\n   fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data.  The\n   strategy parameter only affects the compression ratio but not the\n   correctness of the compressed output even if it is not set appropriately.\n   Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler\n   decoder for special applications.\n\n     deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough\n   memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid\n   method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is\n   incompatible with the version assumed by the caller (ZLIB_VERSION).  msg is\n   set to null if there is no error message.  deflateInit2 does not perform any\n   compression: this will be done by deflate().\n"
2018/06/19 20:06:59 "\n     Initializes the compression dictionary from the given byte sequence\n   without producing any compressed output.  When using the zlib format, this\n   function must be called immediately after deflateInit, deflateInit2 or\n   deflateReset, and before any call of deflate.  When doing raw deflate, this\n   function must be called either before any call of deflate, or immediately\n   after the completion of a deflate block, i.e. after all input has been\n   consumed and all output has been delivered when using any of the flush\n   options Z_BLOCK, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, or Z_FULL_FLUSH.  The\n   compressor and decompressor must use exactly the same dictionary (see\n   inflateSetDictionary).\n\n     The dictionary should consist of strings (byte sequences) that are likely\n   to be encountered later in the data to be compressed, with the most commonly\n   used strings preferably put towards the end of the dictionary.  Using a\n   dictionary is most useful when the data to be compressed is short and can be\n   predicted with good accuracy; the data can then be compressed better than\n   with the default empty dictionary.\n\n     Depending on the size of the compression data structures selected by\n   deflateInit or deflateInit2, a part of the dictionary may in effect be\n   discarded, for example if the dictionary is larger than the window size\n   provided in deflateInit or deflateInit2.  Thus the strings most likely to be\n   useful should be put at the end of the dictionary, not at the front.  In\n   addition, the current implementation of deflate will use at most the window\n   size minus 262 bytes of the provided dictionary.\n\n     Upon return of this function, strm->adler is set to the Adler-32 value\n   of the dictionary; the decompressor may later use this value to determine\n   which dictionary has been used by the compressor.  (The Adler-32 value\n   applies to the whole dictionary even if only a subset of the dictionary is\n   actually used by the compressor.) If a raw deflate was requested, then the\n   Adler-32 value is not computed and strm->adler is not set.\n\n     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a\n   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is\n   inconsistent (for example if deflate has already been called for this stream\n   or if not at a block boundary for raw deflate).  deflateSetDictionary does\n   not perform any compression: this will be done by deflate().\n"
2018/06/19 20:06:59 "\n     Returns the sliding dictionary being maintained by deflate.  dictLength is\n   set to the number of bytes in the dictionary, and that many bytes are copied\n   to dictionary.  dictionary must have enough space, where 32768 bytes is\n   always enough.  If deflateGetDictionary() is called with dictionary equal to\n   Z_NULL, then only the dictionary length is returned, and nothing is copied.\n   Similary, if dictLength is Z_NULL, then it is not set.\n\n     deflateGetDictionary() may return a length less than the window size, even\n   when more than the window size in input has been provided. It may return up\n   to 258 bytes less in that case, due to how zlib's implementation of deflate\n   manages the sliding window and lookahead for matches, where matches can be\n   up to 258 bytes long. If the application needs the last window-size bytes of\n   input, then that would need to be saved by the application outside of zlib.\n\n     deflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the\n   stream state is inconsistent.\n"
2018/06/19 20:06:59 "\n     Sets the destination stream as a complete copy of the source stream.\n\n     This function can be useful when several compression strategies will be\n   tried, for example when there are several ways of pre-processing the input\n   data with a filter.  The streams that will be discarded should then be freed\n   by calling deflateEnd.  Note that deflateCopy duplicates the internal\n   compression state which can be quite large, so this strategy is slow and can\n   consume lots of memory.\n\n     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not\n   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent\n   (such as zalloc being Z_NULL).  msg is left unchanged in both source and\n   destination.\n"
2018/06/19 20:06:59 "\n     This function is equivalent to deflateEnd followed by deflateInit, but\n   does not free and reallocate the internal compression state.  The stream\n   will leave the compression level and any other attributes that may have been\n   set unchanged.\n\n     deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source\n   stream state was inconsistent (such as zalloc or state being Z_NULL).\n"
2018/06/19 20:06:59 "\n     Dynamically update the compression level and compression strategy.  The\n   interpretation of level and strategy is as in deflateInit2().  This can be\n   used to switch between compression and straight copy of the input data, or\n   to switch to a different kind of input data requiring a different strategy.\n   If the compression approach (which is a function of the level) or the\n   strategy is changed, and if any input has been consumed in a previous\n   deflate() call, then the input available so far is compressed with the old\n   level and strategy using deflate(strm, Z_BLOCK).  There are three approaches\n   for the compression levels 0, 1..3, and 4..9 respectively.  The new level\n   and strategy will take effect at the next call of deflate().\n\n     If a deflate(strm, Z_BLOCK) is performed by deflateParams(), and it does\n   not have enough output space to complete, then the parameter change will not\n   take effect.  In this case, deflateParams() can be called again with the\n   same parameters and more output space to try again.\n\n     In order to assure a change in the parameters on the first try, the\n   deflate stream should be flushed using deflate() with Z_BLOCK or other flush\n   request until strm.avail_out is not zero, before calling deflateParams().\n   Then no more input data should be provided before the deflateParams() call.\n   If this is done, the old level and strategy will be applied to the data\n   compressed before deflateParams(), and the new level and strategy will be\n   applied to the the data compressed after deflateParams().\n\n     deflateParams returns Z_OK on success, Z_STREAM_ERROR if the source stream\n   state was inconsistent or if a parameter was invalid, or Z_BUF_ERROR if\n   there was not enough output space to complete the compression of the\n   available input data before a change in the strategy or approach.  Note that\n   in the case of a Z_BUF_ERROR, the parameters are not changed.  A return\n   value of Z_BUF_ERROR is not fatal, in which case deflateParams() can be\n   retried with more output space.\n"
2018/06/19 20:06:59 "\n     Fine tune deflate's internal compression parameters.  This should only be\n   used by someone who understands the algorithm used by zlib's deflate for\n   searching for the best matching string, and even then only by the most\n   fanatic optimizer trying to squeeze out the last compressed bit for their\n   specific input data.  Read the deflate.c source code for the meaning of the\n   max_lazy, good_length, nice_length, and max_chain parameters.\n\n     deflateTune() can be called after deflateInit() or deflateInit2(), and\n   returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.\n "
2018/06/19 20:06:59 "\n     deflateBound() returns an upper bound on the compressed size after\n   deflation of sourceLen bytes.  It must be called after deflateInit() or\n   deflateInit2(), and after deflateSetHeader(), if used.  This would be used\n   to allocate an output buffer for deflation in a single pass, and so would be\n   called before deflate().  If that first deflate() call is provided the\n   sourceLen input bytes, an output buffer allocated to the size returned by\n   deflateBound(), and the flush value Z_FINISH, then deflate() is guaranteed\n   to return Z_STREAM_END.  Note that it is possible for the compressed size to\n   be larger than the value returned by deflateBound() if flush options other\n   than Z_FINISH or Z_NO_FLUSH are used.\n"
2018/06/19 20:06:59 "\n     deflatePending() returns the number of bytes and bits of output that have\n   been generated, but not yet provided in the available output.  The bytes not\n   provided would be due to the available output space having being consumed.\n   The number of bits of output not provided are between 0 and 7, where they\n   await more bits to join them in order to fill out a full byte.  If pending\n   or bits are Z_NULL, then those values are not set.\n\n     deflatePending returns Z_OK if success, or Z_STREAM_ERROR if the source\n   stream state was inconsistent.\n "
2018/06/19 20:06:59 "\n     deflatePrime() inserts bits in the deflate output stream.  The intent\n   is that this function is used to start off the deflate output with the bits\n   leftover from a previous deflate stream when appending to it.  As such, this\n   function can only be used for raw deflate, and must be used before the first\n   deflate() call after a deflateInit2() or deflateReset().  bits must be less\n   than or equal to 16, and that many of the least significant bits of value\n   will be inserted in the output.\n\n     deflatePrime returns Z_OK if success, Z_BUF_ERROR if there was not enough\n   room in the internal buffer to insert the bits, or Z_STREAM_ERROR if the\n   source stream state was inconsistent.\n"
2018/06/19 20:06:59 "\n     deflateSetHeader() provides gzip header information for when a gzip\n   stream is requested by deflateInit2().  deflateSetHeader() may be called\n   after deflateInit2() or deflateReset() and before the first call of\n   deflate().  The text, time, os, extra field, name, and comment information\n   in the provided gz_header structure are written to the gzip header (xflag is\n   ignored -- the extra flags are set according to the compression level).  The\n   caller must assure that, if not Z_NULL, name and comment are terminated with\n   a zero byte, and that if extra is not Z_NULL, that extra_len bytes are\n   available there.  If hcrc is true, a gzip header crc is included.  Note that\n   the current versions of the command-line version of gzip (up through version\n   1.3.x) do not support header crc's, and will report that it is a \"multi-part\n   gzip file\" and give up.\n\n     If deflateSetHeader is not used, the default gzip header has text false,\n   the time set to zero, and os set to 255, with no extra, name, or comment\n   fields.  The gzip header is returned to the default state by deflateReset().\n\n     deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source\n   stream state was inconsistent.\n"
2018/06/19 20:06:59 "\nZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,\n                                     int  windowBits));\n\n     This is another version of inflateInit with an extra parameter.  The\n   fields next_in, avail_in, zalloc, zfree and opaque must be initialized\n   before by the caller.\n\n     The windowBits parameter is the base two logarithm of the maximum window\n   size (the size of the history buffer).  It should be in the range 8..15 for\n   this version of the library.  The default value is 15 if inflateInit is used\n   instead.  windowBits must be greater than or equal to the windowBits value\n   provided to deflateInit2() while compressing, or it must be equal to 15 if\n   deflateInit2() was not used.  If a compressed stream with a larger window\n   size is given as input, inflate() will return with the error code\n   Z_DATA_ERROR instead of trying to allocate a larger window.\n\n     windowBits can also be zero to request that inflate use the window size in\n   the zlib header of the compressed stream.\n\n     windowBits can also be -8..-15 for raw inflate.  In this case, -windowBits\n   determines the window size.  inflate() will then process raw deflate data,\n   not looking for a zlib or gzip header, not generating a check value, and not\n   looking for any check values for comparison at the end of the stream.  This\n   is for use with other formats that use the deflate compressed data format\n   such as zip.  Those formats provide their own check values.  If a custom\n   format is developed using the raw deflate format for compressed data, it is\n   recommended that a check value such as an Adler-32 or a CRC-32 be applied to\n   the uncompressed data as is done in the zlib, gzip, and zip formats.  For\n   most applications, the zlib format should be used as is.  Note that comments\n   above on the use in deflateInit2() applies to the magnitude of windowBits.\n\n     windowBits can also be greater than 15 for optional gzip decoding.  Add\n   32 to windowBits to enable zlib and gzip decoding with automatic header\n   detection, or add 16 to decode only the gzip format (the zlib format will\n   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is a\n   CRC-32 instead of an Adler-32.  Unlike the gunzip utility and gzread() (see\n   below), inflate() will not automatically decode concatenated gzip streams.\n   inflate() will return Z_STREAM_END at the end of the gzip stream.  The state\n   would need to be reset to continue decoding a subsequent gzip stream.\n\n     inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough\n   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the\n   version assumed by the caller, or Z_STREAM_ERROR if the parameters are\n   invalid, such as a null pointer to the structure.  msg is set to null if\n   there is no error message.  inflateInit2 does not perform any decompression\n   apart from possibly reading the zlib header if present: actual decompression\n   will be done by inflate().  (So next_in and avail_in may be modified, but\n   next_out and avail_out are unused and unchanged.) The current implementation\n   of inflateInit2() does not process any header information -- that is\n   deferred until inflate() is called.\n"
2018/06/19 20:06:59 "\n     Initializes the decompression dictionary from the given uncompressed byte\n   sequence.  This function must be called immediately after a call of inflate,\n   if that call returned Z_NEED_DICT.  The dictionary chosen by the compressor\n   can be determined from the Adler-32 value returned by that call of inflate.\n   The compressor and decompressor must use exactly the same dictionary (see\n   deflateSetDictionary).  For raw inflate, this function can be called at any\n   time to set the dictionary.  If the provided dictionary is smaller than the\n   window and there is already data in the window, then the provided dictionary\n   will amend what's there.  The application must insure that the dictionary\n   that was used for compression is provided.\n\n     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a\n   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is\n   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the\n   expected one (incorrect Adler-32 value).  inflateSetDictionary does not\n   perform any decompression: this will be done by subsequent calls of\n   inflate().\n"
2018/06/19 20:06:59 "\n     Returns the sliding dictionary being maintained by inflate.  dictLength is\n   set to the number of bytes in the dictionary, and that many bytes are copied\n   to dictionary.  dictionary must have enough space, where 32768 bytes is\n   always enough.  If inflateGetDictionary() is called with dictionary equal to\n   Z_NULL, then only the dictionary length is returned, and nothing is copied.\n   Similary, if dictLength is Z_NULL, then it is not set.\n\n     inflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the\n   stream state is inconsistent.\n"
2018/06/19 20:06:59 "\n     Skips invalid compressed data until a possible full flush point (see above\n   for the description of deflate with Z_FULL_FLUSH) can be found, or until all\n   available input is skipped.  No output is provided.\n\n     inflateSync searches for a 00 00 FF FF pattern in the compressed data.\n   All full flush points have this pattern, but not all occurrences of this\n   pattern are full flush points.\n\n     inflateSync returns Z_OK if a possible full flush point has been found,\n   Z_BUF_ERROR if no more input was provided, Z_DATA_ERROR if no flush point\n   has been found, or Z_STREAM_ERROR if the stream structure was inconsistent.\n   In the success case, the application may save the current current value of\n   total_in which indicates where valid compressed data was found.  In the\n   error case, the application may repeatedly call inflateSync, providing more\n   input each time, until success or end of the input data.\n"
2018/06/19 20:06:59 "\n     Sets the destination stream as a complete copy of the source stream.\n\n     This function can be useful when randomly accessing a large stream.  The\n   first pass through the stream can periodically record the inflate state,\n   allowing restarting inflate at those points when randomly accessing the\n   stream.\n\n     inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not\n   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent\n   (such as zalloc being Z_NULL).  msg is left unchanged in both source and\n   destination.\n"
2018/06/19 20:06:59 "\n     This function is equivalent to inflateEnd followed by inflateInit,\n   but does not free and reallocate the internal decompression state.  The\n   stream will keep attributes that may have been set by inflateInit2.\n\n     inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source\n   stream state was inconsistent (such as zalloc or state being Z_NULL).\n"
2018/06/19 20:06:59 "\n     This function is the same as inflateReset, but it also permits changing\n   the wrap and window size requests.  The windowBits parameter is interpreted\n   the same as it is for inflateInit2.  If the window size is changed, then the\n   memory allocated for the window is freed, and the window will be reallocated\n   by inflate() if needed.\n\n     inflateReset2 returns Z_OK if success, or Z_STREAM_ERROR if the source\n   stream state was inconsistent (such as zalloc or state being Z_NULL), or if\n   the windowBits parameter is invalid.\n"
2018/06/19 20:06:59 "\n     This function inserts bits in the inflate input stream.  The intent is\n   that this function is used to start inflating at a bit position in the\n   middle of a byte.  The provided bits will be used before any bytes are used\n   from next_in.  This function should only be used with raw inflate, and\n   should be used before the first inflate() call after inflateInit2() or\n   inflateReset().  bits must be less than or equal to 16, and that many of the\n   least significant bits of value will be inserted in the input.\n\n     If bits is negative, then the input stream bit buffer is emptied.  Then\n   inflatePrime() can be called again to put bits in the buffer.  This is used\n   to clear out bits leftover after feeding inflate a block description prior\n   to feeding inflate codes.\n\n     inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source\n   stream state was inconsistent.\n"
2018/06/19 20:06:59 "\n     This function returns two values, one in the lower 16 bits of the return\n   value, and the other in the remaining upper bits, obtained by shifting the\n   return value down 16 bits.  If the upper value is -1 and the lower value is\n   zero, then inflate() is currently decoding information outside of a block.\n   If the upper value is -1 and the lower value is non-zero, then inflate is in\n   the middle of a stored block, with the lower value equaling the number of\n   bytes from the input remaining to copy.  If the upper value is not -1, then\n   it is the number of bits back from the current bit position in the input of\n   the code (literal or length/distance pair) currently being processed.  In\n   that case the lower value is the number of bytes already emitted for that\n   code.\n\n     A code is being processed if inflate is waiting for more input to complete\n   decoding of the code, or if it has completed decoding but is waiting for\n   more output space to write the literal or match data.\n\n     inflateMark() is used to mark locations in the input data for random\n   access, which may be at bit positions, and to note those cases where the\n   output of a code may span boundaries of random access blocks.  The current\n   location in the input stream can be determined from avail_in and data_type\n   as noted in the description for the Z_BLOCK flush parameter for inflate.\n\n     inflateMark returns the value noted above, or -65536 if the provided\n   source stream state was inconsistent.\n"
2018/06/19 20:06:59 "\n     inflateGetHeader() requests that gzip header information be stored in the\n   provided gz_header structure.  inflateGetHeader() may be called after\n   inflateInit2() or inflateReset(), and before the first call of inflate().\n   As inflate() processes the gzip stream, head->done is zero until the header\n   is completed, at which time head->done is set to one.  If a zlib stream is\n   being decoded, then head->done is set to -1 to indicate that there will be\n   no gzip header information forthcoming.  Note that Z_BLOCK or Z_TREES can be\n   used to force inflate() to return immediately after header processing is\n   complete and before any actual data is decompressed.\n\n     The text, time, xflags, and os fields are filled in with the gzip header\n   contents.  hcrc is set to true if there is a header CRC.  (The header CRC\n   was valid if done is set to one.) If extra is not Z_NULL, then extra_max\n   contains the maximum number of bytes to write to extra.  Once done is true,\n   extra_len contains the actual extra field length, and extra contains the\n   extra field, or that field truncated if extra_max is less than extra_len.\n   If name is not Z_NULL, then up to name_max characters are written there,\n   terminated with a zero unless the length is greater than name_max.  If\n   comment is not Z_NULL, then up to comm_max characters are written there,\n   terminated with a zero unless the length is greater than comm_max.  When any\n   of extra, name, or comment are not Z_NULL and the respective field is not\n   present in the header, then that field is set to Z_NULL to signal its\n   absence.  This allows the use of deflateSetHeader() with the returned\n   structure to duplicate the header.  However if those fields are set to\n   allocated memory, then the application will need to save those pointers\n   elsewhere so that they can be eventually freed.\n\n     If inflateGetHeader is not used, then the header information is simply\n   discarded.  The header is always checked for validity, including the header\n   CRC if present.  inflateReset() will reset the process to discard the header\n   information.  The application would need to call inflateGetHeader() again to\n   retrieve the header from the next gzip stream.\n\n     inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source\n   stream state was inconsistent.\n"
2018/06/19 20:06:59 "\nZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,\n                                        unsigned char FAR *window));\n\n     Initialize the internal stream state for decompression using inflateBack()\n   calls.  The fields zalloc, zfree and opaque in strm must be initialized\n   before the call.  If zalloc and zfree are Z_NULL, then the default library-\n   derived memory allocation routines are used.  windowBits is the base two\n   logarithm of the window size, in the range 8..15.  window is a caller\n   supplied buffer of that size.  Except for special applications where it is\n   assured that deflate was used with small window sizes, windowBits must be 15\n   and a 32K byte window must be supplied to be able to decompress general\n   deflate streams.\n\n     See inflateBack() for the usage of these routines.\n\n     inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of\n   the parameters are invalid, Z_MEM_ERROR if the internal state could not be\n   allocated, or Z_VERSION_ERROR if the version of the library does not match\n   the version of the header file.\n"
2018/06/19 20:06:59 "\n     inflateBack() does a raw inflate with a single call using a call-back\n   interface for input and output.  This is potentially more efficient than\n   inflate() for file i/o applications, in that it avoids copying between the\n   output and the sliding window by simply making the window itself the output\n   buffer.  inflate() can be faster on modern CPUs when used with large\n   buffers.  inflateBack() trusts the application to not change the output\n   buffer passed by the output function, at least until inflateBack() returns.\n\n     inflateBackInit() must be called first to allocate the internal state\n   and to initialize the state with the user-provided window buffer.\n   inflateBack() may then be used multiple times to inflate a complete, raw\n   deflate stream with each call.  inflateBackEnd() is then called to free the\n   allocated state.\n\n     A raw deflate stream is one with no zlib or gzip header or trailer.\n   This routine would normally be used in a utility that reads zip or gzip\n   files and writes out uncompressed files.  The utility would decode the\n   header and process the trailer on its own, hence this routine expects only\n   the raw deflate stream to decompress.  This is different from the default\n   behavior of inflate(), which expects a zlib header and trailer around the\n   deflate stream.\n\n     inflateBack() uses two subroutines supplied by the caller that are then\n   called by inflateBack() for input and output.  inflateBack() calls those\n   routines until it reads a complete deflate stream and writes out all of the\n   uncompressed data, or until it encounters an error.  The function's\n   parameters and return types are defined above in the in_func and out_func\n   typedefs.  inflateBack() will call in(in_desc, &buf) which should return the\n   number of bytes of provided input, and a pointer to that input in buf.  If\n   there is no input available, in() must return zero -- buf is ignored in that\n   case -- and inflateBack() will return a buffer error.  inflateBack() will\n   call out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].\n   out() should return zero on success, or non-zero on failure.  If out()\n   returns non-zero, inflateBack() will return with an error.  Neither in() nor\n   out() are permitted to change the contents of the window provided to\n   inflateBackInit(), which is also the buffer that out() uses to write from.\n   The length written by out() will be at most the window size.  Any non-zero\n   amount of input may be provided by in().\n\n     For convenience, inflateBack() can be provided input on the first call by\n   setting strm->next_in and strm->avail_in.  If that input is exhausted, then\n   in() will be called.  Therefore strm->next_in must be initialized before\n   calling inflateBack().  If strm->next_in is Z_NULL, then in() will be called\n   immediately for input.  If strm->next_in is not Z_NULL, then strm->avail_in\n   must also be initialized, and then if strm->avail_in is not zero, input will\n   initially be taken from strm->next_in[0 ..  strm->avail_in - 1].\n\n     The in_desc and out_desc parameters of inflateBack() is passed as the\n   first parameter of in() and out() respectively when they are called.  These\n   descriptors can be optionally used to pass any information that the caller-\n   supplied in() and out() functions need to do their job.\n\n     On return, inflateBack() will set strm->next_in and strm->avail_in to\n   pass back any unused input that was provided by the last in() call.  The\n   return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR\n   if in() or out() returned an error, Z_DATA_ERROR if there was a format error\n   in the deflate stream (in which case strm->msg is set to indicate the nature\n   of the error), or Z_STREAM_ERROR if the stream was not properly initialized.\n   In the case of Z_BUF_ERROR, an input or output error can be distinguished\n   using strm->next_in which will be Z_NULL only if in() returned an error.  If\n   strm->next_in is not Z_NULL, then the Z_BUF_ERROR was due to out() returning\n   non-zero.  (in() will always be called before out(), so strm->next_in is\n   assured to be defined if out() returns non-zero.)  Note that inflateBack()\n   cannot return Z_OK.\n"
2018/06/19 20:06:59 "\n     All memory allocated by inflateBackInit() is freed.\n\n     inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream\n   state was inconsistent.\n"
2018/06/19 20:06:59 " Return flags indicating compile-time options.\n\n    Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:\n     1.0: size of uInt\n     3.2: size of uLong\n     5.4: size of voidpf (pointer)\n     7.6: size of z_off_t\n\n    Compiler, assembler, and debug options:\n     8: ZLIB_DEBUG\n     9: ASMV or ASMINF -- use ASM code\n     10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention\n     11: 0 (reserved)\n\n    One-time table building (smaller code, but not thread-safe if true):\n     12: BUILDFIXED -- build static block decoding tables when needed\n     13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed\n     14,15: 0 (reserved)\n\n    Library content (indicates missing functionality):\n     16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking\n                          deflate code when not needed)\n     17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect\n                    and decode gzip streams (to avoid linking crc code)\n     18-19: 0 (reserved)\n\n    Operation variations (changes in library functionality):\n     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate\n     21: FASTEST -- deflate algorithm with only one, lowest compression level\n     22,23: 0 (reserved)\n\n    The sprintf variant used by gzprintf (zero is best):\n     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format\n     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!\n     26: 0 = returns value, 1 = void -- 1 means inferred string length returned\n\n    Remainder:\n     27-31: 0 (reserved)\n "
2018/06/19 20:06:59 " utility functions "
2018/06/19 20:06:59 "\n     The following utility functions are implemented on top of the basic\n   stream-oriented functions.  To simplify the interface, some default options\n   are assumed (compression level and memory usage, standard memory allocation\n   functions).  The source code of these utility functions can be modified if\n   you need special options.\n"
2018/06/19 20:06:59 "\n     Compresses the source buffer into the destination buffer.  sourceLen is\n   the byte length of the source buffer.  Upon entry, destLen is the total size\n   of the destination buffer, which must be at least the value returned by\n   compressBound(sourceLen).  Upon exit, destLen is the actual size of the\n   compressed data.  compress() is equivalent to compress2() with a level\n   parameter of Z_DEFAULT_COMPRESSION.\n\n     compress returns Z_OK if success, Z_MEM_ERROR if there was not\n   enough memory, Z_BUF_ERROR if there was not enough room in the output\n   buffer.\n"
2018/06/19 20:06:59 "\n     Compresses the source buffer into the destination buffer.  The level\n   parameter has the same meaning as in deflateInit.  sourceLen is the byte\n   length of the source buffer.  Upon entry, destLen is the total size of the\n   destination buffer, which must be at least the value returned by\n   compressBound(sourceLen).  Upon exit, destLen is the actual size of the\n   compressed data.\n\n     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough\n   memory, Z_BUF_ERROR if there was not enough room in the output buffer,\n   Z_STREAM_ERROR if the level parameter is invalid.\n"
2018/06/19 20:06:59 "\n     compressBound() returns an upper bound on the compressed size after\n   compress() or compress2() on sourceLen bytes.  It would be used before a\n   compress() or compress2() call to allocate the destination buffer.\n"
2018/06/19 20:06:59 "\n     Decompresses the source buffer into the destination buffer.  sourceLen is\n   the byte length of the source buffer.  Upon entry, destLen is the total size\n   of the destination buffer, which must be large enough to hold the entire\n   uncompressed data.  (The size of the uncompressed data must have been saved\n   previously by the compressor and transmitted to the decompressor by some\n   mechanism outside the scope of this compression library.) Upon exit, destLen\n   is the actual size of the uncompressed data.\n\n     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not\n   enough memory, Z_BUF_ERROR if there was not enough room in the output\n   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In\n   the case where there is not enough room, uncompress() will fill the output\n   buffer with the uncompressed data up to that point.\n"
2018/06/19 20:06:59 "\n     Same as uncompress, except that sourceLen is a pointer, where the\n   length of the source is *sourceLen.  On return, *sourceLen is the number of\n   source bytes consumed.\n"
2018/06/19 20:06:59 " gzip file access functions "
2018/06/19 20:06:59 "\n     This library supports reading and writing files in gzip (.gz) format with\n   an interface similar to that of stdio, using the functions that start with\n   \"gz\".  The gzip format is different from the zlib format.  gzip is a gzip\n   wrapper, documented in RFC 1952, wrapped around a deflate stream.\n"
2018/06/19 20:06:59 " semi-opaque gzip file descriptor "
2018/06/19 20:06:59 "\nZEXTERN gzFile ZEXPORT gzopen OF((const char *path, const char *mode));\n\n     Opens a gzip (.gz) file for reading or writing.  The mode parameter is as\n   in fopen (\"rb\" or \"wb\") but can also include a compression level (\"wb9\") or\n   a strategy: 'f' for filtered data as in \"wb6f\", 'h' for Huffman-only\n   compression as in \"wb1h\", 'R' for run-length encoding as in \"wb1R\", or 'F'\n   for fixed code compression as in \"wb9F\".  (See the description of\n   deflateInit2 for more information about the strategy parameter.)  'T' will\n   request transparent writing or appending with no compression and not using\n   the gzip format.\n\n     \"a\" can be used instead of \"w\" to request that the gzip stream that will\n   be written be appended to the file.  \"+\" will result in an error, since\n   reading and writing to the same gzip file is not supported.  The addition of\n   \"x\" when writing will create the file exclusively, which fails if the file\n   already exists.  On systems that support it, the addition of \"e\" when\n   reading or writing will set the flag to close the file on an execve() call.\n\n     These functions, as well as gzip, will read and decode a sequence of gzip\n   streams in a file.  The append function of gzopen() can be used to create\n   such a file.  (Also see gzflush() for another way to do this.)  When\n   appending, gzopen does not test whether the file begins with a gzip stream,\n   nor does it look for the end of the gzip streams to begin appending.  gzopen\n   will simply append a gzip stream to the existing file.\n\n     gzopen can be used to read a file which is not in gzip format; in this\n   case gzread will directly read from the file without decompression.  When\n   reading, this will be detected automatically by looking for the magic two-\n   byte gzip header.\n\n     gzopen returns NULL if the file could not be opened, if there was\n   insufficient memory to allocate the gzFile state, or if an invalid mode was\n   specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).\n   errno can be checked to determine if the reason gzopen failed was that the\n   file could not be opened.\n"
2018/06/19 20:06:59 "\n     gzdopen associates a gzFile with the file descriptor fd.  File descriptors\n   are obtained from calls like open, dup, creat, pipe or fileno (if the file\n   has been previously opened with fopen).  The mode parameter is as in gzopen.\n\n     The next call of gzclose on the returned gzFile will also close the file\n   descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor\n   fd.  If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,\n   mode);.  The duplicated descriptor should be saved to avoid a leak, since\n   gzdopen does not close fd if it fails.  If you are using fileno() to get the\n   file descriptor from a FILE *, then you will have to use dup() to avoid\n   double-close()ing the file descriptor.  Both gzclose() and fclose() will\n   close the associated file descriptor, so they need to have different file\n   descriptors.\n\n     gzdopen returns NULL if there was insufficient memory to allocate the\n   gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not\n   provided, or '+' was provided), or if fd is -1.  The file descriptor is not\n   used until the next gz* read, write, seek, or close operation, so gzdopen\n   will not detect if fd is invalid (unless fd is -1).\n"
2018/06/19 20:06:59 "\n     Set the internal buffer size used by this library's functions.  The\n   default buffer size is 8192 bytes.  This function must be called after\n   gzopen() or gzdopen(), and before any other calls that read or write the\n   file.  The buffer memory allocation is always deferred to the first read or\n   write.  Three times that size in buffer space is allocated.  A larger buffer\n   size of, for example, 64K or 128K bytes will noticeably increase the speed\n   of decompression (reading).\n\n     The new buffer size also affects the maximum length for gzprintf().\n\n     gzbuffer() returns 0 on success, or -1 on failure, such as being called\n   too late.\n"
2018/06/19 20:06:59 "\n     Dynamically update the compression level or strategy.  See the description\n   of deflateInit2 for the meaning of these parameters.  Previously provided\n   data is flushed before the parameter change.\n\n     gzsetparams returns Z_OK if success, Z_STREAM_ERROR if the file was not\n   opened for writing, Z_ERRNO if there is an error writing the flushed data,\n   or Z_MEM_ERROR if there is a memory allocation error.\n"
2018/06/19 20:06:59 "\n     Reads the given number of uncompressed bytes from the compressed file.  If\n   the input file is not in gzip format, gzread copies the given number of\n   bytes into the buffer directly from the file.\n\n     After reaching the end of a gzip stream in the input, gzread will continue\n   to read, looking for another gzip stream.  Any number of gzip streams may be\n   concatenated in the input file, and will all be decompressed by gzread().\n   If something other than a gzip stream is encountered after a gzip stream,\n   that remaining trailing garbage is ignored (and no error is returned).\n\n     gzread can be used to read a gzip file that is being concurrently written.\n   Upon reaching the end of the input, gzread will return with the available\n   data.  If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then\n   gzclearerr can be used to clear the end of file indicator in order to permit\n   gzread to be tried again.  Z_OK indicates that a gzip stream was completed\n   on the last gzread.  Z_BUF_ERROR indicates that the input file ended in the\n   middle of a gzip stream.  Note that gzread does not return -1 in the event\n   of an incomplete gzip stream.  This error is deferred until gzclose(), which\n   will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip\n   stream.  Alternatively, gzerror can be used before gzclose to detect this\n   case.\n\n     gzread returns the number of uncompressed bytes actually read, less than\n   len for end of file, or -1 for error.  If len is too large to fit in an int,\n   then nothing is read, -1 is returned, and the error state is set to\n   Z_STREAM_ERROR.\n"
2018/06/19 20:06:59 "\n     Read up to nitems items of size size from file to buf, otherwise operating\n   as gzread() does.  This duplicates the interface of stdio's fread(), with\n   size_t request and return types.  If the library defines size_t, then\n   z_size_t is identical to size_t.  If not, then z_size_t is an unsigned\n   integer type that can contain a pointer.\n\n     gzfread() returns the number of full items read of size size, or zero if\n   the end of the file was reached and a full item could not be read, or if\n   there was an error.  gzerror() must be consulted if zero is returned in\n   order to determine if there was an error.  If the multiplication of size and\n   nitems overflows, i.e. the product does not fit in a z_size_t, then nothing\n   is read, zero is returned, and the error state is set to Z_STREAM_ERROR.\n\n     In the event that the end of file is reached and only a partial item is\n   available at the end, i.e. the remaining uncompressed data length is not a\n   multiple of size, then the final partial item is nevetheless read into buf\n   and the end-of-file flag is set.  The length of the partial item read is not\n   provided, but could be inferred from the result of gztell().  This behavior\n   is the same as the behavior of fread() implementations in common libraries,\n   but it prevents the direct use of gzfread() to read a concurrently written\n   file, reseting and retrying on end-of-file, when size is not 1.\n"
2018/06/19 20:06:59 "\n     Writes the given number of uncompressed bytes into the compressed file.\n   gzwrite returns the number of uncompressed bytes written or 0 in case of\n   error.\n"
2018/06/19 20:06:59 "\n     gzfwrite() writes nitems items of size size from buf to file, duplicating\n   the interface of stdio's fwrite(), with size_t request and return types.  If\n   the library defines size_t, then z_size_t is identical to size_t.  If not,\n   then z_size_t is an unsigned integer type that can contain a pointer.\n\n     gzfwrite() returns the number of full items written of size size, or zero\n   if there was an error.  If the multiplication of size and nitems overflows,\n   i.e. the product does not fit in a z_size_t, then nothing is written, zero\n   is returned, and the error state is set to Z_STREAM_ERROR.\n"
2018/06/19 20:06:59 "\n     Converts, formats, and writes the arguments to the compressed file under\n   control of the format string, as in fprintf.  gzprintf returns the number of\n   uncompressed bytes actually written, or a negative zlib error code in case\n   of error.  The number of uncompressed bytes written is limited to 8191, or\n   one less than the buffer size given to gzbuffer().  The caller should assure\n   that this limit is not exceeded.  If it is exceeded, then gzprintf() will\n   return an error (0) with nothing written.  In this case, there may also be a\n   buffer overflow with unpredictable consequences, which is possible only if\n   zlib was compiled with the insecure functions sprintf() or vsprintf()\n   because the secure snprintf() or vsnprintf() functions were not available.\n   This can be determined using zlibCompileFlags().\n"
2018/06/19 20:06:59 "\n     Writes the given null-terminated string to the compressed file, excluding\n   the terminating null character.\n\n     gzputs returns the number of characters written, or -1 in case of error.\n"
2018/06/19 20:06:59 "\n     Reads bytes from the compressed file until len-1 characters are read, or a\n   newline character is read and transferred to buf, or an end-of-file\n   condition is encountered.  If any characters are read or if len == 1, the\n   string is terminated with a null character.  If no characters are read due\n   to an end-of-file or len < 1, then the buffer is left untouched.\n\n     gzgets returns buf which is a null-terminated string, or it returns NULL\n   for end-of-file or in case of error.  If there was an error, the contents at\n   buf are indeterminate.\n"
2018/06/19 20:06:59 "\n     Writes c, converted to an unsigned char, into the compressed file.  gzputc\n   returns the value that was written, or -1 in case of error.\n"
2018/06/19 20:06:59 "\n     Reads one byte from the compressed file.  gzgetc returns this byte or -1\n   in case of end of file or error.  This is implemented as a macro for speed.\n   As such, it does not do all of the checking the other functions do.  I.e.\n   it does not check to see if file is NULL, nor whether the structure file\n   points to has been clobbered or not.\n"
2018/06/19 20:06:59 "\n     Push one character back onto the stream to be read as the first character\n   on the next read.  At least one character of push-back is allowed.\n   gzungetc() returns the character pushed, or -1 on failure.  gzungetc() will\n   fail if c is -1, and may fail if a character has been pushed but not read\n   yet.  If gzungetc is used immediately after gzopen or gzdopen, at least the\n   output buffer size of pushed characters is allowed.  (See gzbuffer above.)\n   The pushed character will be discarded if the stream is repositioned with\n   gzseek() or gzrewind().\n"
2018/06/19 20:06:59 "\n     Flushes all pending output into the compressed file.  The parameter flush\n   is as in the deflate() function.  The return value is the zlib error number\n   (see function gzerror below).  gzflush is only permitted when writing.\n\n     If the flush parameter is Z_FINISH, the remaining data is written and the\n   gzip stream is completed in the output.  If gzwrite() is called again, a new\n   gzip stream will be started in the output.  gzread() is able to read such\n   concatenated gzip streams.\n\n     gzflush should be called only when strictly necessary because it will\n   degrade compression if called too often.\n"
2018/06/19 20:06:59 "\nZEXTERN z_off_t ZEXPORT gzseek OF((gzFile file,\n                                   z_off_t offset, int whence));\n\n     Sets the starting position for the next gzread or gzwrite on the given\n   compressed file.  The offset represents a number of bytes in the\n   uncompressed data stream.  The whence parameter is defined as in lseek(2);\n   the value SEEK_END is not supported.\n\n     If the file is opened for reading, this function is emulated but can be\n   extremely slow.  If the file is opened for writing, only forward seeks are\n   supported; gzseek then compresses a sequence of zeroes up to the new\n   starting position.\n\n     gzseek returns the resulting offset location as measured in bytes from\n   the beginning of the uncompressed stream, or -1 in case of error, in\n   particular if the file is opened for writing and the new starting position\n   would be before the current position.\n"
2018/06/19 20:06:59 "\n     Rewinds the given file. This function is supported only for reading.\n\n     gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)\n"
2018/06/19 20:06:59 "\nZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));\n\n     Returns the starting position for the next gzread or gzwrite on the given\n   compressed file.  This position represents a number of bytes in the\n   uncompressed data stream, and is zero when starting, even if appending or\n   reading a gzip stream from the middle of a file using gzdopen().\n\n     gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)\n"
2018/06/19 20:06:59 "\nZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile file));\n\n     Returns the current offset in the file being read or written.  This offset\n   includes the count of bytes that precede the gzip stream, for example when\n   appending or when using gzdopen() for reading.  When reading, the offset\n   does not include as yet unused buffered input.  This information can be used\n   for a progress indicator.  On error, gzoffset() returns -1.\n"
2018/06/19 20:06:59 "\n     Returns true (1) if the end-of-file indicator has been set while reading,\n   false (0) otherwise.  Note that the end-of-file indicator is set only if the\n   read tried to go past the end of the input, but came up short.  Therefore,\n   just like feof(), gzeof() may return false even if there is no more data to\n   read, in the event that the last read request was for the exact number of\n   bytes remaining in the input file.  This will happen if the input file size\n   is an exact multiple of the buffer size.\n\n     If gzeof() returns true, then the read functions will return no more data,\n   unless the end-of-file indicator is reset by gzclearerr() and the input file\n   has grown since the previous end of file was detected.\n"
2018/06/19 20:06:59 "\n     Returns true (1) if file is being copied directly while reading, or false\n   (0) if file is a gzip stream being decompressed.\n\n     If the input file is empty, gzdirect() will return true, since the input\n   does not contain a gzip stream.\n\n     If gzdirect() is used immediately after gzopen() or gzdopen() it will\n   cause buffers to be allocated to allow reading the file to determine if it\n   is a gzip file.  Therefore if gzbuffer() is used, it should be called before\n   gzdirect().\n\n     When writing, gzdirect() returns true (1) if transparent writing was\n   requested (\"wT\" for the gzopen() mode), or false (0) otherwise.  (Note:\n   gzdirect() is not needed when writing.  Transparent writing must be\n   explicitly requested, so the application already knows the answer.  When\n   linking statically, using gzdirect() will include all of the zlib code for\n   gzip file reading and decompression, which may not be desired.)\n"
2018/06/19 20:06:59 "\n     Flushes all pending output if necessary, closes the compressed file and\n   deallocates the (de)compression state.  Note that once file is closed, you\n   cannot call gzerror with file, since its structures have been deallocated.\n   gzclose must not be called more than once on the same file, just as free\n   must not be called more than once on the same allocation.\n\n     gzclose will return Z_STREAM_ERROR if file is not valid, Z_ERRNO on a\n   file operation error, Z_MEM_ERROR if out of memory, Z_BUF_ERROR if the\n   last read ended in the middle of a gzip stream, or Z_OK on success.\n"
2018/06/19 20:06:59 "\n     Same as gzclose(), but gzclose_r() is only for use when reading, and\n   gzclose_w() is only for use when writing or appending.  The advantage to\n   using these instead of gzclose() is that they avoid linking in zlib\n   compression or decompression code that is not used when only reading or only\n   writing respectively.  If gzclose() is used, then both compression and\n   decompression code will be included the application when linking to a static\n   zlib library.\n"
2018/06/19 20:06:59 "\n     Returns the error message for the last error which occurred on the given\n   compressed file.  errnum is set to zlib error number.  If an error occurred\n   in the file system and not in the compression library, errnum is set to\n   Z_ERRNO and the application may consult errno to get the exact error code.\n\n     The application must not modify the returned string.  Future calls to\n   this function may invalidate the previously returned string.  If file is\n   closed, then the string previously returned by gzerror will no longer be\n   available.\n\n     gzerror() should be used to distinguish errors from end-of-file for those\n   functions above that do not distinguish those cases in their return values.\n"
2018/06/19 20:06:59 "\n     Clears the error and end-of-file flags for file.  This is analogous to the\n   clearerr() function in stdio.  This is useful for continuing to read a gzip\n   file that is being written concurrently.\n"
2018/06/19 20:06:59 " !Z_SOLO "
2018/06/19 20:06:59 " checksum functions "
2018/06/19 20:06:59 "\n     These functions are not related to compression but are exported\n   anyway because they might be useful in applications using the compression\n   library.\n"
2018/06/19 20:06:59 "\n     Update a running Adler-32 checksum with the bytes buf[0..len-1] and\n   return the updated checksum.  If buf is Z_NULL, this function returns the\n   required initial value for the checksum.\n\n     An Adler-32 checksum is almost as reliable as a CRC-32 but can be computed\n   much faster.\n\n   Usage example:\n\n     uLong adler = adler32(0L, Z_NULL, 0);\n\n     while (read_buffer(buffer, length) != EOF) {\n       adler = adler32(adler, buffer, length);\n     }\n     if (adler != original_adler) error();\n"
2018/06/19 20:06:59 "\n     Same as adler32(), but with a size_t length.\n"
2018/06/19 20:06:59 "\nZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,\n                                          z_off_t len2));\n\n     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1\n   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for\n   each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of\n   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.  Note\n   that the z_off_t type (like off_t) is a signed integer.  If len2 is\n   negative, the result has no meaning or utility.\n"
2018/06/19 20:06:59 "\n     Update a running CRC-32 with the bytes buf[0..len-1] and return the\n   updated CRC-32.  If buf is Z_NULL, this function returns the required\n   initial value for the crc.  Pre- and post-conditioning (one's complement) is\n   performed within this function so it shouldn't be done by the application.\n\n   Usage example:\n\n     uLong crc = crc32(0L, Z_NULL, 0);\n\n     while (read_buffer(buffer, length) != EOF) {\n       crc = crc32(crc, buffer, length);\n     }\n     if (crc != original_crc) error();\n"
2018/06/19 20:06:59 "\n     Same as crc32(), but with a size_t length.\n"
2018/06/19 20:06:59 "\nZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));\n\n     Combine two CRC-32 check values into one.  For two sequences of bytes,\n   seq1 and seq2 with lengths len1 and len2, CRC-32 check values were\n   calculated for each, crc1 and crc2.  crc32_combine() returns the CRC-32\n   check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and\n   len2.\n"
2018/06/19 20:06:59 " various hacks, don't look :) "
2018/06/19 20:06:59 " deflateInit and inflateInit are macros to allow checking the zlib version\n * and the compiler's view of z_stream:\n "
2018/06/19 20:06:59 " gzgetc() macro and its supporting function and exposed data structure.  Note\n * that the real internal state is much larger than the exposed structure.\n * This abbreviated structure exposes just enough for the gzgetc() macro.  The\n * user should not mess with these exposed elements, since their names or\n * behavior could change in the future, perhaps even capriciously.  They can\n * only be used by the gzgetc() macro.  You have been warned.\n "
2018/06/19 20:06:59 " backward compatibility "
2018/06/19 20:06:59 " provide 64-bit offset functions if _LARGEFILE64_SOURCE defined, and/or\n * change the regular functions to 64 bits if _FILE_OFFSET_BITS is 64 (if\n * both are true, the application gets the *64 functions, and the regular\n * functions are changed to 64 bits) -- in case these are set on systems\n * without large file support, _LFS64_LARGEFILE must also be true\n "
2018/06/19 20:06:59 " Z_SOLO "
2018/06/19 20:06:59 " !Z_SOLO "
2018/06/19 20:06:59 " undocumented functions "
2018/06/19 20:06:59 " ZLIB_H "
2018/06/19 20:06:59 Finished Classifying License "/zlib-1.2.11.tar.gz/zlib.h": 247.633368ms
2018/06/19 20:07:00 Classifying license(s): /zlib-1.2.11.tar.gz/msdos/Makefile.dj2
2018/06/19 20:07:00 Finished Classifying License "/zlib-1.2.11.tar.gz/msdos/Makefile.dj2": 14.610314ms
2018/06/19 20:07:00 Couldn't classify license(s)
2018/06/19 20:07:01 Classifying license(s): /zlib-1.2.11.tar.gz/msdos/Makefile.bor
2018/06/19 20:07:01 Finished Classifying License "/zlib-1.2.11.tar.gz/msdos/Makefile.bor": 14.726118ms
2018/06/19 20:07:01 Couldn't classify license(s)
2018/06/19 20:07:02 Classifying license(s): /zlib-1.2.11.tar.gz/msdos/Makefile.emx
2018/06/19 20:07:02 Finished Classifying License "/zlib-1.2.11.tar.gz/msdos/Makefile.emx": 2.759031ms
2018/06/19 20:07:02 Couldn't classify license(s)
2018/06/19 20:07:03 Classifying license(s): /zlib-1.2.11.tar.gz/msdos/Makefile.tc
2018/06/19 20:07:03 Finished Classifying License "/zlib-1.2.11.tar.gz/msdos/Makefile.tc": 4.793169ms
2018/06/19 20:07:03 Couldn't classify license(s)
2018/06/19 20:07:03 Classifying license(s): /zlib-1.2.11.tar.gz/msdos/Makefile.msc
2018/06/19 20:07:03 Finished Classifying License "/zlib-1.2.11.tar.gz/msdos/Makefile.msc": 13.43153ms
2018/06/19 20:07:03 Couldn't classify license(s)
2018/06/19 20:07:04 Classifying license(s): /zlib-1.2.11.tar.gz/gzread.c
2018/06/19 20:07:04 detected language: 4
2018/06/19 20:07:04 " gzread.c -- zlib functions for reading gzip files\n * Copyright (C) 2004, 2005, 2010, 2011, 2012, 2013, 2016 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n "
2018/06/19 20:07:04 " Local functions "
2018/06/19 20:07:04 " Use read() to load a buffer -- return -1 on error, otherwise 0.  Read from\n   state->fd, and update state->eof, state->err, and state->msg as appropriate.\n   This function needs to loop on read(), since read() is not guaranteed to\n   read the number of bytes requested, depending on the type of descriptor. "
2018/06/19 20:07:04 " Load up input buffer and set eof flag if last data loaded -- return -1 on\n   error, 0 otherwise.  Note that the eof flag is set when the end of the input\n   file is reached, even though there may be unused data in the buffer.  Once\n   that data has been used, no more attempts will be made to read the file.\n   If strm->avail_in != 0, then the current data is moved to the beginning of\n   the input buffer, and then the remainder of the buffer is loaded with the\n   available data from the input file. "
2018/06/19 20:07:04 " copy what's there to the start "
2018/06/19 20:07:04 " Look for gzip header, set up for inflate or copy.  state->x.have must be 0.\n   If this is the first time in, allocate required memory.  state->how will be\n   left unchanged if there is no more input data available, will be set to COPY\n   if there is no gzip header and direct copying will be performed, or it will\n   be set to GZIP for decompression.  If direct copying, then leftover input\n   data from the input buffer will be copied to the output buffer.  In that\n   case, all further file reads will be directly to either the output buffer or\n   a user buffer.  If decompressing, the inflate state will be initialized.\n   gz_look() will return 0 on success or -1 on failure. "
2018/06/19 20:07:04 " allocate read buffers and inflate memory "
2018/06/19 20:07:04 " allocate buffers "
2018/06/19 20:07:04 " allocate inflate memory "
2018/06/19 20:07:04 " gunzip "
2018/06/19 20:07:04 " get at least the magic bytes in the input buffer "
2018/06/19 20:07:04 " look for gzip magic bytes -- if there, do gzip decoding (note: there is\n       a logical dilemma here when considering the case of a partially written\n       gzip file, to wit, if a single 31 byte is written, then we cannot tell\n       whether this is a single-byte file, or just a partially written gzip\n       file -- for here we assume that if a gzip file is being written, then\n       the header will be written in a single operation, so that reading a\n       single byte is sufficient indication that it is not a gzip file) "
2018/06/19 20:07:04 " no gzip header -- if we were decoding gzip before, then this is trailing\n       garbage.  Ignore the trailing garbage and finish. "
2018/06/19 20:07:04 " doing raw i/o, copy any leftover input to output -- this assumes that\n       the output buffer is larger than the input buffer, which also assures\n       space for gzungetc() "
2018/06/19 20:07:04 " Decompress from input to the provided next_out and avail_out in the state.\n   On return, state->x.have and state->x.next point to the just decompressed\n   data.  If the gzip stream completes, state->how is reset to LOOK to look for\n   the next gzip stream or raw data, once state->x.have is depleted.  Returns 0\n   on success, -1 on failure. "
2018/06/19 20:07:04 " fill output buffer up to end of deflate stream "
2018/06/19 20:07:04 " get more input for inflate() "
2018/06/19 20:07:04 " decompress and handle errors "
2018/06/19 20:07:04 " deflate stream invalid "
2018/06/19 20:07:04 " update available output "
2018/06/19 20:07:04 " if the gzip stream completed successfully, look for another "
2018/06/19 20:07:04 " good decompression "
2018/06/19 20:07:04 " Fetch data and put it in the output buffer.  Assumes state->x.have is 0.\n   Data is either copied from the input file or decompressed from the input\n   file depending on state->how.  If state->how is LOOK, then a gzip header is\n   looked for to determine whether to copy or decompress.  Returns -1 on error,\n   otherwise 0.  gz_fetch() will leave state->how as COPY or GZIP unless the\n   end of the input file has been reached and all data has been processed.  "
2018/06/19 20:07:04 " -> LOOK, COPY (only if never GZIP), or GZIP "
2018/06/19 20:07:04 " -> COPY "
2018/06/19 20:07:04 " -> GZIP or LOOK (if end of gzip stream) "
2018/06/19 20:07:04 " Skip len uncompressed bytes of output.  Return -1 on error, 0 on success. "
2018/06/19 20:07:04 " skip over len bytes or reach end-of-file, whichever comes first "
2018/06/19 20:07:04 " skip over whatever is in output buffer "
2018/06/19 20:07:04 " output buffer empty -- return if we're at the end of the input "
2018/06/19 20:07:04 " need more data to skip -- load up output buffer "
2018/06/19 20:07:04 " get more output, looking for header if required "
2018/06/19 20:07:04 " Read len bytes into buf from file, or less than len up to the end of the\n   input.  Return the number of bytes read.  If zero is returned, either the\n   end of file was reached, or there was an error.  state->err must be\n   consulted in that case to determine which. "
2018/06/19 20:07:04 " if len is zero, avoid unnecessary operations "
2018/06/19 20:07:04 " process a skip request "
2018/06/19 20:07:04 " get len bytes to buf, or less than len if at the end "
2018/06/19 20:07:04 " set n to the maximum amount of len that fits in an unsigned int "
2018/06/19 20:07:04 " first just try copying data from the output buffer "
2018/06/19 20:07:04 " output buffer empty -- return if we're at the end of the input "
2018/06/19 20:07:04 " tried to read past end "
2018/06/19 20:07:04 " need output data -- for small len or new stream load up our output\n           buffer "
2018/06/19 20:07:04 " get more output, looking for header if required "
2018/06/19 20:07:04 " no progress yet -- go back to copy above \n the copy above assures that we will leave with space in the\n               output buffer, allowing at least one gzungetc() to succeed "
2018/06/19 20:07:04 " large len -- read directly into user buffer \n read directly "
2018/06/19 20:07:04 " large len -- decompress directly into user buffer \n state->how == GZIP "
2018/06/19 20:07:04 " update progress "
2018/06/19 20:07:04 " return number of bytes read into user buffer "
2018/06/19 20:07:04 " -- see zlib.h -- "
2018/06/19 20:07:04 " get internal structure "
2018/06/19 20:07:04 " check that we're reading and that there's no (serious) error "
2018/06/19 20:07:04 " since an int is returned, make sure len fits in one, otherwise return\n       with an error (this avoids a flaw in the interface) "
2018/06/19 20:07:04 " read len or fewer bytes to buf "
2018/06/19 20:07:04 " check for an error "
2018/06/19 20:07:04 " return the number of bytes read (this is assured to fit in an int) "
2018/06/19 20:07:04 " -- see zlib.h -- "
2018/06/19 20:07:04 " get internal structure "
2018/06/19 20:07:04 " check that we're reading and that there's no (serious) error "
2018/06/19 20:07:04 " compute bytes to read -- error on overflow "
2018/06/19 20:07:04 " read len or fewer bytes to buf, return the number of full items read "
2018/06/19 20:07:04 " -- see zlib.h -- "
2018/06/19 20:07:04 " get internal structure "
2018/06/19 20:07:04 " check that we're reading and that there's no (serious) error "
2018/06/19 20:07:04 " try output buffer (no need to check for skip request) "
2018/06/19 20:07:04 " nothing there -- try gz_read() "
2018/06/19 20:07:04 " -- see zlib.h -- "
2018/06/19 20:07:04 " get internal structure "
2018/06/19 20:07:04 " check that we're reading and that there's no (serious) error "
2018/06/19 20:07:04 " process a skip request "
2018/06/19 20:07:04 " can't push EOF "
2018/06/19 20:07:04 " if output buffer empty, put byte at end (allows more pushing) "
2018/06/19 20:07:04 " if no room, give up (must have already done a gzungetc()) "
2018/06/19 20:07:04 " slide output data if needed and insert byte before existing data "
2018/06/19 20:07:04 " -- see zlib.h -- "
2018/06/19 20:07:04 " check parameters and get internal structure "
2018/06/19 20:07:04 " check that we're reading and that there's no (serious) error "
2018/06/19 20:07:04 " process a skip request "
2018/06/19 20:07:04 " copy output bytes up to new line or len - 1, whichever comes first --\n       append a terminating zero to the string (we don't check for a zero in\n       the contents, let the user worry about that) "
2018/06/19 20:07:04 " assure that something is in the output buffer "
2018/06/19 20:07:04 " error \n end of file \n read past end \n return what we have "
2018/06/19 20:07:04 " look for end-of-line in current output buffer "
2018/06/19 20:07:04 " copy through end-of-line, or remainder if not found "
2018/06/19 20:07:04 " return terminated string, or if nothing, end of file "
2018/06/19 20:07:04 " -- see zlib.h -- "
2018/06/19 20:07:04 " get internal structure "
2018/06/19 20:07:04 " if the state is not known, but we can find out, then do so (this is\n       mainly for right after a gzopen() or gzdopen()) "
2018/06/19 20:07:04 " return 1 if transparent, 0 if processing a gzip stream "
2018/06/19 20:07:04 " -- see zlib.h -- "
2018/06/19 20:07:04 " get internal structure "
2018/06/19 20:07:04 " check that we're reading "
2018/06/19 20:07:04 " free memory and close file "
2018/06/19 20:07:04 Finished Classifying License "/zlib-1.2.11.tar.gz/gzread.c": 18.859444ms
2018/06/19 20:07:04 Couldn't classify license(s)
2018/06/19 20:07:05 Classifying license(s): /zlib-1.2.11.tar.gz/trees.c
2018/06/19 20:07:05 detected language: 4
2018/06/19 20:07:05 " trees.c -- output deflated data using Huffman coding\n * Copyright (C) 1995-2017 Jean-loup Gailly\n * detect_data_type() function provided freely by Cosmin Truta, 2006\n * For conditions of distribution and use, see copyright notice in zlib.h\n "
2018/06/19 20:07:05 "\n *  ALGORITHM\n *\n *      The \"deflation\" process uses several Huffman trees. The more\n *      common source values are represented by shorter bit sequences.\n *\n *      Each code tree is stored in a compressed form which is itself\n * a Huffman encoding of the lengths of all the code strings (in\n * ascending order by source values).  The actual code strings are\n * reconstructed from the lengths in the inflate process, as described\n * in the deflate specification.\n *\n *  REFERENCES\n *\n *      Deutsch, L.P.,\"'Deflate' Compressed Data Format Specification\".\n *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc\n *\n *      Storer, James A.\n *          Data Compression:  Methods and Theory, pp. 49-50.\n *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.\n *\n *      Sedgewick, R.\n *          Algorithms, p290.\n *          Addison-Wesley, 1983. ISBN 0-201-06672-6.\n "
2018/06/19 20:07:05 " @(#) $Id$ "
2018/06/19 20:07:05 " #define GEN_TREES_H "
2018/06/19 20:07:05 " ===========================================================================\n * Constants\n "
2018/06/19 20:07:05 " Bit length codes must not exceed MAX_BL_BITS bits "
2018/06/19 20:07:05 " end of block literal code "
2018/06/19 20:07:05 " repeat previous bit length 3-6 times (2 bits of repeat count) "
2018/06/19 20:07:05 " repeat a zero length 3-10 times  (3 bits of repeat count) "
2018/06/19 20:07:05 " repeat a zero length 11-138 times  (7 bits of repeat count) "
2018/06/19 20:07:05 " extra bits for each length code "
2018/06/19 20:07:05 " extra bits for each distance code "
2018/06/19 20:07:05 " extra bits for each bit length code "
2018/06/19 20:07:05 " The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n "
2018/06/19 20:07:05 " ===========================================================================\n * Local data. These are initialized only once.\n "
2018/06/19 20:07:05 " see definition of array dist_code below "
2018/06/19 20:07:05 " non ANSI compilers may not accept trees.h "
2018/06/19 20:07:05 " The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n "
2018/06/19 20:07:05 " The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n "
2018/06/19 20:07:05 " Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n "
2018/06/19 20:07:05 " length code for each normalized match length (0 == MIN_MATCH) "
2018/06/19 20:07:05 " First normalized length for each code (0 = MIN_MATCH) "
2018/06/19 20:07:05 " First normalized distance for each code (0 = distance of 1) "
2018/06/19 20:07:05 " GEN_TREES_H "
2018/06/19 20:07:05 " static tree or NULL \n extra bits for each code or NULL \n base index for extra_bits \n max number of elements in the tree \n max bit length for the codes "
2018/06/19 20:07:05 " ===========================================================================\n * Local (static) routines in this file.\n "
2018/06/19 20:07:05 " Send a code of the given tree. c and tree must not have side effects "
2018/06/19 20:07:05 " !ZLIB_DEBUG "
2018/06/19 20:07:05 " ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n "
2018/06/19 20:07:05 " ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n "
2018/06/19 20:07:05 " value to send \n number of bits "
2018/06/19 20:07:05 " If not enough room in bi_buf, use (valid) bits from bi_buf and\n     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))\n     * unused bits in value.\n     "
2018/06/19 20:07:05 " !ZLIB_DEBUG "
2018/06/19 20:07:05 " ZLIB_DEBUG "
2018/06/19 20:07:05 " the arguments must not have side effects "
2018/06/19 20:07:05 " ===========================================================================\n * Initialize the various 'constant' tables.\n "
2018/06/19 20:07:05 " iterates over tree elements \n bit counter \n length value \n code value \n distance index "
2018/06/19 20:07:05 " number of codes at each bit length for an optimal tree "
2018/06/19 20:07:05 " For some embedded targets, global variables are not initialized: "
2018/06/19 20:07:05 " Initialize the mapping length (0..255) -> length code (0..28) "
2018/06/19 20:07:05 " Note that the length 255 (match length 258) can be represented\n     * in two different ways: code 284 + 5 bits or code 285, so we\n     * overwrite length_code[255] to use the best encoding:\n     "
2018/06/19 20:07:05 " Initialize the mapping dist (0..32K) -> dist code (0..29) "
2018/06/19 20:07:05 " from now on, all distances are divided by 128 "
2018/06/19 20:07:05 " Construct the codes of the static literal tree "
2018/06/19 20:07:05 " Codes 286 and 287 do not exist, but we must include them in the\n     * tree construction to get a canonical Huffman tree (longest code\n     * all ones)\n     "
2018/06/19 20:07:05 " The static distance tree is trivial: "
2018/06/19 20:07:05 " defined(GEN_TREES_H) || !defined(STDC) "
2018/06/19 20:07:05 " ===========================================================================\n * Genererate the file trees.h describing the static trees.\n "
2018/06/19 20:07:05 " GEN_TREES_H "
2018/06/19 20:07:05 " ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n "
2018/06/19 20:07:05 " Initialize the first block of the first file: "
2018/06/19 20:07:05 " ===========================================================================\n * Initialize a new block.\n "
2018/06/19 20:07:05 " iterates over tree elements "
2018/06/19 20:07:05 " Initialize the trees. "
2018/06/19 20:07:05 " Index within the heap array of least frequent node in the Huffman tree "
2018/06/19 20:07:05 " ===========================================================================\n * Remove the smallest element from the heap and recreate the heap with\n * one less element. Updates heap and heap_len.\n "
2018/06/19 20:07:05 " ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n "
2018/06/19 20:07:05 " ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n "
2018/06/19 20:07:05 " the tree to restore \n node to move down "
2018/06/19 20:07:05 " left son of k "
2018/06/19 20:07:05 " Set j to the smallest of the two sons: "
2018/06/19 20:07:05 " Exit if v is smaller than both sons "
2018/06/19 20:07:05 " Exchange v with the smallest son "
2018/06/19 20:07:05 " And continue down the tree, setting j to the left son of k "
2018/06/19 20:07:05 " ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n "
2018/06/19 20:07:05 " the tree descriptor "
2018/06/19 20:07:05 " heap index \n iterate over the tree elements \n bit length \n extra bits \n frequency \n number of elements with bit length too large "
2018/06/19 20:07:05 " In a first pass, compute the optimal bit lengths (which may\n     * overflow in the case of the bit length tree).\n     "
2018/06/19 20:07:05 " root of the heap "
2018/06/19 20:07:05 " We overwrite tree[n].Dad which is no longer needed "
2018/06/19 20:07:05 " not a leaf node "
2018/06/19 20:07:05 " This happens for example on obj2 and pic of the Calgary corpus "
2018/06/19 20:07:05 " Find the first bit length which could increase: "
2018/06/19 20:07:05 " move one leaf down the tree \n move one overflow item as its brother "
2018/06/19 20:07:05 " The brother of the overflow item also moves one step up,\n         * but this does not affect bl_count[max_length]\n         "
2018/06/19 20:07:05 " Now recompute all bit lengths, scanning in increasing frequency.\n     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n     * lengths instead of fixing only the wrong ones. This idea is taken\n     * from 'ar' written by Haruhiko Okumura.)\n     "
2018/06/19 20:07:05 " ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n "
2018/06/19 20:07:05 " the tree to decorate \n largest code with non zero frequency \n number of codes at each bit length "
2018/06/19 20:07:05 " next code value for each bit length \n running code value \n bit index \n code index "
2018/06/19 20:07:05 " The distribution counts are first used to generate the code values\n     * without bit reversal.\n     "
2018/06/19 20:07:05 " Check that the bit counts in bl_count are consistent. The last code\n     * must be all ones.\n     "
2018/06/19 20:07:05 " Now reverse the bits "
2018/06/19 20:07:05 " ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n "
2018/06/19 20:07:05 " the tree descriptor "
2018/06/19 20:07:05 " iterate over heap elements \n largest code with non zero frequency \n new node being created "
2018/06/19 20:07:05 " Construct the initial heap, with least frequent element in\n     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n     * heap[0] is not used.\n     "
2018/06/19 20:07:05 " The pkzip format requires that at least one distance code exists,\n     * and that at least one bit should be sent even if there is only one\n     * possible code. So to avoid special checks later on we force at least\n     * two codes of non zero frequency.\n     "
2018/06/19 20:07:05 " node is 0 or 1 so it does not have extra bits "
2018/06/19 20:07:05 " The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n     * establish sub-heaps of increasing lengths:\n     "
2018/06/19 20:07:05 " Construct the Huffman tree by repeatedly combining the least two\n     * frequent nodes.\n     "
2018/06/19 20:07:05 " next internal node of the tree "
2018/06/19 20:07:05 " n = node of least frequency \n m = node of next least frequency "
2018/06/19 20:07:05 " keep the nodes sorted by frequency "
2018/06/19 20:07:05 " Create a new node father of n and m "
2018/06/19 20:07:05 " and insert the new node in the heap "
2018/06/19 20:07:05 " At this point, the fields freq and dad are set. We can now\n     * generate the bit lengths.\n     "
2018/06/19 20:07:05 " The field len is now set, we can generate the bit codes "
2018/06/19 20:07:05 " ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n "
2018/06/19 20:07:05 " the tree to be scanned \n and its largest code of non zero frequency "
2018/06/19 20:07:05 " iterates over all tree elements \n last emitted length \n length of current code \n length of next code \n repeat count of the current code \n max repeat count \n min repeat count "
2018/06/19 20:07:05 " guard "
2018/06/19 20:07:05 " ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n "
2018/06/19 20:07:05 " the tree to be scanned \n and its largest code of non zero frequency "
2018/06/19 20:07:05 " iterates over all tree elements \n last emitted length \n length of current code \n length of next code \n repeat count of the current code \n max repeat count \n min repeat count "
2018/06/19 20:07:05 " tree[max_code+1].Len = -1; \n guard already set "
2018/06/19 20:07:05 " ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n "
2018/06/19 20:07:05 " index of last bit length code of non zero freq "
2018/06/19 20:07:05 " Determine the bit length frequencies for literal and distance trees "
2018/06/19 20:07:05 " Build the bit length tree: "
2018/06/19 20:07:05 " opt_len now includes the length of the tree representations, except\n     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n     "
2018/06/19 20:07:05 " Determine the number of bit length codes to send. The pkzip format\n     * requires that at least 4 bit length codes be sent. (appnote.txt says\n     * 3 but the actual value used is 4.)\n     "
2018/06/19 20:07:05 " Update opt_len to include the bit length tree and counts "
2018/06/19 20:07:05 " ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n "
2018/06/19 20:07:05 " number of codes for each tree "
2018/06/19 20:07:05 " index in bl_order "
2018/06/19 20:07:05 " not +255 as stated in appnote.txt "
2018/06/19 20:07:05 " not -3 as stated in appnote.txt "
2018/06/19 20:07:05 " literal tree "
2018/06/19 20:07:05 " distance tree "
2018/06/19 20:07:05 " ===========================================================================\n * Send a stored block\n "
2018/06/19 20:07:05 " input block \n length of input block \n one if this is the last block for a file "
2018/06/19 20:07:05 " send block type \n align on byte boundary "
2018/06/19 20:07:05 " ===========================================================================\n * Flush the bits in the bit buffer to pending output (leaves at most 7 bits)\n "
2018/06/19 20:07:05 " ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n "
2018/06/19 20:07:05 " 3 for block type, 7 for EOB "
2018/06/19 20:07:05 " ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and write out the encoded block.\n "
2018/06/19 20:07:05 " input block, or NULL if too old \n length of input block \n one if this is the last block for a file "
2018/06/19 20:07:05 " opt_len and static_len in bytes \n index of last bit length code of non zero freq "
2018/06/19 20:07:05 " Build the Huffman trees unless a stored block is forced "
2018/06/19 20:07:05 " Check if the file is binary or text "
2018/06/19 20:07:05 " Construct the literal and distance trees "
2018/06/19 20:07:05 " At this point, opt_len and static_len are the total bit lengths of\n         * the compressed block data, excluding the tree representations.\n         "
2018/06/19 20:07:05 " Build the bit length tree for the above two trees, and get the index\n         * in bl_order of the last bit length code to send.\n         "
2018/06/19 20:07:05 " Determine the best encoding. Compute the block lengths in bytes. "
2018/06/19 20:07:05 " force a stored block "
2018/06/19 20:07:05 " force stored block "
2018/06/19 20:07:05 " 4: two words for the lengths "
2018/06/19 20:07:05 " The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n         * Otherwise we can't have processed more than WSIZE input bytes since\n         * the last block flush, because compression would have been\n         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n         * transform a block into a stored block.\n         "
2018/06/19 20:07:05 " force static trees "
2018/06/19 20:07:05 " The above check is made mod 2^32, for files larger than 512 MB\n     * and uLong implemented on 32 bits.\n     "
2018/06/19 20:07:05 " align on byte boundary "
2018/06/19 20:07:05 " ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n "
2018/06/19 20:07:05 " distance of matched string \n match length-MIN_MATCH or unmatched char (if dist==0) "
2018/06/19 20:07:05 " lc is the unmatched char "
2018/06/19 20:07:05 " Here, lc is the match length - MIN_MATCH \n dist = match distance - 1 "
2018/06/19 20:07:05 " Try to guess if it is profitable to stop the current block here "
2018/06/19 20:07:05 " Compute an upper bound for the compressed length "
2018/06/19 20:07:05 " We avoid equality with lit_bufsize because of wraparound at 64K\n     * on 16 bit machines and because stored blocks are restricted to\n     * 64K-1 bytes.\n     "
2018/06/19 20:07:05 " ===========================================================================\n * Send the block data compressed using the given Huffman trees\n "
2018/06/19 20:07:05 " literal tree \n distance tree "
2018/06/19 20:07:05 " distance of matched string \n match length or unmatched char (if dist == 0) \n running index in l_buf \n the code to send \n number of extra bits to send "
2018/06/19 20:07:05 " send a literal byte "
2018/06/19 20:07:05 " Here, lc is the match length - MIN_MATCH "
2018/06/19 20:07:05 " send the length code "
2018/06/19 20:07:05 " send the extra length bits "
2018/06/19 20:07:05 " dist is now the match distance - 1 "
2018/06/19 20:07:05 " send the distance code "
2018/06/19 20:07:05 " send the extra distance bits "
2018/06/19 20:07:05 " literal or match pair ? "
2018/06/19 20:07:05 " Check that the overlay between pending_buf and d_buf+l_buf is ok: "
2018/06/19 20:07:05 " ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n "
2018/06/19 20:07:05 " black_mask is the bit mask of black-listed bytes\n     * set bits 0..6, 14..25, and 28..31\n     * 0xf3ffc07f = binary 11110011111111111100000001111111\n     "
2018/06/19 20:07:05 " Check for non-textual (\"black-listed\") bytes. "
2018/06/19 20:07:05 " Check for textual (\"white-listed\") bytes. "
2018/06/19 20:07:05 " There are no \"black-listed\" or \"white-listed\" bytes:\n     * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n     "
2018/06/19 20:07:05 " ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n "
2018/06/19 20:07:05 " the value to invert \n its bit length "
2018/06/19 20:07:05 " ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n "
2018/06/19 20:07:05 " ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n "
2018/06/19 20:07:05 Finished Classifying License "/zlib-1.2.11.tar.gz/trees.c": 110.155692ms
2018/06/19 20:07:05 Couldn't classify license(s)
2018/06/19 20:07:06 Classifying license(s): /zlib-1.2.11.tar.gz/zutil.h
2018/06/19 20:07:06 detected language: 4
2018/06/19 20:07:06 " zutil.h -- internal interface and configuration of the compression library\n * Copyright (C) 1995-2016 Jean-loup Gailly, Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n "
2018/06/19 20:07:06 " WARNING: this file should *not* be used by applications. It is\n   part of the implementation of the compression library and is\n   subject to change. Applications should only use zlib.h.\n "
2018/06/19 20:07:06 " @(#) $Id$ "
2018/06/19 20:07:06 " guess -- will be caught if guess is wrong "
2018/06/19 20:07:06 " since \"static\" is used to mean two completely different things in C, we\n   define \"local\" for the non-static meaning of \"static\", for readability\n   (compile with -Dlocal if your debugger can't find static symbols) "
2018/06/19 20:07:06 " indexed by 2-zlib_error \n (size given to avoid silly warnings with Visual C++) "
2018/06/19 20:07:06 " To be used only when the state is known to be valid "
2018/06/19 20:07:06 " common constants "
2018/06/19 20:07:06 " default windowBits for decompression. MAX_WBITS is for compression only "
2018/06/19 20:07:06 " default memLevel "
2018/06/19 20:07:06 " The three kinds of block type "
2018/06/19 20:07:06 " The minimum and maximum match lengths "
2018/06/19 20:07:06 " preset dictionary flag in zlib header "
2018/06/19 20:07:06 " target dependencies "
2018/06/19 20:07:06 " Allow compilation with ANSI keywords only enabled "
2018/06/19 20:07:06 " MSC or DJGPP "
2018/06/19 20:07:06 " for fdopen "
2018/06/19 20:07:06 " No fdopen() "
2018/06/19 20:07:06 " No fdopen() "
2018/06/19 20:07:06 " No fdopen() "
2018/06/19 20:07:06 " provide prototypes for these when building zlib without LFS "
2018/06/19 20:07:06 " common defaults "
2018/06/19 20:07:06 " assume Unix "
2018/06/19 20:07:06 " functions "
2018/06/19 20:07:06 " Use our own functions for small and medium model with MSC <= 5.0.\n  * You may have to use the same strategy for Borland C (untested).\n  * The __SC__ check is for Symantec.\n  "
2018/06/19 20:07:06 " MSDOS small or medium model "
2018/06/19 20:07:06 " Diagnostic functions "
2018/06/19 20:07:06 " Reverse the bytes in a 32-bit value "
2018/06/19 20:07:06 " ZUTIL_H "
2018/06/19 20:07:06 Finished Classifying License "/zlib-1.2.11.tar.gz/zutil.h": 5.132087ms
2018/06/19 20:07:06 Couldn't classify license(s)
2018/06/19 20:07:07 Classifying license(s): /zlib-1.2.11.tar.gz/infback.c
2018/06/19 20:07:07 detected language: 4
2018/06/19 20:07:07 " infback.c -- inflate using a call-back interface\n * Copyright (C) 1995-2016 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n "
2018/06/19 20:07:07 "\n   This code is largely copied from inflate.c.  Normally either infback.o or\n   inflate.o would be linked into an application--not both.  The interface\n   with inffast.c is retained so that optimized assembler-coded versions of\n   inflate_fast() can be used with either inflate.c or infback.c.\n "
2018/06/19 20:07:07 " function prototypes "
2018/06/19 20:07:07 "\n   strm provides memory allocation functions in zalloc and zfree, or\n   Z_NULL to use the library memory allocation functions.\n\n   windowBits is in the range 8..15, and window is a user-supplied\n   window and output buffer that is 2**windowBits bytes.\n "
2018/06/19 20:07:07 " in case we return an error "
2018/06/19 20:07:07 "\n   Return state with length and distance decoding tables and index sizes set to\n   fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n   If BUILDFIXED is defined, then instead this routine builds the tables the\n   first time it's called, and returns those tables the first time and\n   thereafter.  This reduces the size of the code by about 2K bytes, in\n   exchange for a little execution time.  However, BUILDFIXED should not be\n   used for threaded applications, since the rewriting of the tables and virgin\n   may not be thread-safe.\n "
2018/06/19 20:07:07 " build fixed huffman tables if first call (may not be thread safe) "
2018/06/19 20:07:07 " literal/length table "
2018/06/19 20:07:07 " distance table "
2018/06/19 20:07:07 " do this just once "
2018/06/19 20:07:07 " !BUILDFIXED "
2018/06/19 20:07:07 " BUILDFIXED "
2018/06/19 20:07:07 " Macros for inflateBack(): "
2018/06/19 20:07:07 " Load returned state from inflate_fast() "
2018/06/19 20:07:07 " Set state from registers for inflate_fast() "
2018/06/19 20:07:07 " Clear the input bit accumulator "
2018/06/19 20:07:07 " Assure that some input is available.  If input is requested, but denied,\n   then return a Z_BUF_ERROR from inflateBack(). "
2018/06/19 20:07:07 " Get a byte of input into the bit accumulator, or return from inflateBack()\n   with an error if there is no input available. "
2018/06/19 20:07:07 " Assure that there are at least n bits in the bit accumulator.  If there is\n   not enough available input to do that, then return from inflateBack() with\n   an error. "
2018/06/19 20:07:07 " Return the low n bits of the bit accumulator (n < 16) "
2018/06/19 20:07:07 " Remove n bits from the bit accumulator "
2018/06/19 20:07:07 " Remove zero to seven bits as needed to go to a byte boundary "
2018/06/19 20:07:07 " Assure that some output space is available, by writing out the window\n   if it's full.  If the write fails, return from inflateBack() with a\n   Z_BUF_ERROR. "
2018/06/19 20:07:07 "\n   strm provides the memory allocation functions and window buffer on input,\n   and provides information on the unused input on return.  For Z_DATA_ERROR\n   returns, strm will also provide an error message.\n\n   in() and out() are the call-back input and output functions.  When\n   inflateBack() needs more input, it calls in().  When inflateBack() has\n   filled the window with output, or when it completes with data in the\n   window, it calls out() to write out the data.  The application must not\n   change the provided input until in() is called again or inflateBack()\n   returns.  The application must not change the window/output buffer until\n   inflateBack() returns.\n\n   in() and out() are called with a descriptor parameter provided in the\n   inflateBack() call.  This parameter can be a structure that provides the\n   information required to do the read or write, as well as accumulated\n   information on the input and output such as totals and check values.\n\n   in() should return zero on failure.  out() should return non-zero on\n   failure.  If either in() or out() fails, than inflateBack() returns a\n   Z_BUF_ERROR.  strm->next_in can be checked for Z_NULL to see whether it\n   was in() or out() that caused in the error.  Otherwise,  inflateBack()\n   returns Z_STREAM_END on success, Z_DATA_ERROR for an deflate format\n   error, or Z_MEM_ERROR if it could not allocate memory for the state.\n   inflateBack() can also return Z_STREAM_ERROR if the input parameters\n   are not correct, i.e. strm is Z_NULL or the state was not initialized.\n "
2018/06/19 20:07:07 " next input \n next output \n available input and output \n bit buffer \n bits in bit buffer \n number of stored or match bytes to copy \n where to copy match bytes from \n current decoding table entry \n parent table entry \n length to copy for repeats, bits to drop \n return code \n permutation of code lengths "
2018/06/19 20:07:07 " Check that the strm exists and that the state was initialized "
2018/06/19 20:07:07 " Reset the state "
2018/06/19 20:07:07 " Inflate until end of block marked as last "
2018/06/19 20:07:07 " determine and dispatch block type "
2018/06/19 20:07:07 " stored block "
2018/06/19 20:07:07 " fixed block "
2018/06/19 20:07:07 " decode codes "
2018/06/19 20:07:07 " dynamic block "
2018/06/19 20:07:07 " get and verify stored block length \n go to byte boundary "
2018/06/19 20:07:07 " copy stored block from input to output "
2018/06/19 20:07:07 " get dynamic table entries descriptor "
2018/06/19 20:07:07 " get code length code lengths (not a typo) "
2018/06/19 20:07:07 " get length and distance code code lengths "
2018/06/19 20:07:07 " handle error breaks in while "
2018/06/19 20:07:07 " check for end-of-block code (better have one) "
2018/06/19 20:07:07 " build code tables -- note: do not change the lenbits or distbits\n               values here (9 and 6) without reading the comments in inftrees.h\n               concerning the ENOUGH constants, which depend on those values "
2018/06/19 20:07:07 " use inflate_fast() if we have enough input and output "
2018/06/19 20:07:07 " get a literal, length, or end-of-block code "
2018/06/19 20:07:07 " process literal "
2018/06/19 20:07:07 " process end of block "
2018/06/19 20:07:07 " invalid code "
2018/06/19 20:07:07 " length code -- get extra bits, if any "
2018/06/19 20:07:07 " get distance code "
2018/06/19 20:07:07 " get distance extra bits, if any "
2018/06/19 20:07:07 " copy match from window to output "
2018/06/19 20:07:07 " inflate stream terminated properly -- write leftover output "
2018/06/19 20:07:07 " can't happen, but makes compilers happy "
2018/06/19 20:07:07 " Return unused input "
2018/06/19 20:07:07 Finished Classifying License "/zlib-1.2.11.tar.gz/infback.c": 35.787152ms
2018/06/19 20:07:07 Couldn't classify license(s)
2018/06/19 20:07:07 Classifying license(s): /zlib-1.2.11.tar.gz/zlib.3
2018/06/19 20:07:07 Finished Classifying License "/zlib-1.2.11.tar.gz/zlib.3": 18.492432ms
2018/06/19 20:07:08 Classifying license(s): /zlib-1.2.11.tar.gz/gzwrite.c
2018/06/19 20:07:08 detected language: 4
2018/06/19 20:07:08 " gzwrite.c -- zlib functions for writing gzip files\n * Copyright (C) 2004-2017 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n "
2018/06/19 20:07:08 " Local functions "
2018/06/19 20:07:08 " Initialize state for writing a gzip file.  Mark initialization by setting\n   state->size to non-zero.  Return -1 on a memory allocation failure, or 0 on\n   success. "
2018/06/19 20:07:08 " allocate input buffer (double size for gzprintf) "
2018/06/19 20:07:08 " only need output buffer and deflate state if compressing "
2018/06/19 20:07:08 " allocate output buffer "
2018/06/19 20:07:08 " allocate deflate memory, set up for gzip compression "
2018/06/19 20:07:08 " mark state as initialized "
2018/06/19 20:07:08 " initialize write buffer if compressing "
2018/06/19 20:07:08 " Compress whatever is at avail_in and next_in and write to the output file.\n   Return -1 if there is an error writing to the output file or if gz_init()\n   fails to allocate memory, otherwise 0.  flush is assumed to be a valid\n   deflate() flush value.  If flush is Z_FINISH, then the deflate() state is\n   reset to start a new gzip stream.  If gz->direct is true, then simply write\n   to the output file without compressing, and ignore flush. "
2018/06/19 20:07:08 " allocate memory if this is the first time through "
2018/06/19 20:07:08 " write directly if requested "
2018/06/19 20:07:08 " run deflate() on provided input until it produces no more output "
2018/06/19 20:07:08 " write out current buffer contents if full, or if flushing, but if\n           doing Z_FINISH then don't write until we get to Z_STREAM_END "
2018/06/19 20:07:08 " compress "
2018/06/19 20:07:08 " if that completed a deflate stream, allow another to start "
2018/06/19 20:07:08 " all done, no errors "
2018/06/19 20:07:08 " Compress len zeros to output.  Return -1 on a write error or memory\n   allocation failure by gz_comp(), or 0 on success. "
2018/06/19 20:07:08 " consume whatever's left in the input buffer "
2018/06/19 20:07:08 " compress len zeros (len guaranteed > 0) "
2018/06/19 20:07:08 " Write len bytes from buf to file.  Return the number of bytes written.  If\n   the returned value is less than len, then there was an error. "
2018/06/19 20:07:08 " if len is zero, avoid unnecessary operations "
2018/06/19 20:07:08 " allocate memory if this is the first time through "
2018/06/19 20:07:08 " check for seek request "
2018/06/19 20:07:08 " for small len, copy to input buffer, otherwise compress directly "
2018/06/19 20:07:08 " copy to input buffer, compress when full "
2018/06/19 20:07:08 " consume whatever's left in the input buffer "
2018/06/19 20:07:08 " directly compress user buffer to file "
2018/06/19 20:07:08 " input was all buffered or compressed "
2018/06/19 20:07:08 " -- see zlib.h -- "
2018/06/19 20:07:08 " get internal structure "
2018/06/19 20:07:08 " check that we're writing and that there's no error "
2018/06/19 20:07:08 " since an int is returned, make sure len fits in one, otherwise return\n       with an error (this avoids a flaw in the interface) "
2018/06/19 20:07:08 " write len bytes from buf (the return value will fit in an int) "
2018/06/19 20:07:08 " -- see zlib.h -- "
2018/06/19 20:07:08 " get internal structure "
2018/06/19 20:07:08 " check that we're writing and that there's no error "
2018/06/19 20:07:08 " compute bytes to read -- error on overflow "
2018/06/19 20:07:08 " write len bytes to buf, return the number of full items written "
2018/06/19 20:07:08 " -- see zlib.h -- "
2018/06/19 20:07:08 " get internal structure "
2018/06/19 20:07:08 " check that we're writing and that there's no error "
2018/06/19 20:07:08 " check for seek request "
2018/06/19 20:07:08 " try writing to input buffer for speed (state->size == 0 if buffer not\n       initialized) "
2018/06/19 20:07:08 " no room in buffer or not initialized, use gz_write() "
2018/06/19 20:07:08 " -- see zlib.h -- "
2018/06/19 20:07:08 " get internal structure "
2018/06/19 20:07:08 " check that we're writing and that there's no error "
2018/06/19 20:07:08 " write string "
2018/06/19 20:07:08 " -- see zlib.h -- "
2018/06/19 20:07:08 " get internal structure "
2018/06/19 20:07:08 " check that we're writing and that there's no error "
2018/06/19 20:07:08 " make sure we have some buffer space "
2018/06/19 20:07:08 " check for seek request "
2018/06/19 20:07:08 " do the printf() into the input buffer, put length in len -- the input\n       buffer is double-sized just for this function, so there is guaranteed to\n       be state->size bytes available after the current contents "
2018/06/19 20:07:08 " check that printf() results fit in buffer "
2018/06/19 20:07:08 " update buffer and position, compress first half if past that "
2018/06/19 20:07:08 " !STDC && !Z_HAVE_STDARG_H "
2018/06/19 20:07:08 " -- see zlib.h -- "
2018/06/19 20:07:08 " get internal structure "
2018/06/19 20:07:08 " check that can really pass pointer in ints "
2018/06/19 20:07:08 " check that we're writing and that there's no error "
2018/06/19 20:07:08 " make sure we have some buffer space "
2018/06/19 20:07:08 " check for seek request "
2018/06/19 20:07:08 " do the printf() into the input buffer, put length in len -- the input\n       buffer is double-sized just for this function, so there is guaranteed to\n       be state->size bytes available after the current contents "
2018/06/19 20:07:08 " check that printf() results fit in buffer "
2018/06/19 20:07:08 " update buffer and position, compress first half if past that "
2018/06/19 20:07:08 " -- see zlib.h -- "
2018/06/19 20:07:08 " get internal structure "
2018/06/19 20:07:08 " check that we're writing and that there's no error "
2018/06/19 20:07:08 " check flush parameter "
2018/06/19 20:07:08 " check for seek request "
2018/06/19 20:07:08 " compress remaining data with requested flush "
2018/06/19 20:07:08 " -- see zlib.h -- "
2018/06/19 20:07:08 " get internal structure "
2018/06/19 20:07:08 " check that we're writing and that there's no error "
2018/06/19 20:07:08 " if no change is requested, then do nothing "
2018/06/19 20:07:08 " check for seek request "
2018/06/19 20:07:08 " change compression parameters for subsequent input "
2018/06/19 20:07:08 " flush previous input with previous parameters before changing "
2018/06/19 20:07:08 " -- see zlib.h -- "
2018/06/19 20:07:08 " get internal structure "
2018/06/19 20:07:08 " check that we're writing "
2018/06/19 20:07:08 " check for seek request "
2018/06/19 20:07:08 " flush, free memory, and close file "
2018/06/19 20:07:08 Finished Classifying License "/zlib-1.2.11.tar.gz/gzwrite.c": 12.61891ms
2018/06/19 20:07:08 Couldn't classify license(s)
2018/06/19 20:07:09 Classifying license(s): /zlib-1.2.11.tar.gz/zconf.h
2018/06/19 20:07:09 detected language: 4
2018/06/19 20:07:09 " zconf.h -- configuration of the zlib compression library\n * Copyright (C) 1995-2016 Jean-loup Gailly, Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n "
2018/06/19 20:07:09 " @(#) $Id$ "
2018/06/19 20:07:09 "\n * If you *really* need a unique prefix for all types and library functions,\n * compile with -DZ_PREFIX. The \"standard\" zlib should be compiled without it.\n * Even better than compiling with -DZ_PREFIX would be to use configure to set\n * this permanently in zconf.h using \"./configure --zprefix\".\n "
2018/06/19 20:07:09 " may be set to #if 1 by ./configure "
2018/06/19 20:07:09 " all linked symbols and init macros "
2018/06/19 20:07:09 " all zlib typedefs in zlib.h and zconf.h "
2018/06/19 20:07:09 " all zlib structs in zlib.h and zconf.h "
2018/06/19 20:07:09 "\n * Compile with -DMAXSEG_64K if the alloc function cannot allocate more\n * than 64k bytes at a time (needed on systems with 16-bit int).\n "
2018/06/19 20:07:09 " iSeries (formerly AS/400). "
2018/06/19 20:07:09 " cannot use !defined(STDC) && !defined(const) on Mac \n note: need a more gentle solution here "
2018/06/19 20:07:09 " Maximum value for memLevel in deflateInit2 "
2018/06/19 20:07:09 " Maximum value for windowBits in deflateInit2 and inflateInit2.\n * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files\n * created by gzip. (Files created by minigzip can still be extracted by\n * gzip.)\n "
2018/06/19 20:07:09 " 32K LZ77 window "
2018/06/19 20:07:09 " The memory requirements for deflate are (in bytes):\n            (1 << (windowBits+2)) +  (1 << (memLevel+9))\n that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)\n plus a few kilobytes for small objects. For example, if you want to reduce\n the default memory requirements from 256K to 128K, compile with\n     make CFLAGS=\"-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7\"\n Of course this will generally degrade compression (there's no free lunch).\n\n   The memory requirements for inflate are (in bytes) 1 << windowBits\n that is, 32K for windowBits=15 (default value) plus about 7 kilobytes\n for small objects.\n"
2018/06/19 20:07:09 " Type declarations "
2018/06/19 20:07:09 " function prototypes "
2018/06/19 20:07:09 " function prototypes for stdarg "
2018/06/19 20:07:09 " The following definitions for FAR are needed only for MSDOS mixed\n * model programming (small or medium model with some far allocations).\n * This was tested only with MSC; for other MSDOS compilers you may have\n * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,\n * just define FAR to be empty.\n "
2018/06/19 20:07:09 " MSC small or medium model "
2018/06/19 20:07:09 " Turbo C small or medium model "
2018/06/19 20:07:09 " If building or using zlib as a DLL, define ZLIB_DLL.\n    * This is not mandatory, but it offers a little performance increase.\n    "
2018/06/19 20:07:09 " ZLIB_DLL \n If building or using zlib with the WINAPI/WINAPIV calling convention,\n    * define ZLIB_WINAPI.\n    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.\n    "
2018/06/19 20:07:09 " No need for _export, use ZLIB.DEF instead. \n For complete Windows compatibility, use WINAPI, not __stdcall. "
2018/06/19 20:07:09 " 8 bits "
2018/06/19 20:07:09 " 16 bits or more \n 32 bits or more "
2018/06/19 20:07:09 " Borland C/C++ and some old MSC versions ignore FAR inside typedef "
2018/06/19 20:07:09 " may be set to #if 1 by ./configure "
2018/06/19 20:07:09 " may be set to #if 1 by ./configure "
2018/06/19 20:07:09 " for off_t "
2018/06/19 20:07:09 " for va_list "
2018/06/19 20:07:09 " for wchar_t "
2018/06/19 20:07:09 " a little trick to accommodate both \"#define _LARGEFILE64_SOURCE\" and\n * \"#define _LARGEFILE64_SOURCE 1\" as requesting 64-bit operations, (even\n * though the former does not conform to the LFS document), but considering\n * both \"#undef _LARGEFILE64_SOURCE\" and \"#define _LARGEFILE64_SOURCE 0\" as\n * equivalently requesting no 64-bit operations\n "
2018/06/19 20:07:09 " for SEEK_*, off_t, and _LFS64_LARGEFILE "
2018/06/19 20:07:09 " for off_t "
2018/06/19 20:07:09 " Seek from beginning of file.  \n Seek from current position.  \n Set file pointer to EOF plus \"offset\" "
2018/06/19 20:07:09 " MVS linker does not support external names larger than 8 bytes "
2018/06/19 20:07:09 " ZCONF_H "
2018/06/19 20:07:09 Finished Classifying License "/zlib-1.2.11.tar.gz/zconf.h": 8.852507ms
2018/06/19 20:07:09 Couldn't classify license(s)
2018/06/19 20:07:10 Classifying license(s): /zlib-1.2.11.tar.gz/inffast.h
2018/06/19 20:07:10 detected language: 4
2018/06/19 20:07:10 " inffast.h -- header to use inffast.c\n * Copyright (C) 1995-2003, 2010 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n "
2018/06/19 20:07:10 " WARNING: this file should *not* be used by applications. It is\n   part of the implementation of the compression library and is\n   subject to change. Applications should only use zlib.h.\n "
2018/06/19 20:07:10 Finished Classifying License "/zlib-1.2.11.tar.gz/inffast.h": 1.056476ms
2018/06/19 20:07:10 Couldn't classify license(s)
2018/06/19 20:07:11 Classifying license(s): /zlib-1.2.11.tar.gz/zlib.map
2018/06/19 20:07:11 Finished Classifying License "/zlib-1.2.11.tar.gz/zlib.map": 2.788321ms
2018/06/19 20:07:11 Couldn't classify license(s)
2018/06/19 20:07:11 Classifying license(s): /zlib-1.2.11.tar.gz/inffixed.h
2018/06/19 20:07:11 detected language: 4
2018/06/19 20:07:11 " inffixed.h -- table for decoding fixed codes\n     * Generated automatically by makefixed().\n     "
2018/06/19 20:07:11 " WARNING: this file should *not* be used by applications.\n       It is part of the implementation of this library and is\n       subject to change. Applications should only use zlib.h.\n     "
2018/06/19 20:07:11 Finished Classifying License "/zlib-1.2.11.tar.gz/inffixed.h": 1.747761ms
2018/06/19 20:07:11 Couldn't classify license(s)
2018/06/19 20:07:12 Classifying license(s): /zlib-1.2.11.tar.gz/compress.c
2018/06/19 20:07:12 detected language: 4
2018/06/19 20:07:12 " compress.c -- compress a memory buffer\n * Copyright (C) 1995-2005, 2014, 2016 Jean-loup Gailly, Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n "
2018/06/19 20:07:12 " @(#) $Id$ "
2018/06/19 20:07:12 " ===========================================================================\n     Compresses the source buffer into the destination buffer. The level\n   parameter has the same meaning as in deflateInit.  sourceLen is the byte\n   length of the source buffer. Upon entry, destLen is the total size of the\n   destination buffer, which must be at least 0.1% larger than sourceLen plus\n   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.\n\n     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough\n   memory, Z_BUF_ERROR if there was not enough room in the output buffer,\n   Z_STREAM_ERROR if the level parameter is invalid.\n"
2018/06/19 20:07:12 " ===========================================================================\n "
2018/06/19 20:07:12 " ===========================================================================\n     If the default memLevel or windowBits for deflateInit() is changed, then\n   this function needs to be updated.\n "
2018/06/19 20:07:12 Finished Classifying License "/zlib-1.2.11.tar.gz/compress.c": 2.613458ms
2018/06/19 20:07:12 Couldn't classify license(s)
2018/06/19 20:07:13 Classifying license(s): /zlib-1.2.11.tar.gz/win32/zlib.def
2018/06/19 20:07:13 Finished Classifying License "/zlib-1.2.11.tar.gz/win32/zlib.def": 3.001281ms
2018/06/19 20:07:13 Couldn't classify license(s)
2018/06/19 20:07:14 Classifying license(s): /zlib-1.2.11.tar.gz/win32/DLL_FAQ.txt
2018/06/19 20:07:14 Finished Classifying License "/zlib-1.2.11.tar.gz/win32/DLL_FAQ.txt": 60.663195ms
2018/06/19 20:07:14 Couldn't classify license(s)
2018/06/19 20:07:15 Classifying license(s): /zlib-1.2.11.tar.gz/win32/README-WIN32.txt
2018/06/19 20:07:15 Finished Classifying License "/zlib-1.2.11.tar.gz/win32/README-WIN32.txt": 18.205979ms
2018/06/19 20:07:15 Classifying license(s): /zlib-1.2.11.tar.gz/win32/Makefile.bor
2018/06/19 20:07:15 Finished Classifying License "/zlib-1.2.11.tar.gz/win32/Makefile.bor": 4.813177ms
2018/06/19 20:07:15 Couldn't classify license(s)
2018/06/19 20:07:16 Classifying license(s): /zlib-1.2.11.tar.gz/win32/VisualC.txt
2018/06/19 20:07:16 Finished Classifying License "/zlib-1.2.11.tar.gz/win32/VisualC.txt": 551.9µs
2018/06/19 20:07:16 Couldn't classify license(s)
2018/06/19 20:07:17 Classifying license(s): /zlib-1.2.11.tar.gz/win32/Makefile.msc
2018/06/19 20:07:17 Finished Classifying License "/zlib-1.2.11.tar.gz/win32/Makefile.msc": 16.928982ms
2018/06/19 20:07:17 Couldn't classify license(s)
2018/06/19 20:07:18 Classifying license(s): /zlib-1.2.11.tar.gz/win32/zlib1.rc
2018/06/19 20:07:18 Finished Classifying License "/zlib-1.2.11.tar.gz/win32/zlib1.rc": 8.161929ms
2018/06/19 20:07:18 Couldn't classify license(s)
2018/06/19 20:07:18 Classifying license(s): /zlib-1.2.11.tar.gz/win32/Makefile.gcc
2018/06/19 20:07:18 Finished Classifying License "/zlib-1.2.11.tar.gz/win32/Makefile.gcc": 18.124528ms
2018/06/19 20:07:18 Couldn't classify license(s)
2018/06/19 20:07:19 Classifying license(s): /zlib-1.2.11.tar.gz/deflate.h
2018/06/19 20:07:19 detected language: 4
2018/06/19 20:07:19 " deflate.h -- internal compression state\n * Copyright (C) 1995-2016 Jean-loup Gailly\n * For conditions of distribution and use, see copyright notice in zlib.h\n "
2018/06/19 20:07:19 " WARNING: this file should *not* be used by applications. It is\n   part of the implementation of the compression library and is\n   subject to change. Applications should only use zlib.h.\n "
2018/06/19 20:07:19 " @(#) $Id$ "
2018/06/19 20:07:19 " define NO_GZIP when compiling if you want to disable gzip header and\n   trailer creation by deflate().  NO_GZIP would be used to avoid linking in\n   the crc code when it is not needed.  For shared libraries, gzip encoding\n   should be left enabled. "
2018/06/19 20:07:19 " ===========================================================================\n * Internal compression state.\n "
2018/06/19 20:07:19 " number of length codes, not counting the special END_BLOCK code "
2018/06/19 20:07:19 " number of literal bytes 0..255 "
2018/06/19 20:07:19 " number of Literal or Length codes, including the END_BLOCK code "
2018/06/19 20:07:19 " number of distance codes "
2018/06/19 20:07:19 " number of codes used to transfer the bit lengths "
2018/06/19 20:07:19 " maximum heap size "
2018/06/19 20:07:19 " All codes must not exceed MAX_BITS bits "
2018/06/19 20:07:19 " size of bit buffer in bi_buf "
2018/06/19 20:07:19 " zlib header -> BUSY_STATE "
2018/06/19 20:07:19 " gzip header -> BUSY_STATE | EXTRA_STATE "
2018/06/19 20:07:19 " gzip extra block -> NAME_STATE \n gzip file name -> COMMENT_STATE \n gzip comment -> HCRC_STATE \n gzip header CRC -> BUSY_STATE \n deflate -> FINISH_STATE \n stream complete \n Stream status "
2018/06/19 20:07:19 " Data structure describing a single value and its code string. "
2018/06/19 20:07:19 " frequency count \n bit string "
2018/06/19 20:07:19 " father node in Huffman tree \n length of bit string "
2018/06/19 20:07:19 " the dynamic tree \n largest code with non zero frequency \n the corresponding static tree "
2018/06/19 20:07:19 " A Pos is an index in the character window. We use short instead of int to\n * save space in the various tables. IPos is used only for parameter passing.\n "
2018/06/19 20:07:19 " pointer back to this zlib stream \n as the name implies \n output still pending \n size of pending_buf \n next pending byte to output to the stream \n nb of bytes in the pending buffer \n bit 0 true for zlib, bit 1 true for gzip \n gzip header information to write \n where in extra, name, or comment \n can only be DEFLATED \n value of flush param for previous deflate call "
2018/06/19 20:07:19 " used by deflate.c: "
2018/06/19 20:07:19 " LZ77 window size (32K by default) \n log2(w_size)  (8..16) \n w_size - 1 "
2018/06/19 20:07:19 " Sliding window. Input bytes are read into the second half of the window,\n     * and move to the first half later to keep a dictionary of at least wSize\n     * bytes. With this organization, matches are limited to a distance of\n     * wSize-MAX_MATCH bytes, but this ensures that IO is always\n     * performed with a length multiple of the block size. Also, it limits\n     * the window size to 64K, which is quite useful on MSDOS.\n     * To do: use the user input buffer as sliding window.\n     "
2018/06/19 20:07:19 " Actual size of window: 2*wSize, except when the user input buffer\n     * is directly used as sliding window.\n     "
2018/06/19 20:07:19 " Link to older string with same hash index. To limit the size of this\n     * array to 64K, this link is maintained only for the last 32K strings.\n     * An index in this array is thus a window index modulo 32K.\n     "
2018/06/19 20:07:19 " Heads of the hash chains or NIL. "
2018/06/19 20:07:19 " hash index of string to be inserted \n number of elements in hash table \n log2(hash_size) \n hash_size-1 "
2018/06/19 20:07:19 " Number of bits by which ins_h must be shifted at each input\n     * step. It must be such that after MIN_MATCH steps, the oldest\n     * byte no longer takes part in the hash key, that is:\n     *   hash_shift * MIN_MATCH >= hash_bits\n     "
2018/06/19 20:07:19 " Window position at the beginning of the current output block. Gets\n     * negative when the window is moved backwards.\n     "
2018/06/19 20:07:19 " length of best match \n previous match \n set if previous match exists \n start of string to insert \n start of matching string \n number of valid bytes ahead in window "
2018/06/19 20:07:19 " Length of the best match at previous step. Matches not greater than this\n     * are discarded. This is used in the lazy match evaluation.\n     "
2018/06/19 20:07:19 " To speed up deflation, hash chains are never searched beyond this\n     * length.  A higher limit improves compression ratio but degrades the\n     * speed.\n     "
2018/06/19 20:07:19 " Attempt to find a better match only when the current match is strictly\n     * smaller than this value. This mechanism is used only for compression\n     * levels >= 4.\n     "
2018/06/19 20:07:19 " Insert new strings in the hash table only if the match length is not\n     * greater than this length. This saves time but degrades compression.\n     * max_insert_length is used only for compression levels <= 3.\n     "
2018/06/19 20:07:19 " compression level (1..9) \n favor or force Huffman coding"
2018/06/19 20:07:19 " Use a faster search when the previous match is longer than this "
2018/06/19 20:07:19 " Stop searching when current match exceeds this "
2018/06/19 20:07:19 " used by trees.c: \n Didn't use ct_data typedef below to suppress compiler warning \n literal and length tree \n distance tree \n Huffman tree for bit lengths "
2018/06/19 20:07:19 " desc. for literal tree \n desc. for distance tree \n desc. for bit length tree "
2018/06/19 20:07:19 " number of codes at each bit length for an optimal tree "
2018/06/19 20:07:19 " heap used to build the Huffman trees \n number of elements in the heap \n element of largest frequency \n The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n     * The same heap array is used to build all trees.\n     "
2018/06/19 20:07:19 " Depth of each subtree used as tie breaker for trees of equal frequency\n     "
2018/06/19 20:07:19 " buffer for literals or lengths "
2018/06/19 20:07:19 " Size of match buffer for literals/lengths.  There are 4 reasons for\n     * limiting lit_bufsize to 64K:\n     *   - frequencies can be kept in 16 bit counters\n     *   - if compression is not successful for the first block, all input\n     *     data is still in the window so we can still emit a stored block even\n     *     when input comes from standard input.  (This can also be done for\n     *     all blocks if lit_bufsize is not greater than 32K.)\n     *   - if compression is not successful for a file smaller than 64K, we can\n     *     even emit a stored file instead of a stored block (saving 5 bytes).\n     *     This is applicable only for zip (not gzip or zlib).\n     *   - creating new Huffman trees less frequently may not provide fast\n     *     adaptation to changes in the input data statistics. (Take for\n     *     example a binary file with poorly compressible code followed by\n     *     a highly compressible string table.) Smaller buffer sizes give\n     *     fast adaptation but have of course the overhead of transmitting\n     *     trees more frequently.\n     *   - I can't count above 4\n     "
2018/06/19 20:07:19 " running index in l_buf "
2018/06/19 20:07:19 " Buffer for distances. To simplify the code, d_buf and l_buf have\n     * the same number of elements. To use different lengths, an extra flag\n     * array would be necessary.\n     "
2018/06/19 20:07:19 " bit length of current block with optimal trees \n bit length of current block with static trees \n number of string matches in current block \n bytes at end of window left to insert "
2018/06/19 20:07:19 " total bit length of compressed file mod 2^32 \n bit length of compressed data sent mod 2^32 "
2018/06/19 20:07:19 " Output buffer. bits are inserted starting at the bottom (least\n     * significant bits).\n     "
2018/06/19 20:07:19 " Number of valid bits in bi_buf.  All bits above the last valid bit\n     * are always zero.\n     "
2018/06/19 20:07:19 " High water mark offset in window for initialized bytes -- bytes above\n     * this are set to zero in order to avoid memory check warnings when\n     * longest match routines access bytes past the input.  This is then\n     * updated to the new high water mark.\n     "
2018/06/19 20:07:19 " Output a byte on the stream.\n * IN assertion: there is enough room in pending_buf.\n "
2018/06/19 20:07:19 " Minimum amount of lookahead, except at the end of the input file.\n * See deflate.c for comments about the MIN_MATCH+1.\n "
2018/06/19 20:07:19 " In order to simplify the code, particularly on 16 bit machines, match\n * distances are limited to MAX_DIST instead of WSIZE.\n "
2018/06/19 20:07:19 " Number of bytes after end of data in window to initialize in order to avoid\n   memory checker errors from longest match routines "
2018/06/19 20:07:19 " in trees.c "
2018/06/19 20:07:19 " Mapping from a distance to a distance code. dist is the distance - 1 and\n * must not have side effects. _dist_code[256] and _dist_code[257] are never\n * used.\n "
2018/06/19 20:07:19 " Inline versions of _tr_tally for speed: "
2018/06/19 20:07:19 " DEFLATE_H "
2018/06/19 20:07:19 Finished Classifying License "/zlib-1.2.11.tar.gz/deflate.h": 41.940364ms
2018/06/19 20:07:19 Couldn't classify license(s)
2018/06/19 20:07:20 Classifying license(s): /zlib-1.2.11.tar.gz/treebuild.xml
2018/06/19 20:07:20 Finished Classifying License "/zlib-1.2.11.tar.gz/treebuild.xml": 12.791905ms
2018/06/19 20:07:20 Couldn't classify license(s)
2018/06/19 20:07:21 Classifying license(s): /zlib-1.2.11.tar.gz/FAQ
2018/06/19 20:07:21 Finished Classifying License "/zlib-1.2.11.tar.gz/FAQ": 51.621614ms
2018/06/19 20:07:21 Couldn't classify license(s)
2018/06/19 20:07:22 Classifying license(s): /zlib-1.2.11.tar.gz/inflate.c
2018/06/19 20:07:22 detected language: 4
2018/06/19 20:07:22 " inflate.c -- zlib decompression\n * Copyright (C) 1995-2016 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n "
2018/06/19 20:07:22 "\n * Change history:\n *\n * 1.2.beta0    24 Nov 2002\n * - First version -- complete rewrite of inflate to simplify code, avoid\n *   creation of window when not needed, minimize use of window when it is\n *   needed, make inffast.c even faster, implement gzip decoding, and to\n *   improve code readability and style over the previous zlib inflate code\n *\n * 1.2.beta1    25 Nov 2002\n * - Use pointers for available input and output checking in inffast.c\n * - Remove input and output counters in inffast.c\n * - Change inffast.c entry and loop from avail_in >= 7 to >= 6\n * - Remove unnecessary second byte pull from length extra in inffast.c\n * - Unroll direct copy to three copies per loop in inffast.c\n *\n * 1.2.beta2    4 Dec 2002\n * - Change external routine names to reduce potential conflicts\n * - Correct filename to inffixed.h for fixed tables in inflate.c\n * - Make hbuf[] unsigned char to match parameter type in inflate.c\n * - Change strm->next_out[-state->offset] to *(strm->next_out - state->offset)\n *   to avoid negation problem on Alphas (64 bit) in inflate.c\n *\n * 1.2.beta3    22 Dec 2002\n * - Add comments on state->bits assertion in inffast.c\n * - Add comments on op field in inftrees.h\n * - Fix bug in reuse of allocated window after inflateReset()\n * - Remove bit fields--back to byte structure for speed\n * - Remove distance extra == 0 check in inflate_fast()--only helps for lengths\n * - Change post-increments to pre-increments in inflate_fast(), PPC biased?\n * - Add compile time option, POSTINC, to use post-increments instead (Intel?)\n * - Make MATCH copy in inflate() much faster for when inflate_fast() not used\n * - Use local copies of stream next and avail values, as well as local bit\n *   buffer and bit count in inflate()--for speed when inflate_fast() not used\n *\n * 1.2.beta4    1 Jan 2003\n * - Split ptr - 257 statements in inflate_table() to avoid compiler warnings\n * - Move a comment on output buffer sizes from inffast.c to inflate.c\n * - Add comments in inffast.c to introduce the inflate_fast() routine\n * - Rearrange window copies in inflate_fast() for speed and simplification\n * - Unroll last copy for window match in inflate_fast()\n * - Use local copies of window variables in inflate_fast() for speed\n * - Pull out common wnext == 0 case for speed in inflate_fast()\n * - Make op and len in inflate_fast() unsigned for consistency\n * - Add FAR to lcode and dcode declarations in inflate_fast()\n * - Simplified bad distance check in inflate_fast()\n * - Added inflateBackInit(), inflateBack(), and inflateBackEnd() in new\n *   source file infback.c to provide a call-back interface to inflate for\n *   programs like gzip and unzip -- uses window as output buffer to avoid\n *   window copying\n *\n * 1.2.beta5    1 Jan 2003\n * - Improved inflateBack() interface to allow the caller to provide initial\n *   input in strm.\n * - Fixed stored blocks bug in inflateBack()\n *\n * 1.2.beta6    4 Jan 2003\n * - Added comments in inffast.c on effectiveness of POSTINC\n * - Typecasting all around to reduce compiler warnings\n * - Changed loops from while (1) or do {} while (1) to for (;;), again to\n *   make compilers happy\n * - Changed type of window in inflateBackInit() to unsigned char *\n *\n * 1.2.beta7    27 Jan 2003\n * - Changed many types to unsigned or unsigned short to avoid warnings\n * - Added inflateCopy() function\n *\n * 1.2.0        9 Mar 2003\n * - Changed inflateBack() interface to provide separate opaque descriptors\n *   for the in() and out() functions\n * - Changed inflateBack() argument and in_func typedef to swap the length\n *   and buffer address return values for the input function\n * - Check next_in and next_out for Z_NULL on entry to inflate()\n *\n * The history for versions after 1.2.0 are in ChangeLog in zlib distribution.\n "
2018/06/19 20:07:22 " function prototypes "
2018/06/19 20:07:22 " to support ill-conceived Java test suite "
2018/06/19 20:07:22 " get the state "
2018/06/19 20:07:22 " extract wrap request from windowBits parameter "
2018/06/19 20:07:22 " set number of window bits, free window if different "
2018/06/19 20:07:22 " update state and reset the rest of it "
2018/06/19 20:07:22 " in case we return an error "
2018/06/19 20:07:22 " to pass state test in inflateReset2() "
2018/06/19 20:07:22 "\n   Return state with length and distance decoding tables and index sizes set to\n   fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n   If BUILDFIXED is defined, then instead this routine builds the tables the\n   first time it's called, and returns those tables the first time and\n   thereafter.  This reduces the size of the code by about 2K bytes, in\n   exchange for a little execution time.  However, BUILDFIXED should not be\n   used for threaded applications, since the rewriting of the tables and virgin\n   may not be thread-safe.\n "
2018/06/19 20:07:22 " build fixed huffman tables if first call (may not be thread safe) "
2018/06/19 20:07:22 " literal/length table "
2018/06/19 20:07:22 " distance table "
2018/06/19 20:07:22 " do this just once "
2018/06/19 20:07:22 " !BUILDFIXED "
2018/06/19 20:07:22 " BUILDFIXED "
2018/06/19 20:07:22 "\n   Write out the inffixed.h that is #include'd above.  Defining MAKEFIXED also\n   defines BUILDFIXED, so the tables are built on the fly.  makefixed() writes\n   those tables to stdout, which would be piped to inffixed.h.  A small program\n   can simply call makefixed to do this:\n\n    void makefixed(void);\n\n    int main(void)\n    {\n        makefixed();\n        return 0;\n    }\n\n   Then that can be linked with zlib built with MAKEFIXED defined and run:\n\n    a.out > inffixed.h\n "
2018/06/19 20:07:22 " MAKEFIXED "
2018/06/19 20:07:22 "\n   Update the window with the last wsize (normally 32K) bytes written before\n   returning.  If window does not exist yet, create it.  This is only called\n   when a window is already in use, or when output has been written during this\n   inflate call, but the end of the deflate stream has not been reached yet.\n   It is also called to create a window for dictionary data when a dictionary\n   is loaded.\n\n   Providing output buffers larger than 32K to inflate() should provide a speed\n   advantage, since only the last 32K of output is copied to the sliding window\n   upon return from inflate(), and since all distances after the first 32K of\n   output will fall in the output data, making match copies simpler and faster.\n   The advantage may be dependent on the size of the processor's data caches.\n "
2018/06/19 20:07:22 " if it hasn't been done already, allocate space for the window "
2018/06/19 20:07:22 " if window not in use yet, initialize "
2018/06/19 20:07:22 " copy state->wsize or less output bytes into the circular window "
2018/06/19 20:07:22 " Macros for inflate(): "
2018/06/19 20:07:22 " check function to use adler32() for zlib or crc32() for gzip "
2018/06/19 20:07:22 " check macros for header crc "
2018/06/19 20:07:22 " Load registers with state in inflate() for speed "
2018/06/19 20:07:22 " Restore state from registers in inflate() "
2018/06/19 20:07:22 " Clear the input bit accumulator "
2018/06/19 20:07:22 " Get a byte of input into the bit accumulator, or return from inflate()\n   if there is no input available. "
2018/06/19 20:07:22 " Assure that there are at least n bits in the bit accumulator.  If there is\n   not enough available input to do that, then return from inflate(). "
2018/06/19 20:07:22 " Return the low n bits of the bit accumulator (n < 16) "
2018/06/19 20:07:22 " Remove n bits from the bit accumulator "
2018/06/19 20:07:22 " Remove zero to seven bits as needed to go to a byte boundary "
2018/06/19 20:07:22 "\n   inflate() uses a state machine to process as much input data and generate as\n   much output data as possible before returning.  The state machine is\n   structured roughly as follows:\n\n    for (;;) switch (state) {\n    ...\n    case STATEn:\n        if (not enough input data or output space to make progress)\n            return;\n        ... make progress ...\n        state = STATEm;\n        break;\n    ...\n    }\n\n   so when inflate() is called again, the same case is attempted again, and\n   if the appropriate resources are provided, the machine proceeds to the\n   next state.  The NEEDBITS() macro is usually the way the state evaluates\n   whether it can proceed or should return.  NEEDBITS() does the return if\n   the requested bits are not available.  The typical use of the BITS macros\n   is:\n\n        NEEDBITS(n);\n        ... do something with BITS(n) ...\n        DROPBITS(n);\n\n   where NEEDBITS(n) either returns from inflate() if there isn't enough\n   input left to load n bits into the accumulator, or it continues.  BITS(n)\n   gives the low n bits in the accumulator.  When done, DROPBITS(n) drops\n   the low n bits off the accumulator.  INITBITS() clears the accumulator\n   and sets the number of available bits to zero.  BYTEBITS() discards just\n   enough bits to put the accumulator on a byte boundary.  After BYTEBITS()\n   and a NEEDBITS(8), then BITS(8) would return the next byte in the stream.\n\n   NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return\n   if there is no input available.  The decoding of variable length codes uses\n   PULLBYTE() directly in order to pull just enough bytes to decode the next\n   code, and no more.\n\n   Some states loop until they get enough input, making sure that enough\n   state information is maintained to continue the loop where it left off\n   if NEEDBITS() returns in the loop.  For example, want, need, and keep\n   would all have to actually be part of the saved state in case NEEDBITS()\n   returns:\n\n    case STATEw:\n        while (want < need) {\n            NEEDBITS(n);\n            keep[want++] = BITS(n);\n            DROPBITS(n);\n        }\n        state = STATEx;\n    case STATEx:\n\n   As shown above, if the next state is also the next case, then the break\n   is omitted.\n\n   A state may also return if there is not enough output space available to\n   complete that state.  Those states are copying stored data, writing a\n   literal byte, and copying a matching string.\n\n   When returning, a \"goto inf_leave\" is used to update the total counters,\n   update the check value, and determine whether any progress has been made\n   during that inflate() call in order to return the proper return code.\n   Progress is defined as a change in either strm->avail_in or strm->avail_out.\n   When there is a window, goto inf_leave will update the window with the last\n   output written.  If a goto inf_leave occurs in the middle of decompression\n   and there is no window currently, goto inf_leave will create one and copy\n   output to the window for the next call of inflate().\n\n   In this implementation, the flush parameter of inflate() only affects the\n   return code (per zlib.h).  inflate() always writes as much as possible to\n   strm->next_out, given the space available and the provided input--the effect\n   documented in zlib.h of Z_SYNC_FLUSH.  Furthermore, inflate() always defers\n   the allocation of and copying into a sliding window until necessary, which\n   provides the effect documented in zlib.h for Z_FINISH when the entire input\n   stream available.  So the only thing the flush parameter actually does is:\n   when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it\n   will return Z_BUF_ERROR if it has not reached the end of the stream.\n "
2018/06/19 20:07:22 " next input \n next output \n available input and output \n bit buffer \n bits in bit buffer \n save starting available input and output \n number of stored or match bytes to copy \n where to copy match bytes from \n current decoding table entry \n parent table entry \n length to copy for repeats, bits to drop \n return code "
2018/06/19 20:07:22 " buffer for gzip header crc calculation "
2018/06/19 20:07:22 " permutation of code lengths "
2018/06/19 20:07:22 " skip check "
2018/06/19 20:07:22 " gzip header "
2018/06/19 20:07:22 " expect zlib header "
2018/06/19 20:07:22 " check if zlib header allowed "
2018/06/19 20:07:22 " stored block "
2018/06/19 20:07:22 " fixed block "
2018/06/19 20:07:22 " decode codes "
2018/06/19 20:07:22 " dynamic block "
2018/06/19 20:07:22 " go to byte boundary "
2018/06/19 20:07:22 " handle error breaks in while "
2018/06/19 20:07:22 " check for end-of-block code (better have one) "
2018/06/19 20:07:22 " build code tables -- note: do not change the lenbits or distbits\n               values here (9 and 6) without reading the comments in inftrees.h\n               concerning the ENOUGH constants, which depend on those values "
2018/06/19 20:07:22 " copy from window "
2018/06/19 20:07:22 " copy from output "
2018/06/19 20:07:22 "\n       Return from inflate(), updating the total counts and the check value.\n       If there was no progress during the inflate() call, return a buffer\n       error.  Call updatewindow() to create and/or update the window state.\n       Note: a memory error from inflate() is non-recoverable.\n     "
2018/06/19 20:07:22 " check state "
2018/06/19 20:07:22 " copy dictionary "
2018/06/19 20:07:22 " check state "
2018/06/19 20:07:22 " check for correct dictionary identifier "
2018/06/19 20:07:22 " copy dictionary to window using updatewindow(), which will amend the\n       existing dictionary if appropriate "
2018/06/19 20:07:22 " check state "
2018/06/19 20:07:22 " save header structure "
2018/06/19 20:07:22 "\n   Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found\n   or when out of input.  When called, *have is the number of pattern bytes\n   found in order so far, in 0..3.  On return *have is updated to the new\n   state.  If on return *have equals four, then the pattern was found and the\n   return value is how many bytes were read including the last byte of the\n   pattern.  If *have is less than four, then the pattern has not been found\n   yet and the return value is len.  In the latter case, syncsearch() can be\n   called again with more data and the *have state.  *have is initialized to\n   zero for the first call.\n "
2018/06/19 20:07:22 " number of bytes to look at or looked at \n temporary to save total_in and total_out \n to restore bit buffer to byte string "
2018/06/19 20:07:22 " check parameters "
2018/06/19 20:07:22 " if first time, start search in bit buffer "
2018/06/19 20:07:22 " search available input "
2018/06/19 20:07:22 " return no joy or set up to restart inflate() on a new block "
2018/06/19 20:07:22 "\n   Returns true if inflate is currently at the end of a block generated by\n   Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP\n   implementation to provide an additional safety check. PPP uses\n   Z_SYNC_FLUSH but removes the length bytes of the resulting empty stored\n   block. When decompressing, PPP checks that at the end of input packet,\n   inflate is waiting for these length bytes.\n "
2018/06/19 20:07:22 " check input "
2018/06/19 20:07:22 " allocate space "
2018/06/19 20:07:22 " copy state "
2018/06/19 20:07:22 Finished Classifying License "/zlib-1.2.11.tar.gz/inflate.c": 55.51696ms
2018/06/19 20:07:22 Couldn't classify license(s)
2018/06/19 20:07:23 Classifying license(s): /zlib-1.2.11.tar.gz/amiga/Makefile.sas
2018/06/19 20:07:23 Finished Classifying License "/zlib-1.2.11.tar.gz/amiga/Makefile.sas": 3.500514ms
2018/06/19 20:07:23 Couldn't classify license(s)
2018/06/19 20:07:23 Classifying license(s): /zlib-1.2.11.tar.gz/amiga/Makefile.pup
2018/06/19 20:07:23 Finished Classifying License "/zlib-1.2.11.tar.gz/amiga/Makefile.pup": 3.616058ms
2018/06/19 20:07:23 Couldn't classify license(s)
2018/06/19 20:07:24 Classifying license(s): /zlib-1.2.11.tar.gz/zlib.pc.cmakein
2018/06/19 20:07:24 Finished Classifying License "/zlib-1.2.11.tar.gz/zlib.pc.cmakein": 6.206256ms
2018/06/19 20:07:24 Couldn't classify license(s)
2018/06/19 20:07:25 Classifying license(s): /zlib-1.2.11.tar.gz/Makefile
2018/06/19 20:07:25 Finished Classifying License "/zlib-1.2.11.tar.gz/Makefile": 589.831µs
2018/06/19 20:07:25 Couldn't classify license(s)
2018/06/19 20:07:26 Classifying license(s): /zlib-1.2.11.tar.gz/adler32.c
2018/06/19 20:07:26 detected language: 4
2018/06/19 20:07:26 " adler32.c -- compute the Adler-32 checksum of a data stream\n * Copyright (C) 1995-2011, 2016 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n "
2018/06/19 20:07:26 " @(#) $Id$ "
2018/06/19 20:07:26 " largest prime smaller than 65536 "
2018/06/19 20:07:26 " NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 "
2018/06/19 20:07:26 " use NO_DIVIDE if your processor does not do division in hardware --\n   try it both ways to see which is faster "
2018/06/19 20:07:26 " note that this assumes BASE is 65521, where 65536 % 65521 == 15\n   (thank you to John Reiser for pointing this out) "
2018/06/19 20:07:26 " this assumes a is not negative "
2018/06/19 20:07:26 " ========================================================================= "
2018/06/19 20:07:26 " split Adler-32 into component sums "
2018/06/19 20:07:26 " in case user likes doing a byte at a time, keep it fast "
2018/06/19 20:07:26 " initial Adler-32 value (deferred check for len == 1 speed) "
2018/06/19 20:07:26 " in case short lengths are provided, keep it somewhat fast "
2018/06/19 20:07:26 " only added so many BASE's "
2018/06/19 20:07:26 " do length NMAX blocks -- requires just one modulo operation "
2018/06/19 20:07:26 " NMAX is divisible by 16 "
2018/06/19 20:07:26 " 16 sums unrolled "
2018/06/19 20:07:26 " do remaining bytes (less than NMAX, still just one modulo) \n avoid modulos if none remaining "
2018/06/19 20:07:26 " return recombined sums "
2018/06/19 20:07:26 " ========================================================================= "
2018/06/19 20:07:26 " ========================================================================= "
2018/06/19 20:07:26 " for negative len, return invalid adler32 as a clue for debugging "
2018/06/19 20:07:26 " the derivation of this formula is left as an exercise for the reader \n assumes len2 >= 0 "
2018/06/19 20:07:26 " ========================================================================= "
2018/06/19 20:07:26 Finished Classifying License "/zlib-1.2.11.tar.gz/adler32.c": 3.972285ms
2018/06/19 20:07:26 Couldn't classify license(s)
2018/06/19 20:07:26 Classifying license(s): /zlib-1.2.11.tar.gz/Makefile.in
2018/06/19 20:07:27 Finished Classifying License "/zlib-1.2.11.tar.gz/Makefile.in": 42.962262ms
2018/06/19 20:07:27 Couldn't classify license(s)
2018/06/19 20:07:27 Classifying license(s): /zlib-1.2.11.tar.gz/os400/zlib.inc
2018/06/19 20:07:27 Finished Classifying License "/zlib-1.2.11.tar.gz/os400/zlib.inc": 85.661842ms
2018/06/19 20:07:27 Couldn't classify license(s)
2018/06/19 20:07:28 Classifying license(s): /zlib-1.2.11.tar.gz/os400/README400
2018/06/19 20:07:28 Finished Classifying License "/zlib-1.2.11.tar.gz/os400/README400": 10.434969ms
2018/06/19 20:07:28 Couldn't classify license(s)
2018/06/19 20:07:29 Classifying license(s): /zlib-1.2.11.tar.gz/os400/make.sh
2018/06/19 20:07:29 detected language: 32
2018/06/19 20:07:29 361:EOF in string
2018/06/19 20:07:29 "!/bin/sh\n\n       ZLIB compilation script for the OS/400.\n\n\n       This is a shell script since make is not a standard component of OS/400."
2018/06/19 20:07:29 "###############################################################################\n\n                       Tunable configuration parameters.\n\n###############################################################################"
2018/06/19 20:07:29 " Target OS/400 program library\n Static binding directory.\n Dynamic binding directory.\n Service program.\n IFS support base directory.\n Target CCSID of objects\n Debug level\n Optimisation level\n Compilation output option.\n Target OS release"
2018/06/19 20:07:29 "###############################################################################\n\n                       OS/400 specific definitions.\n\n###############################################################################"
2018/06/19 20:07:29 "###############################################################################\n\n                               Procedures.\n\n###############################################################################"
2018/06/19 20:07:29 "       action_needed dest [src]\n\n       dest is an object to build\n       if specified, src is an object on which dest depends.\n\n       exit 0 (succeeds) if some action has to be taken, else 1."
2018/06/19 20:07:29 "       make_module module_name source_name [additional_definitions]\n\n       Compile source name into module if needed.\n       As side effect, append the module name to variable MODULES.\n       Set LINK to \"YES\" if the module has been compiled."
2018/06/19 20:07:29 "       Determine DB2 object name from IFS name."
2018/06/19 20:07:29 "       Force enumeration types to be the same size as integers."
2018/06/19 20:07:29 "###############################################################################\n\n                             Script initialization.\n\n###############################################################################"
2018/06/19 20:07:29 "  The script directory is supposed to be in ${TOPDIR}/os400."
2018/06/19 20:07:29 "  Extract the version from the master compilation XML file."
2018/06/19 20:07:29 "###############################################################################"
2018/06/19 20:07:29 "       Create the OS/400 library if it does not exist."
2018/06/19 20:07:29 "       Create the DOCS source file if it does not exist."
2018/06/19 20:07:29 "       Copy some documentation files if needed."
2018/06/19 20:07:29 "       Create the OS/400 source program file for the C header files."
2018/06/19 20:07:29 "       Create the IFS directory for the C header files."
2018/06/19 20:07:29 "       Copy the header files to DB2 library. Link from IFS include directory."
2018/06/19 20:07:29 "       Need to translate to target CCSID."
2018/06/19 20:07:29 " touch -r \"${HFILE}\" \"${DEST}\""
2018/06/19 20:07:29 "       Install the ILE/RPG header file."
2018/06/19 20:07:29 " touch -r \"${HFILE}\" \"${DEST}\""
2018/06/19 20:07:29 "      Create and compile the identification source file."
2018/06/19 20:07:29 Finished Classifying License "/zlib-1.2.11.tar.gz/os400/make.sh": 9.076301ms
2018/06/19 20:07:29 Couldn't classify license(s)
2018/06/19 20:07:30 Classifying license(s): /zlib-1.2.11.tar.gz/os400/bndsrc
2018/06/19 20:07:30 Finished Classifying License "/zlib-1.2.11.tar.gz/os400/bndsrc": 14.241058ms
2018/06/19 20:07:30 Couldn't classify license(s)
2018/06/19 20:07:31 Classifying license(s): /zlib-1.2.11.tar.gz/zconf.h.cmakein
2018/06/19 20:07:31 Finished Classifying License "/zlib-1.2.11.tar.gz/zconf.h.cmakein": 48.954637ms
2018/06/19 20:07:31 Couldn't classify license(s)
2018/06/19 20:07:31 Classifying license(s): /zlib-1.2.11.tar.gz/doc/rfc1950.txt
2018/06/19 20:07:31 Finished Classifying License "/zlib-1.2.11.tar.gz/doc/rfc1950.txt": 57.555166ms
2018/06/19 20:07:31 Couldn't classify license(s)
2018/06/19 20:07:32 Classifying license(s): /zlib-1.2.11.tar.gz/doc/rfc1951.txt
2018/06/19 20:07:32 Finished Classifying License "/zlib-1.2.11.tar.gz/doc/rfc1951.txt": 131.514037ms
2018/06/19 20:07:32 Couldn't classify license(s)
2018/06/19 20:07:33 Classifying license(s): /zlib-1.2.11.tar.gz/doc/rfc1952.txt
2018/06/19 20:07:33 Finished Classifying License "/zlib-1.2.11.tar.gz/doc/rfc1952.txt": 77.435959ms
2018/06/19 20:07:33 Couldn't classify license(s)
2018/06/19 20:07:34 Classifying license(s): /zlib-1.2.11.tar.gz/doc/txtvsbin.txt
2018/06/19 20:07:34 Finished Classifying License "/zlib-1.2.11.tar.gz/doc/txtvsbin.txt": 20.226657ms
2018/06/19 20:07:34 Couldn't classify license(s)
2018/06/19 20:07:35 Classifying license(s): /zlib-1.2.11.tar.gz/doc/algorithm.txt
2018/06/19 20:07:35 Finished Classifying License "/zlib-1.2.11.tar.gz/doc/algorithm.txt": 33.334527ms
2018/06/19 20:07:35 Couldn't classify license(s)
2018/06/19 20:07:36 Classifying license(s): /zlib-1.2.11.tar.gz/crc32.c
2018/06/19 20:07:36 detected language: 4
2018/06/19 20:07:36 " crc32.c -- compute the CRC-32 of a data stream\n * Copyright (C) 1995-2006, 2010, 2011, 2012, 2016 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n *\n * Thanks to Rodney Brown <rbrown64@csc.com.au> for his contribution of faster\n * CRC methods: exclusive-oring 32 bits of data at a time, and pre-computing\n * tables for updating the shift register in one step with three exclusive-ors\n * instead of four steps with four exclusive-ors.  This results in about a\n * factor of two increase in speed on a Power PC G4 (PPC7455) using gcc -O3.\n "
2018/06/19 20:07:36 " @(#) $Id$ "
2018/06/19 20:07:36 "\n  Note on the use of DYNAMIC_CRC_TABLE: there is no mutex or semaphore\n  protection on the static variables used to control the first-use generation\n  of the crc tables.  Therefore, if you #define DYNAMIC_CRC_TABLE, you should\n  first call get_crc_table() to initialize the tables before allowing more than\n  one thread to use crc32().\n\n  DYNAMIC_CRC_TABLE and MAKECRCH can be #defined to write out crc32.h.\n "
2018/06/19 20:07:36 " !DYNAMIC_CRC_TABLE \n MAKECRCH "
2018/06/19 20:07:36 " for STDC and FAR definitions "
2018/06/19 20:07:36 " Definitions for doing the crc four data bytes at a time. "
2018/06/19 20:07:36 " BYFOUR "
2018/06/19 20:07:36 " Local functions for crc concatenation "
2018/06/19 20:07:36 " MAKECRCH \n\n  Generate tables for a byte-wise 32-bit CRC calculation on the polynomial:\n  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.\n\n  Polynomials over GF(2) are represented in binary, one bit per coefficient,\n  with the lowest powers in the most significant bit.  Then adding polynomials\n  is just exclusive-or, and multiplying a polynomial by x is a right shift by\n  one.  If we call the above polynomial p, and represent a byte as the\n  polynomial q, also with the lowest power in the most significant bit (so the\n  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,\n  where a mod b means the remainder after dividing a by b.\n\n  This calculation is done using the shift-register method of multiplying and\n  taking the remainder.  The register is initialized to zero, and for each\n  incoming bit, x^32 is added mod p to the register if the bit is a one (where\n  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by\n  x (which is shifting right by one and adding x^32 mod p if the bit shifted\n  out is a one).  We start with the highest power (least significant bit) of\n  q and repeat for all eight bits of q.\n\n  The first table is simply the CRC of all possible eight bit values.  This is\n  all the information needed to generate CRCs on data a byte at a time for all\n  combinations of CRC register values and incoming bytes.  The remaining tables\n  allow for word-at-a-time CRC calculation for both big-endian and little-\n  endian machines, where a word is four bytes.\n"
2018/06/19 20:07:36 " polynomial exclusive-or pattern \n terms of polynomial defining this crc (except x^32): \n flag to limit concurrent making "
2018/06/19 20:07:36 " See if another task is already doing this (not thread-safe, but better\n       than nothing -- significantly reduces duration of vulnerability in\n       case the advice about DYNAMIC_CRC_TABLE is ignored) "
2018/06/19 20:07:36 " make exclusive-or pattern from polynomial (0xedb88320UL) "
2018/06/19 20:07:36 " generate a crc for every 8-bit value "
2018/06/19 20:07:36 " generate crc for each value followed by one, two, and three zeros,\n           and then the byte reversal of those as well as the first table "
2018/06/19 20:07:36 " BYFOUR "
2018/06/19 20:07:36 " not first \n wait for the other guy to finish (not efficient, but rare) "
2018/06/19 20:07:36 " write out CRC tables to crc32.h "
2018/06/19 20:07:36 " BYFOUR "
2018/06/19 20:07:36 " MAKECRCH "
2018/06/19 20:07:36 " MAKECRCH "
2018/06/19 20:07:36 " !DYNAMIC_CRC_TABLE \n ========================================================================\n * Tables of CRC-32s of all single-byte values, made by make_crc_table().\n "
2018/06/19 20:07:36 " DYNAMIC_CRC_TABLE "
2018/06/19 20:07:36 " =========================================================================\n * This function can be used by asm versions of crc32()\n "
2018/06/19 20:07:36 " DYNAMIC_CRC_TABLE "
2018/06/19 20:07:36 " ========================================================================= "
2018/06/19 20:07:36 " ========================================================================= "
2018/06/19 20:07:36 " DYNAMIC_CRC_TABLE "
2018/06/19 20:07:36 " BYFOUR "
2018/06/19 20:07:36 " ========================================================================= "
2018/06/19 20:07:36 "\n   This BYFOUR code accesses the passed unsigned char * buffer with a 32-bit\n   integer pointer type. This violates the strict aliasing rule, where a\n   compiler can assume, for optimization purposes, that two pointers to\n   fundamentally different types won't ever point to the same memory. This can\n   manifest as a problem only if one of the pointers is written to. This code\n   only reads from those pointers. So long as this code remains isolated in\n   this compilation unit, there won't be a problem. For this reason, this code\n   should not be copied and pasted into a compilation unit in which other code\n   writes to the buffer that is passed to these routines.\n "
2018/06/19 20:07:36 " ========================================================================= "
2018/06/19 20:07:36 " ========================================================================= "
2018/06/19 20:07:36 " ========================================================================= "
2018/06/19 20:07:36 " ========================================================================= "
2018/06/19 20:07:36 " BYFOUR "
2018/06/19 20:07:36 " dimension of GF(2) vectors (length of CRC) "
2018/06/19 20:07:36 " ========================================================================= "
2018/06/19 20:07:36 " ========================================================================= "
2018/06/19 20:07:36 " ========================================================================= "
2018/06/19 20:07:36 " even-power-of-two zeros operator \n odd-power-of-two zeros operator "
2018/06/19 20:07:36 " degenerate case (also disallow negative lengths) "
2018/06/19 20:07:36 " put operator for one zero bit in odd \n CRC-32 polynomial "
2018/06/19 20:07:36 " put operator for two zero bits in even "
2018/06/19 20:07:36 " put operator for four zero bits in odd "
2018/06/19 20:07:36 " apply len2 zeros to crc1 (first square will put the operator for one\n       zero byte, eight zero bits, in even) "
2018/06/19 20:07:36 " apply zeros operator for this bit of len2 "
2018/06/19 20:07:36 " if no more bits set, then done "
2018/06/19 20:07:36 " another iteration of the loop with odd and even swapped "
2018/06/19 20:07:36 " if no more bits set, then done "
2018/06/19 20:07:36 " return combined crc "
2018/06/19 20:07:36 " ========================================================================= "
2018/06/19 20:07:36 Finished Classifying License "/zlib-1.2.11.tar.gz/crc32.c": 19.938732ms
2018/06/19 20:07:36 Couldn't classify license(s)
2018/06/19 20:07:36 Classifying license(s): /zlib-1.2.11.tar.gz/gzlib.c
2018/06/19 20:07:36 detected language: 4
2018/06/19 20:07:36 " gzlib.c -- zlib functions common to reading and writing gzip files\n * Copyright (C) 2004-2017 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n "
2018/06/19 20:07:36 " Local functions "
2018/06/19 20:07:36 " Map the Windows error number in ERROR to a locale-dependent error message\n   string and return a pointer to it.  Typically, the values for ERROR come\n   from GetLastError.\n\n   The string pointed to shall not be modified by the application, but may be\n   overwritten by a subsequent call to gz_strwinerror\n\n   The gz_strwinerror function does not change the current setting of\n   GetLastError. "
2018/06/19 20:07:36 " Default language "
2018/06/19 20:07:36 " If there is an \\r\\n appended, zap it.  "
2018/06/19 20:07:36 " UNDER_CE "
2018/06/19 20:07:36 " Reset gzip file state "
2018/06/19 20:07:36 " no output data available \n for reading ... \n not at end of file \n have not read past end yet \n look for gzip header "
2018/06/19 20:07:36 " no seek request pending \n clear error \n no uncompressed data yet \n no input data yet "
2018/06/19 20:07:36 " Open a gzip file either by name or file descriptor. "
2018/06/19 20:07:36 " check input "
2018/06/19 20:07:36 " allocate gzFile structure to return "
2018/06/19 20:07:36 " no buffers allocated yet \n requested buffer size \n no error message yet "
2018/06/19 20:07:36 " interpret mode "
2018/06/19 20:07:36 " can't read and write at the same time "
2018/06/19 20:07:36 " ignore -- will request binary anyway "
2018/06/19 20:07:36 " could consider as an error, but just ignore "
2018/06/19 20:07:36 " must provide an \"r\", \"w\", or \"a\" "
2018/06/19 20:07:36 " can't force transparent read "
2018/06/19 20:07:36 " for empty file "
2018/06/19 20:07:36 " save the path name for error messages "
2018/06/19 20:07:36 " compute the flags for open() "
2018/06/19 20:07:36 " open the file with the appropriate flags (or just use fd) "
2018/06/19 20:07:36 " so gzoffset() is correct \n simplify later checks "
2018/06/19 20:07:36 " save the current position for rewinding (only if reading) "
2018/06/19 20:07:36 " initialize stream "
2018/06/19 20:07:36 " return stream "
2018/06/19 20:07:36 " -- see zlib.h -- "
2018/06/19 20:07:36 " -- see zlib.h -- "
2018/06/19 20:07:36 " -- see zlib.h -- "
2018/06/19 20:07:36 " identifier for error messages "
2018/06/19 20:07:36 " for debugging "
2018/06/19 20:07:36 " -- see zlib.h -- "
2018/06/19 20:07:36 " -- see zlib.h -- "
2018/06/19 20:07:36 " get internal structure and check integrity "
2018/06/19 20:07:36 " make sure we haven't already allocated memory "
2018/06/19 20:07:36 " check and set requested size "
2018/06/19 20:07:36 " need to be able to double it "
2018/06/19 20:07:36 " need two bytes to check magic header "
2018/06/19 20:07:36 " -- see zlib.h -- "
2018/06/19 20:07:36 " get internal structure "
2018/06/19 20:07:36 " check that we're reading and that there's no error "
2018/06/19 20:07:36 " back up and start over "
2018/06/19 20:07:36 " -- see zlib.h -- "
2018/06/19 20:07:36 " get internal structure and check integrity "
2018/06/19 20:07:36 " check that there's no error "
2018/06/19 20:07:36 " can only seek from start or relative to current position "
2018/06/19 20:07:36 " normalize offset to a SEEK_CUR specification "
2018/06/19 20:07:36 " if within raw area while reading, just go there "
2018/06/19 20:07:36 " calculate skip amount, rewinding if needed for back seek when reading "
2018/06/19 20:07:36 " writing -- can't go backwards "
2018/06/19 20:07:36 " before start of file! "
2018/06/19 20:07:36 " rewind, then skip to offset "
2018/06/19 20:07:36 " if reading, skip what's in output buffer (one less gzgetc() check) "
2018/06/19 20:07:36 " request skip (if not zero) "
2018/06/19 20:07:36 " -- see zlib.h -- "
2018/06/19 20:07:36 " -- see zlib.h -- "
2018/06/19 20:07:36 " get internal structure and check integrity "
2018/06/19 20:07:36 " return position "
2018/06/19 20:07:36 " -- see zlib.h -- "
2018/06/19 20:07:36 " -- see zlib.h -- "
2018/06/19 20:07:36 " get internal structure and check integrity "
2018/06/19 20:07:36 " compute and return effective offset in file "
2018/06/19 20:07:36 " reading \n don't count buffered input "
2018/06/19 20:07:36 " -- see zlib.h -- "
2018/06/19 20:07:36 " -- see zlib.h -- "
2018/06/19 20:07:36 " get internal structure and check integrity "
2018/06/19 20:07:36 " return end-of-file state "
2018/06/19 20:07:36 " -- see zlib.h -- "
2018/06/19 20:07:36 " get internal structure and check integrity "
2018/06/19 20:07:36 " return error information "
2018/06/19 20:07:36 " -- see zlib.h -- "
2018/06/19 20:07:36 " get internal structure and check integrity "
2018/06/19 20:07:36 " clear error and end-of-file "
2018/06/19 20:07:36 " Create an error message in allocated memory and set state->err and\n   state->msg accordingly.  Free any previous error message already there.  Do\n   not try to free or allocate space if the error is Z_MEM_ERROR (out of\n   memory).  Simply save the error message as a static string.  If there is an\n   allocation failure constructing the error message, then convert the error to\n   out of memory. "
2018/06/19 20:07:36 " free previously allocated message and clear "
2018/06/19 20:07:36 " if fatal, set state->x.have to 0 so that the gzgetc() macro fails "
2018/06/19 20:07:36 " set error code, and if no message, then done "
2018/06/19 20:07:36 " for an out of memory error, return literal string when requested "
2018/06/19 20:07:36 " construct error message with path "
2018/06/19 20:07:36 " portably return maximum value for an int (when limits.h presumed not\n   available) -- we need to do this to cover cases where 2's complement not\n   used, since C standard permits 1's complement and sign-bit representations,\n   otherwise we could just use ((unsigned)-1) >> 1 "
2018/06/19 20:07:36 Finished Classifying License "/zlib-1.2.11.tar.gz/gzlib.c": 15.42814ms
2018/06/19 20:07:36 Couldn't classify license(s)
2018/06/19 20:07:37 Classifying license(s): /zlib-1.2.11.tar.gz/test/infcover.c
2018/06/19 20:07:37 detected language: 4
2018/06/19 20:07:37 " infcover.c -- test zlib's inflate routines with full code coverage\n * Copyright (C) 2011, 2016 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n "
2018/06/19 20:07:37 " to use, do: ./configure --cover && make cover "
2018/06/19 20:07:37 " get definition of internal structure so we can mess with it (see pull()),\n   and so we can call inflate_trees() (see cover5()) "
2018/06/19 20:07:37 " -- memory tracking routines -- "
2018/06/19 20:07:37 "\n   These memory tracking routines are provided to zlib and track all of zlib's\n   allocations and deallocations, check for LIFO operations, keep a current\n   and high water mark of total bytes requested, optionally set a limit on the\n   total memory that can be allocated, and when done check for memory leaks.\n\n   They are used as follows:\n\n   z_stream strm;\n   mem_setup(&strm)         initializes the memory tracking and sets the\n                            zalloc, zfree, and opaque members of strm to use\n                            memory tracking for all zlib operations on strm\n   mem_limit(&strm, limit)  sets a limit on the total bytes requested -- a\n                            request that exceeds this limit will result in an\n                            allocation failure (returns NULL) -- setting the\n                            limit to zero means no limit, which is the default\n                            after mem_setup()\n   mem_used(&strm, \"msg\")   prints to stderr \"msg\" and the total bytes used\n   mem_high(&strm, \"msg\")   prints to stderr \"msg\" and the high water mark\n   mem_done(&strm, \"msg\")   ends memory tracking, releases all allocations\n                            for the tracking as well as leaked zlib blocks, if\n                            any.  If there was anything unusual, such as leaked\n                            blocks, non-FIFO frees, or frees of addresses not\n                            allocated, then \"msg\" and information about the\n                            problem is printed to stderr.  If everything is\n                            normal, nothing is printed. mem_done resets the\n                            strm members to Z_NULL to use the default memory\n                            allocation routines on the next zlib initialization\n                            using strm.\n "
2018/06/19 20:07:37 " these items are strung together in a linked list, one for each allocation "
2018/06/19 20:07:37 " pointer to allocated memory \n requested size of allocation \n pointer to next item in list, or NULL "
2018/06/19 20:07:37 " this structure is at the root of the linked list, and tracks statistics "
2018/06/19 20:07:37 " pointer to first item in list, or NULL \n total allocations, and largest total \n memory allocation limit, or 0 if no limit \n counts of non-LIFO frees and rogue frees "
2018/06/19 20:07:37 " memory allocation routine to pass to zlib "
2018/06/19 20:07:37 " induced allocation failure "
2018/06/19 20:07:37 " perform allocation using the standard library, fill memory with a\n       non-zero value to make sure that the code isn't depending on zeros "
2018/06/19 20:07:37 " create a new item for the list "
2018/06/19 20:07:37 " insert item at the beginning of the list "
2018/06/19 20:07:37 " update the statistics "
2018/06/19 20:07:37 " return the allocated memory "
2018/06/19 20:07:37 " memory free routine to pass to zlib "
2018/06/19 20:07:37 " if no zone, just do a free "
2018/06/19 20:07:37 " point next to the item that matches ptr, or NULL if not found -- remove\n       the item from the linked list if found "
2018/06/19 20:07:37 " first one is it, remove from list "
2018/06/19 20:07:37 " search the linked list "
2018/06/19 20:07:37 " if found, remove from linked list "
2018/06/19 20:07:37 " not a LIFO free "
2018/06/19 20:07:37 " if found, update the statistics and free the item "
2018/06/19 20:07:37 " if not found, update the rogue count "
2018/06/19 20:07:37 " in any case, do the requested free with the standard library function "
2018/06/19 20:07:37 " set up a controlled memory allocation space for monitoring, set the stream\n   parameters to the controlled routines, with opaque pointing to the space "
2018/06/19 20:07:37 " set a limit on the total memory allocation, or 0 to remove the limit "
2018/06/19 20:07:37 " show the current total requested allocations in bytes "
2018/06/19 20:07:37 " show the high water allocation in bytes "
2018/06/19 20:07:37 " release the memory allocation zone -- if there are any surprises, notify "
2018/06/19 20:07:37 " show high water mark "
2018/06/19 20:07:37 " free leftover allocations and item structures, if any "
2018/06/19 20:07:37 " issue alerts about anything unexpected "
2018/06/19 20:07:37 " free the zone and delete from the stream "
2018/06/19 20:07:37 " -- inflate test routines -- "
2018/06/19 20:07:37 " Decode a hexadecimal string, set *len to length, in[] to the bytes.  This\n   decodes liberally, in that hex digits can be adjacent, in which case two in\n   a row writes a byte.  Or they can be delimited by any non-hex character,\n   where the delimiters are ignored except when a single hex digit is followed\n   by a delimiter, where that single digit writes a byte.  The returned data is\n   allocated and must eventually be freed.  NULL is returned if out of memory.\n   If the length is not needed, then len can be NULL. "
2018/06/19 20:07:37 " one digit followed by delimiter \n make it look like two digits \n have two digits \n save the decoded byte \n start over "
2018/06/19 20:07:37 " go through the loop with the terminating null "
2018/06/19 20:07:37 " generic inflate() run, where hex is the hexadecimal input data, what is the\n   text to include in an error message, step is how much input data to feed\n   inflate() on each call, or zero to feed it all, win is the window bits\n   parameter to inflateInit2(), len is the size of the output buffer, and err\n   is the error code expected from the first inflate() call (the second\n   inflate() call is expected to return Z_STREAM_END).  If win is 47, then\n   header information is collected with inflateGetHeader().  If a zlib stream\n   is looking for a dictionary, then an empty dictionary is provided.\n   inflate() is run until all of the input data is consumed. "
2018/06/19 20:07:37 " don't care next time around "
2018/06/19 20:07:37 " cover all of the lines in inflate.c up to inflate() "
2018/06/19 20:07:37 " cover all inflate() header and trailer cases and code after inflate() "
2018/06/19 20:07:37 " input and output functions for inflateBack() "
2018/06/19 20:07:37 " no input (already provided at next_in) "
2018/06/19 20:07:37 " force an otherwise impossible situation "
2018/06/19 20:07:37 " force error if desc not null "
2018/06/19 20:07:37 " cover inflateBack() up to common deflate data cases and after those "
2018/06/19 20:07:37 " force output error "
2018/06/19 20:07:37 " force mode error by mucking with state "
2018/06/19 20:07:37 " do a raw inflate of data in hexadecimal with both inflate and inflateBack "
2018/06/19 20:07:37 " convert to hex "
2018/06/19 20:07:37 " allocate work areas "
2018/06/19 20:07:37 " first with inflate "
2018/06/19 20:07:37 " then with inflateBack "
2018/06/19 20:07:37 " clean up "
2018/06/19 20:07:37 " cover deflate data cases in both inflate() and inflateBack() "
2018/06/19 20:07:37 " also trailer mismatch just in inflate() "
2018/06/19 20:07:37 " cover remaining lines in inftrees.c "
2018/06/19 20:07:37 " we need to call inflate_table() directly in order to manifest not-\n       enough errors, since zlib insures that enough is always enough "
2018/06/19 20:07:37 " cover remaining inffast.c decoding and window copying "
2018/06/19 20:07:37 Finished Classifying License "/zlib-1.2.11.tar.gz/test/infcover.c": 29.496456ms
2018/06/19 20:07:37 Couldn't classify license(s)
2018/06/19 20:07:38 Classifying license(s): /zlib-1.2.11.tar.gz/test/minigzip.c
2018/06/19 20:07:38 detected language: 4
2018/06/19 20:07:38 " minigzip.c -- simulate gzip using the zlib compression library\n * Copyright (C) 1995-2006, 2010, 2011, 2016 Jean-loup Gailly\n * For conditions of distribution and use, see copyright notice in zlib.h\n "
2018/06/19 20:07:38 "\n * minigzip is a minimal implementation of the gzip utility. This is\n * only an example of using zlib and isn't meant to replace the\n * full-featured gzip. No attempt is made to deal with file systems\n * limiting names to 14 or 8+3 characters, etc... Error checking is\n * very limited. So use minigzip only for testing; use gzip for the\n * real thing. On MSDOS, use only on file names without extension\n * or in pipe mode.\n "
2018/06/19 20:07:38 " @(#) $Id$ "
2018/06/19 20:07:38 " for fileno "
2018/06/19 20:07:38 " unlink already in stdio.h for WIN32 "
2018/06/19 20:07:38 " Map the Windows error number in ERROR to a locale-dependent error\n   message string and return a pointer to it.  Typically, the values\n   for ERROR come from GetLastError.\n\n   The string pointed to shall not be modified by the application,\n   but may be overwritten by a subsequent call to strwinerror\n\n   The strwinerror function does not change the current setting\n   of GetLastError.  "
2018/06/19 20:07:38 " Default language "
2018/06/19 20:07:38 " If there is an \\r\\n appended, zap it.  "
2018/06/19 20:07:38 " UNDER_CE "
2018/06/19 20:07:38 " Needed for systems with limitation on stack size. "
2018/06/19 20:07:38 " for Z_SOLO, create simplified gz* functions using deflate and inflate "
2018/06/19 20:07:38 " for unlink() "
2018/06/19 20:07:38 " ===========================================================================\n * Display error message and exit\n "
2018/06/19 20:07:38 " ===========================================================================\n * Compress input to output then close both files.\n "
2018/06/19 20:07:38 " Try first compressing with mmap. If mmap fails (minigzip used in a\n     * pipe), use the normal fread loop.\n     "
2018/06/19 20:07:38 " MMAP version, Miguel Albrecht <malbrech@eso.org> "
2018/06/19 20:07:38 " Try compressing the input file at once using mmap. Return Z_OK if\n * if success, Z_ERRNO otherwise.\n "
2018/06/19 20:07:38 " mmap'ed buffer for the entire input file \n length of the input file "
2018/06/19 20:07:38 " Determine the size of the file, needed for mmap: "
2018/06/19 20:07:38 " Now do the actual mmap: "
2018/06/19 20:07:38 " Compress the whole file at once: "
2018/06/19 20:07:38 " USE_MMAP "
2018/06/19 20:07:38 " ===========================================================================\n * Uncompress input to output then close both files.\n "
2018/06/19 20:07:38 " ===========================================================================\n * Compress the given file: create a corresponding .gz file and remove the\n * original.\n "
2018/06/19 20:07:38 " ===========================================================================\n * Uncompress the given file and remove the original.\n "
2018/06/19 20:07:38 " ===========================================================================\n * Usage:  minigzip [-c] [-d] [-f] [-h] [-r] [-1 to -9] [files...]\n *   -c : write to standard output\n *   -d : decompress\n *   -f : compress with Z_FILTERED\n *   -h : compress with Z_HUFFMAN_ONLY\n *   -r : compress with Z_RLE\n *   -1 to -9 : compression level\n "
2018/06/19 20:07:38 Finished Classifying License "/zlib-1.2.11.tar.gz/test/minigzip.c": 14.086335ms
2018/06/19 20:07:38 Couldn't classify license(s)
2018/06/19 20:07:39 Classifying license(s): /zlib-1.2.11.tar.gz/test/example.c
2018/06/19 20:07:39 detected language: 4
2018/06/19 20:07:39 " example.c -- usage example of the zlib compression library\n * Copyright (C) 1995-2006, 2011, 2016 Jean-loup Gailly\n * For conditions of distribution and use, see copyright notice in zlib.h\n "
2018/06/19 20:07:39 " @(#) $Id$ "
2018/06/19 20:07:39 " \"hello world\" would be more standard, but the repeated \"hello\"\n * stresses the compression code better, sorry...\n "
2018/06/19 20:07:39 " Adler32 value of the dictionary "
2018/06/19 20:07:39 " !Z_SOLO "
2018/06/19 20:07:39 " ===========================================================================\n * Test compress() and uncompress()\n "
2018/06/19 20:07:39 " ===========================================================================\n * Test read/write of .gz files\n "
2018/06/19 20:07:39 " compressed file name "
2018/06/19 20:07:39 " add one zero byte "
2018/06/19 20:07:39 " \" hello!\" "
2018/06/19 20:07:39 " Z_SOLO "
2018/06/19 20:07:39 " ===========================================================================\n * Test deflate() with small buffers\n "
2018/06/19 20:07:39 " compression stream "
2018/06/19 20:07:39 " force small buffers "
2018/06/19 20:07:39 " Finish the stream, still forcing small buffers: "
2018/06/19 20:07:39 " ===========================================================================\n * Test inflate() with small buffers\n "
2018/06/19 20:07:39 " decompression stream "
2018/06/19 20:07:39 " force small buffers "
2018/06/19 20:07:39 " ===========================================================================\n * Test deflate() with large buffers and dynamic change of compression level\n "
2018/06/19 20:07:39 " compression stream "
2018/06/19 20:07:39 " At this point, uncompr is still mostly zeroes, so it should compress\n     * very well:\n     "
2018/06/19 20:07:39 " Feed in already compressed data and switch to no compression: "
2018/06/19 20:07:39 " Switch back to compressing mode: "
2018/06/19 20:07:39 " ===========================================================================\n * Test inflate() with large buffers\n "
2018/06/19 20:07:39 " decompression stream "
2018/06/19 20:07:39 " discard the output "
2018/06/19 20:07:39 " ===========================================================================\n * Test deflate() with full flush\n "
2018/06/19 20:07:39 " compression stream "
2018/06/19 20:07:39 " force an error in first compressed block "
2018/06/19 20:07:39 " ===========================================================================\n * Test inflateSync()\n "
2018/06/19 20:07:39 " decompression stream "
2018/06/19 20:07:39 " just read the zlib header "
2018/06/19 20:07:39 " read all compressed data \n but skip the damaged part "
2018/06/19 20:07:39 " Because of incorrect adler32 "
2018/06/19 20:07:39 " ===========================================================================\n * Test deflate() with preset dictionary\n "
2018/06/19 20:07:39 " compression stream "
2018/06/19 20:07:39 " ===========================================================================\n * Test inflate() with a preset dictionary\n "
2018/06/19 20:07:39 " decompression stream "
2018/06/19 20:07:39 " ===========================================================================\n * Usage:  example [output.gz  [input.gz]]\n "
2018/06/19 20:07:39 " don't overflow on MSDOS "
2018/06/19 20:07:39 " compr and uncompr are cleared to avoid reading uninitialized\n     * data and to ensure that uncompr compresses well.\n     "
2018/06/19 20:07:39 Finished Classifying License "/zlib-1.2.11.tar.gz/test/example.c": 11.322919ms
2018/06/19 20:07:39 Couldn't classify license(s)
2018/06/19 20:07:40 Classifying license(s): /zlib-1.2.11.tar.gz/inflate.h
2018/06/19 20:07:40 detected language: 4
2018/06/19 20:07:40 " inflate.h -- internal inflate state definition\n * Copyright (C) 1995-2016 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n "
2018/06/19 20:07:40 " WARNING: this file should *not* be used by applications. It is\n   part of the implementation of the compression library and is\n   subject to change. Applications should only use zlib.h.\n "
2018/06/19 20:07:40 " define NO_GZIP when compiling if you want to disable gzip header and\n   trailer decoding by inflate().  NO_GZIP would be used to avoid linking in\n   the crc code when it is not needed.  For shared libraries, gzip decoding\n   should be left enabled. "
2018/06/19 20:07:40 " Possible inflate modes between inflate() calls "
2018/06/19 20:07:40 " i: waiting for magic header \n i: waiting for method and flags (gzip) \n i: waiting for modification time (gzip) \n i: waiting for extra flags and operating system (gzip) \n i: waiting for extra length (gzip) \n i: waiting for extra bytes (gzip) \n i: waiting for end of file name (gzip) \n i: waiting for end of comment (gzip) \n i: waiting for header crc (gzip) \n i: waiting for dictionary check value \n waiting for inflateSetDictionary() call \n i: waiting for type bits, including last-flag bit \n i: same, but skip check to exit inflate on new block \n i: waiting for stored size (length and complement) \n i/o: same as COPY below, but only first time in \n i/o: waiting for input or output to copy stored block \n i: waiting for dynamic block table lengths \n i: waiting for code length code lengths \n i: waiting for length/lit and distance code lengths \n i: same as LEN below, but only first time in \n i: waiting for length/lit/eob code \n i: waiting for length extra bits \n i: waiting for distance code \n i: waiting for distance extra bits \n o: waiting for output space to copy string \n o: waiting for output space to write literal \n i: waiting for 32-bit check value \n i: waiting for 32-bit length (gzip) \n finished check, done -- remain here until reset \n got a data error -- remain here until reset \n got an inflate() memory error -- remain here until reset \n looking for synchronization bytes to restart inflate() "
2018/06/19 20:07:40 "\n    State transitions between above modes -\n\n    (most modes can go to BAD or MEM on error -- not shown for clarity)\n\n    Process header:\n        HEAD -> (gzip) or (zlib) or (raw)\n        (gzip) -> FLAGS -> TIME -> OS -> EXLEN -> EXTRA -> NAME -> COMMENT ->\n                  HCRC -> TYPE\n        (zlib) -> DICTID or TYPE\n        DICTID -> DICT -> TYPE\n        (raw) -> TYPEDO\n    Read deflate blocks:\n            TYPE -> TYPEDO -> STORED or TABLE or LEN_ or CHECK\n            STORED -> COPY_ -> COPY -> TYPE\n            TABLE -> LENLENS -> CODELENS -> LEN_\n            LEN_ -> LEN\n    Read deflate codes in fixed or dynamic block:\n                LEN -> LENEXT or LIT or TYPE\n                LENEXT -> DIST -> DISTEXT -> MATCH -> LEN\n                LIT -> LEN\n    Process trailer:\n        CHECK -> LENGTH -> DONE\n "
2018/06/19 20:07:40 " State maintained between inflate() calls -- approximately 7K bytes, not\n   including the allocated sliding window, which is up to 32K bytes. "
2018/06/19 20:07:40 " pointer back to this zlib stream \n current inflate mode \n true if processing last block \n bit 0 true for zlib, bit 1 true for gzip,\n                                   bit 2 true to validate check value "
2018/06/19 20:07:40 " true if dictionary provided \n gzip header method and flags (0 if zlib) \n zlib header max distance (INFLATE_STRICT) \n protected copy of check value \n protected copy of output count \n where to save gzip header information \n sliding window \n log base 2 of requested window size \n window size or zero if not using window \n valid bytes in the window \n window write index \n allocated sliding window, if needed \n bit accumulator \n input bit accumulator \n number of bits in \"in\" \n for string and stored block copying \n literal or length of data to copy \n distance back to copy string from \n for table and code decoding \n extra bits needed \n fixed and dynamic code tables \n starting table for length/literal codes \n starting table for distance codes \n index bits for lencode \n index bits for distcode \n dynamic table building \n number of code length code lengths \n number of length code lengths \n number of distance code lengths \n number of code lengths in lens[] \n next available space in codes[] \n temporary storage for code lengths \n work area for code table building \n space for code tables \n if false, allow invalid distance too far \n bits back of last unprocessed length/lit \n initial length of match "
2018/06/19 20:07:40 Finished Classifying License "/zlib-1.2.11.tar.gz/inflate.h": 21.250429ms
2018/06/19 20:07:40 Couldn't classify license(s)
2018/06/19 20:07:40 Classifying license(s): /zlib-1.2.11.tar.gz/watcom/watcom_f.mak
2018/06/19 20:07:40 Finished Classifying License "/zlib-1.2.11.tar.gz/watcom/watcom_f.mak": 2.686415ms
2018/06/19 20:07:40 Couldn't classify license(s)
2018/06/19 20:07:41 Classifying license(s): /zlib-1.2.11.tar.gz/watcom/watcom_l.mak
2018/06/19 20:07:41 Finished Classifying License "/zlib-1.2.11.tar.gz/watcom/watcom_l.mak": 2.760455ms
2018/06/19 20:07:41 Couldn't classify license(s)
2018/06/19 20:07:42 Classifying license(s): /zlib-1.2.11.tar.gz/zconf.h.in
2018/06/19 20:07:42 Finished Classifying License "/zlib-1.2.11.tar.gz/zconf.h.in": 46.047079ms
2018/06/19 20:07:42 Couldn't classify license(s)
2018/06/19 20:07:43 Classifying license(s): /zlib-1.2.11.tar.gz/nintendods/Makefile
2018/06/19 20:07:43 Finished Classifying License "/zlib-1.2.11.tar.gz/nintendods/Makefile": 11.14881ms
2018/06/19 20:07:43 Couldn't classify license(s)
2018/06/19 20:07:44 Classifying license(s): /zlib-1.2.11.tar.gz/nintendods/README
2018/06/19 20:07:44 Finished Classifying License "/zlib-1.2.11.tar.gz/nintendods/README": 779.534µs
2018/06/19 20:07:44 Couldn't classify license(s)
2018/06/19 20:07:44 Classifying license(s): /zlib-1.2.11.tar.gz/deflate.c
2018/06/19 20:07:44 detected language: 4
2018/06/19 20:07:44 " deflate.c -- compress data using the deflation algorithm\n * Copyright (C) 1995-2017 Jean-loup Gailly and Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n "
2018/06/19 20:07:44 "\n *  ALGORITHM\n *\n *      The \"deflation\" process depends on being able to identify portions\n *      of the input text which are identical to earlier input (within a\n *      sliding window trailing behind the input currently being processed).\n *\n *      The most straightforward technique turns out to be the fastest for\n *      most input files: try all possible matches and select the longest.\n *      The key feature of this algorithm is that insertions into the string\n *      dictionary are very simple and thus fast, and deletions are avoided\n *      completely. Insertions are performed at each input character, whereas\n *      string matches are performed only when the previous match ends. So it\n *      is preferable to spend more time in matches to allow very fast string\n *      insertions and avoid deletions. The matching algorithm for small\n *      strings is inspired from that of Rabin & Karp. A brute force approach\n *      is used to find longer strings when a small match has been found.\n *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze\n *      (by Leonid Broukhis).\n *         A previous version of this file used a more sophisticated algorithm\n *      (by Fiala and Greene) which is guaranteed to run in linear amortized\n *      time, but has a larger average cost, uses more memory and is patented.\n *      However the F&G algorithm may be faster for some highly redundant\n *      files if the parameter max_chain_length (described below) is too large.\n *\n *  ACKNOWLEDGEMENTS\n *\n *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and\n *      I found it in 'freeze' written by Leonid Broukhis.\n *      Thanks to many people for bug reports and testing.\n *\n *  REFERENCES\n *\n *      Deutsch, L.P.,\"DEFLATE Compressed Data Format Specification\".\n *      Available in http://tools.ietf.org/html/rfc1951\n *\n *      A description of the Rabin and Karp algorithm is given in the book\n *         \"Algorithms\" by R. Sedgewick, Addison-Wesley, p252.\n *\n *      Fiala,E.R., and Greene,D.H.\n *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595\n *\n "
2018/06/19 20:07:44 " @(#) $Id$ "
2018/06/19 20:07:44 "\n  If you use the zlib library in a product, an acknowledgment is welcome\n  in the documentation of your product. If for some reason you cannot\n  include such an acknowledgment, I would appreciate that you keep this\n  copyright string in the executable of your product.\n "
2018/06/19 20:07:44 " ===========================================================================\n *  Function prototypes.\n "
2018/06/19 20:07:44 " block not completed, need more input or more output \n block flush performed \n finish started, need only more output at next deflate \n finish done, accept no more input or output "
2018/06/19 20:07:44 " Compression function. Returns the block state after the call. "
2018/06/19 20:07:44 " asm code initialization "
2018/06/19 20:07:44 " ===========================================================================\n * Local data\n "
2018/06/19 20:07:44 " Tail of hash chains "
2018/06/19 20:07:44 " Matches of length 3 are discarded if their distance exceeds TOO_FAR "
2018/06/19 20:07:44 " Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n "
2018/06/19 20:07:44 " reduce lazy search above this match length \n do not perform lazy search above this match length \n quit search above this match length "
2018/06/19 20:07:44 "      good lazy nice chain \n 0 \n store only \n 1 \n max speed, no lazy matches "
2018/06/19 20:07:44 "      good lazy nice chain \n 0 \n store only \n 1 \n max speed, no lazy matches \n 2 \n 3 "
2018/06/19 20:07:44 " 4 \n lazy matches \n 5 \n 6 \n 7 \n 8 \n 9 \n max compression "
2018/06/19 20:07:44 " Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4\n * For deflate_fast() (levels <= 3) good is ignored and lazy has a different\n * meaning.\n "
2018/06/19 20:07:44 " rank Z_BLOCK between Z_NO_FLUSH and Z_PARTIAL_FLUSH "
2018/06/19 20:07:44 " ===========================================================================\n * Update a hash value with the given input byte\n * IN  assertion: all calls to UPDATE_HASH are made with consecutive input\n *    characters, so that a running hash key can be computed from the previous\n *    key instead of complete recalculation each time.\n "
2018/06/19 20:07:44 " ===========================================================================\n * Insert string str in the dictionary and set match_head to the previous head\n * of the hash chain (the most recent string with same hash key). Return\n * the previous length of the hash chain.\n * If this file is compiled with -DFASTEST, the compression level is forced\n * to 1, and no hash chains are maintained.\n * IN  assertion: all calls to INSERT_STRING are made with consecutive input\n *    characters and the first MIN_MATCH bytes of str are valid (except for\n *    the last MIN_MATCH-1 bytes of the input file).\n "
2018/06/19 20:07:44 " ===========================================================================\n * Initialize the hash table (avoiding 64K overflow for 16 bit systems).\n * prev[] will be initialized on the fly.\n "
2018/06/19 20:07:44 " ===========================================================================\n * Slide the hash table when sliding the window down (could be avoided with 32\n * bit values at the expense of memory usage). We slide even when level == 0 to\n * keep the hash table consistent if we switch back to level > 0 later.\n "
2018/06/19 20:07:44 " If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         "
2018/06/19 20:07:44 " ========================================================================= "
2018/06/19 20:07:44 " To do: ignore strm->next_in if we use it as window "
2018/06/19 20:07:44 " ========================================================================= "
2018/06/19 20:07:44 " We overlay pending_buf and d_buf+l_buf. This works since the average\n     * output size for (length,distance) codes is <= 24 bits.\n     "
2018/06/19 20:07:44 " suppress zlib wrapper "
2018/06/19 20:07:44 " write gzip wrapper instead "
2018/06/19 20:07:44 " until 256-byte window bug fixed "
2018/06/19 20:07:44 " to pass state test in deflateReset() "
2018/06/19 20:07:44 " nothing written to s->window yet "
2018/06/19 20:07:44 " 16K elements by default "
2018/06/19 20:07:44 " =========================================================================\n * Check for a valid deflate stream state. Return 0 if ok, 1 if not.\n "
2018/06/19 20:07:44 " ========================================================================= "
2018/06/19 20:07:44 " when using zlib wrappers, compute Adler-32 for provided dictionary "
2018/06/19 20:07:44 " avoid computing Adler-32 in read_buf "
2018/06/19 20:07:44 " if dictionary would fill window, just replace the history "
2018/06/19 20:07:44 " already empty otherwise "
2018/06/19 20:07:44 " use the tail "
2018/06/19 20:07:44 " insert dictionary into window and hash "
2018/06/19 20:07:44 " ========================================================================= "
2018/06/19 20:07:44 " ========================================================================= "
2018/06/19 20:07:44 " use zfree if we ever allocate msg dynamically "
2018/06/19 20:07:44 " was made negative by deflate(..., Z_FINISH); "
2018/06/19 20:07:44 " ========================================================================= "
2018/06/19 20:07:44 " ========================================================================= "
2018/06/19 20:07:44 " ========================================================================= "
2018/06/19 20:07:44 " ========================================================================= "
2018/06/19 20:07:44 " ========================================================================= "
2018/06/19 20:07:44 " Flush the last buffer: "
2018/06/19 20:07:44 " ========================================================================= "
2018/06/19 20:07:44 " =========================================================================\n * For the default windowBits of 15 and memLevel of 8, this function returns\n * a close to exact, as well as small, upper bound on the compressed size.\n * They are coded as constants here for a reason--if the #define's are\n * changed, then this function needs to be changed as well.  The return\n * value for 15 and 8 only works for those exact settings.\n *\n * For any setting other than those defaults for windowBits and memLevel,\n * the value returned is a conservative worst case for the maximum expansion\n * resulting from using fixed blocks instead of stored blocks, which deflate\n * can emit on compressed data for some combinations of the parameters.\n *\n * This function could be more sophisticated to provide closer upper bounds for\n * every combination of windowBits and memLevel.  But even the conservative\n * upper bound of about 14% expansion does not seem onerous for output buffer\n * allocation.\n "
2018/06/19 20:07:44 " conservative upper bound for compressed data "
2018/06/19 20:07:44 " if can't get parameters, return conservative bound plus zlib wrapper "
2018/06/19 20:07:44 " compute wrapper length "
2018/06/19 20:07:44 " raw deflate "
2018/06/19 20:07:44 " zlib wrapper "
2018/06/19 20:07:44 " gzip wrapper "
2018/06/19 20:07:44 " user-supplied gzip header "
2018/06/19 20:07:44 " for compiler happiness "
2018/06/19 20:07:44 " if not default parameters, return conservative bound "
2018/06/19 20:07:44 " default settings: return tight bound for that case "
2018/06/19 20:07:44 " =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n "
2018/06/19 20:07:44 " =========================================================================\n * Flush as much pending output as possible. All deflate() output, except for\n * some deflate_stored() output, goes through this function so some\n * applications may wish to modify it to avoid allocating a large\n * strm->next_out buffer and copying into it. (See also read_buf()).\n "
2018/06/19 20:07:44 " ===========================================================================\n * Update the header CRC with the bytes s->pending_buf[beg..s->pending - 1].\n "
2018/06/19 20:07:44 " ========================================================================= "
2018/06/19 20:07:44 " value of flush param for previous deflate call "
2018/06/19 20:07:44 " Flush as much pending output as possible "
2018/06/19 20:07:44 " Since avail_out is 0, deflate will be called again with\n             * more output space, but possibly with both pending and\n             * avail_in equal to zero. There won't be anything to do,\n             * but this is not an error situation so make sure we\n             * return OK instead of BUF_ERROR at next call of deflate:\n             "
2018/06/19 20:07:44 " Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     "
2018/06/19 20:07:44 " User must not provide more input after the first FINISH: "
2018/06/19 20:07:44 " Write the header "
2018/06/19 20:07:44 " zlib header "
2018/06/19 20:07:44 " Save the adler32 of the preset dictionary: "
2018/06/19 20:07:44 " Compression must start with an empty pending buffer "
2018/06/19 20:07:44 " gzip header "
2018/06/19 20:07:44 " Compression must start with an empty pending buffer "
2018/06/19 20:07:44 " start of bytes to update crc "
2018/06/19 20:07:44 " start of bytes to update crc "
2018/06/19 20:07:44 " start of bytes to update crc "
2018/06/19 20:07:44 " Compression must start with an empty pending buffer "
2018/06/19 20:07:44 " Start a new block or continue the current one.\n     "
2018/06/19 20:07:44 " avoid BUF_ERROR next call, see above "
2018/06/19 20:07:44 " If flush != Z_NO_FLUSH && avail_out == 0, the next call\n             * of deflate should use the same flush parameter to make sure\n             * that the flush is complete. So we don't have to output an\n             * empty block here, this will be done at next call. This also\n             * ensures that for a very small output buffer, we emit at most\n             * one empty block.\n             "
2018/06/19 20:07:44 " FULL_FLUSH or SYNC_FLUSH "
2018/06/19 20:07:44 " For a full flush, this empty block will be recognized\n                 * as a special marker by inflate_sync().\n                 "
2018/06/19 20:07:44 " forget history "
2018/06/19 20:07:44 " avoid BUF_ERROR at next call, see above "
2018/06/19 20:07:44 " Write the trailer "
2018/06/19 20:07:44 " If avail_out is zero, the application will call deflate again\n     * to flush the rest.\n     "
2018/06/19 20:07:44 " write the trailer only once! "
2018/06/19 20:07:44 " ========================================================================= "
2018/06/19 20:07:44 " Deallocate in reverse order of allocations: "
2018/06/19 20:07:44 " =========================================================================\n * Copy the source state to the destination state.\n * To simplify the source, this is not supported for 16-bit MSDOS (which\n * doesn't have enough memory anyway to duplicate compression states).\n "
2018/06/19 20:07:44 " following zmemcpy do not work for 16-bit MSDOS "
2018/06/19 20:07:44 " MAXSEG_64K "
2018/06/19 20:07:44 " ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->next_in buffer and copying from it.\n * (See also flush_pending()).\n "
2018/06/19 20:07:44 " ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n "
2018/06/19 20:07:44 " Set the default configuration parameters:\n     "
2018/06/19 20:07:44 " initialize the asm code "
2018/06/19 20:07:44 " ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n "
2018/06/19 20:07:44 " For 80x86 and 680x0, an optimized version will be provided in match.asm or\n * match.S. The code will be functionally equivalent.\n "
2018/06/19 20:07:44 " current match "
2018/06/19 20:07:44 " max hash chain length \n current string \n matched string \n length of current match \n best match length so far \n stop if match long enough "
2018/06/19 20:07:44 " Stop when cur_match becomes <= limit. To simplify the code,\n     * we prevent matches with the string of window index 0.\n     "
2018/06/19 20:07:44 " Compare two bytes at a time. Note: this is not always beneficial.\n     * Try with and without -DUNALIGNED_OK to check.\n     "
2018/06/19 20:07:44 " The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n     * It is easy to get rid of this optimization if necessary.\n     "
2018/06/19 20:07:44 " Do not waste too much time if we already have a good match: "
2018/06/19 20:07:44 " Do not look for matches beyond the end of the input. This is necessary\n     * to make deflate deterministic.\n     "
2018/06/19 20:07:44 " Skip to next match if the match length cannot increase\n         * or if the match length is less than 2.  Note that the checks below\n         * for insufficient lookahead only occur occasionally for performance\n         * reasons.  Therefore uninitialized memory will be accessed, and\n         * conditional jumps will be made that depend on those values.\n         * However the length of the match is limited to the lookahead, so\n         * the output of deflate is not affected by the uninitialized values.\n         "
2018/06/19 20:07:44 " This code assumes sizeof(unsigned short) == 2. Do not use\n         * UNALIGNED_OK if your compiler uses a different size.\n         "
2018/06/19 20:07:44 " It is not necessary to compare scan[2] and match[2] since they are\n         * always equal when the other bytes match, given that the hash keys\n         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at\n         * strstart+3, +5, ... up to strstart+257. We check for insufficient\n         * lookahead only every 4th comparison; the 128th check will be made\n         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is\n         * necessary to put more guard bytes at the end of the window, or\n         * to check more often for insufficient lookahead.\n         "
2018/06/19 20:07:44 " The funny \"do {}\" generates better code on most compilers "
2018/06/19 20:07:44 " Here, scan <= window+strstart+257 "
2018/06/19 20:07:44 " UNALIGNED_OK "
2018/06/19 20:07:44 " The check at best_len-1 can be removed because it will be made\n         * again later. (This heuristic is not always a win.)\n         * It is not necessary to compare scan[2] and match[2] since they\n         * are always equal when the other bytes match, given that\n         * the hash keys are equal and that HASH_BITS >= 8.\n         "
2018/06/19 20:07:44 " We check for insufficient lookahead only every 8th comparison;\n         * the 256th check will be made at strstart+258.\n         "
2018/06/19 20:07:44 " UNALIGNED_OK "
2018/06/19 20:07:44 " ASMV "
2018/06/19 20:07:44 " FASTEST "
2018/06/19 20:07:44 " ---------------------------------------------------------------------------\n * Optimized version for FASTEST only\n "
2018/06/19 20:07:44 " current match "
2018/06/19 20:07:44 " current string \n matched string \n length of current match "
2018/06/19 20:07:44 " The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n     * It is easy to get rid of this optimization if necessary.\n     "
2018/06/19 20:07:44 " Return failure if the match length is less than 2:\n     "
2018/06/19 20:07:44 " The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     "
2018/06/19 20:07:44 " We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     "
2018/06/19 20:07:44 " FASTEST "
2018/06/19 20:07:44 " result of memcmp for equal strings "
2018/06/19 20:07:44 " ===========================================================================\n * Check that the match at match_start is indeed a match.\n "
2018/06/19 20:07:44 " check that the match is indeed a match "
2018/06/19 20:07:44 " ZLIB_DEBUG "
2018/06/19 20:07:44 " ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n "
2018/06/19 20:07:44 " Amount of free space at the end of the window. "
2018/06/19 20:07:44 " Deal with !@#$% 64K limit: "
2018/06/19 20:07:44 " Very unlikely, but possible on 16 bit machine if\n                 * strstart == 0 && lookahead == 1 (input done a byte at time)\n                 "
2018/06/19 20:07:44 " If the window is almost full and there is insufficient lookahead,\n         * move the upper half to the lower one to make room in the upper half.\n         "
2018/06/19 20:07:44 " we now have strstart >= MAX_DIST "
2018/06/19 20:07:44 " If there was no sliding:\n         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n         *    more == window_size - lookahead - strstart\n         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n         * => more >= window_size - 2*WSIZE + 2\n         * In the BIG_MEM or MMAP case (not yet supported),\n         *   window_size == input_size + MIN_LOOKAHEAD  &&\n         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n         * Otherwise, window_size == 2*WSIZE so more >= 2.\n         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n         "
2018/06/19 20:07:44 " Initialize the hash value now that we have some input: "
2018/06/19 20:07:44 " If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n         * but this is not important since only literal bytes will be emitted.\n         "
2018/06/19 20:07:44 " If the WIN_INIT bytes after the end of the current data have never been\n     * written, then zero those bytes in order to avoid memory check reports of\n     * the use of uninitialized (or uninitialised as Julian writes) bytes by\n     * the longest match routines.  Update the high water mark for the next\n     * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n     * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n     "
2018/06/19 20:07:44 " Previous high water mark below current data -- zero WIN_INIT\n             * bytes or up to end of window, whichever is less.\n             "
2018/06/19 20:07:44 " High water mark at or above current data, but below current data\n             * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n             * to end of window, whichever is less.\n             "
2018/06/19 20:07:44 " ===========================================================================\n * Flush the current block, with given end-of-file flag.\n * IN assertion: strstart is set to the end of the current match.\n "
2018/06/19 20:07:44 " Same but force premature exit if necessary. "
2018/06/19 20:07:44 " Maximum stored block length in deflate format (not including header). "
2018/06/19 20:07:44 " Minimum of a and b. "
2018/06/19 20:07:44 " ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n *\n * In case deflateParams() is used to later switch to a non-zero compression\n * level, s->matches (otherwise unused when storing) keeps track of the number\n * of hash table slides to perform. If s->matches is 1, then one hash table\n * slide will be done when switching. If s->matches is 2, the maximum value\n * allowed here, then the hash table will be cleared, since two or more slides\n * is the same as a clear.\n *\n * deflate_stored() is written to minimize the number of times an input byte is\n * copied. It is most efficient with large input and output buffers, which\n * maximizes the opportunites to have a single copy from next_in to next_out.\n "
2018/06/19 20:07:44 " Smallest worthy block size when not flushing or finishing. By default\n     * this is 32K. This can be as small as 507 bytes for memLevel == 1. For\n     * large input and output buffers, the stored block size will be larger.\n     "
2018/06/19 20:07:44 " Copy as many min_block or larger stored blocks directly to next_out as\n     * possible. If flushing, copy the remaining available input to next_out as\n     * stored blocks, if there is enough space.\n     "
2018/06/19 20:07:44 " Set len to the maximum size block that we can copy directly with the\n         * available input data and output space. Set left to how much of that\n         * would be copied from what's left in the window.\n         "
2018/06/19 20:07:44 " maximum deflate stored block length \n number of header bytes \n need room for header "
2018/06/19 20:07:44 " maximum stored block length that will fit in avail_out: "
2018/06/19 20:07:44 " bytes left in window "
2018/06/19 20:07:44 " limit len to the input "
2018/06/19 20:07:44 " limit len to the output "
2018/06/19 20:07:44 " If the stored block would be less than min_block in length, or if\n         * unable to copy all of the available input when flushing, then try\n         * copying to the window and the pending buffer instead. Also don't\n         * write an empty block when flushing -- deflate() does that.\n         "
2018/06/19 20:07:44 " Make a dummy stored block in pending to get the header bytes,\n         * including any pending bits. This also updates the debugging counts.\n         "
2018/06/19 20:07:44 " Replace the lengths in the dummy stored block with len. "
2018/06/19 20:07:44 " Write the stored block header bytes. "
2018/06/19 20:07:44 " Update debugging counts for the data about to be copied. "
2018/06/19 20:07:44 " Copy uncompressed bytes from the window to next_out. "
2018/06/19 20:07:44 " Copy uncompressed bytes directly from next_in to next_out, updating\n         * the check value.\n         "
2018/06/19 20:07:44 " Update the sliding window with the last s->w_size bytes of the copied\n     * data, or append all of the copied data to the existing window if less\n     * than s->w_size bytes were copied. Also update the number of bytes to\n     * insert in the hash tables, in the event that deflateParams() switches to\n     * a non-zero compression level.\n     "
2018/06/19 20:07:44 " number of input bytes directly copied "
2018/06/19 20:07:44 " If any input was used, then no unused input remains in the window,\n         * therefore s->block_start == s->strstart.\n         "
2018/06/19 20:07:44 " supplant the previous history \n clear hash "
2018/06/19 20:07:44 " Slide the window down. "
2018/06/19 20:07:44 " add a pending slide_hash() "
2018/06/19 20:07:44 " If the last block was written to next_out, then done. "
2018/06/19 20:07:44 " If flushing and all input has been consumed, then done. "
2018/06/19 20:07:44 " Fill the window with any remaining input. "
2018/06/19 20:07:44 " Slide the window down. "
2018/06/19 20:07:44 " add a pending slide_hash() \n more space now "
2018/06/19 20:07:44 " There was not enough avail_out to write a complete worthy or flushed\n     * stored block to next_out. Write a stored block to pending instead, if we\n     * have enough input for a worthy block, or if flushing and there is enough\n     * room for the remaining input as a stored block in the pending buffer.\n     "
2018/06/19 20:07:44 " number of header bytes \n maximum stored block length that will fit in pending: "
2018/06/19 20:07:44 " We've done all we can with the available input and output. "
2018/06/19 20:07:44 " ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n "
2018/06/19 20:07:44 " head of the hash chain \n set if current block must be flushed "
2018/06/19 20:07:44 " Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the next match, plus MIN_MATCH bytes to insert the\n         * string following the next match.\n         "
2018/06/19 20:07:44 " flush the current block "
2018/06/19 20:07:44 " Insert the string window[strstart .. strstart+2] in the\n         * dictionary, and set hash_head to the head of the hash chain:\n         "
2018/06/19 20:07:44 " Find the longest match, discarding those <= prev_length.\n         * At this point we have always match_length < MIN_MATCH\n         "
2018/06/19 20:07:44 " To simplify the code, we prevent matches with the string\n             * of window index 0 (in particular we have to avoid a match\n             * of the string with itself at the start of the input file).\n             "
2018/06/19 20:07:44 " longest_match() sets match_start "
2018/06/19 20:07:44 " Insert new strings in the hash table only if the match length\n             * is not too large. This saves time but degrades compression.\n             "
2018/06/19 20:07:44 " string at strstart already in table "
2018/06/19 20:07:44 " strstart never exceeds WSIZE-MAX_MATCH, so there are\n                     * always MIN_MATCH bytes ahead.\n                     "
2018/06/19 20:07:44 " If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n                 * matter since it will be recomputed at next deflate call.\n                 "
2018/06/19 20:07:44 " No match, output a literal byte "
2018/06/19 20:07:44 " ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n "
2018/06/19 20:07:44 " head of hash chain \n set if current block must be flushed "
2018/06/19 20:07:44 " Process the input block. "
2018/06/19 20:07:44 " Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the next match, plus MIN_MATCH bytes to insert the\n         * string following the next match.\n         "
2018/06/19 20:07:44 " flush the current block "
2018/06/19 20:07:44 " Insert the string window[strstart .. strstart+2] in the\n         * dictionary, and set hash_head to the head of the hash chain:\n         "
2018/06/19 20:07:44 " Find the longest match, discarding those <= prev_length.\n         "
2018/06/19 20:07:44 " To simplify the code, we prevent matches with the string\n             * of window index 0 (in particular we have to avoid a match\n             * of the string with itself at the start of the input file).\n             "
2018/06/19 20:07:44 " longest_match() sets match_start "
2018/06/19 20:07:44 " If prev_match is also MIN_MATCH, match_start is garbage\n                 * but we will ignore the current match anyway.\n                 "
2018/06/19 20:07:44 " If there was a match at the previous step and the current\n         * match is not better, output the previous match:\n         "
2018/06/19 20:07:44 " Do not insert strings in hash table beyond this. "
2018/06/19 20:07:44 " Insert in hash table all strings up to the end of the match.\n             * strstart-1 and strstart are already inserted. If there is not\n             * enough lookahead, the last two strings are not inserted in\n             * the hash table.\n             "
2018/06/19 20:07:44 " If there was no match at the previous position, output a\n             * single literal. If there was a match but the current match\n             * is longer, truncate the previous match to a single literal.\n             "
2018/06/19 20:07:44 " There is no previous match to compare with, wait for\n             * the next step to decide.\n             "
2018/06/19 20:07:44 " FASTEST "
2018/06/19 20:07:44 " ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n "
2018/06/19 20:07:44 " set if current block must be flushed \n byte at distance one to match \n scan goes up to strend for length of run "
2018/06/19 20:07:44 " Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the longest run, plus one for the unrolled loop.\n         "
2018/06/19 20:07:44 " flush the current block "
2018/06/19 20:07:44 " See how many times the previous byte repeats "
2018/06/19 20:07:44 " Emit match if have run of MIN_MATCH or longer, else emit literal "
2018/06/19 20:07:44 " No match, output a literal byte "
2018/06/19 20:07:44 " ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n "
2018/06/19 20:07:44 " set if current block must be flushed "
2018/06/19 20:07:44 " Make sure that we have a literal to write. "
2018/06/19 20:07:44 " flush the current block "
2018/06/19 20:07:44 " Output a literal byte "
2018/06/19 20:07:44 Finished Classifying License "/zlib-1.2.11.tar.gz/deflate.c": 91.106964ms
2018/06/19 20:07:44 Couldn't classify license(s)
2018/06/19 20:07:45 Classifying license(s): /zlib-1.2.11.tar.gz/zlib.pc.in
2018/06/19 20:07:45 Finished Classifying License "/zlib-1.2.11.tar.gz/zlib.pc.in": 5.91452ms
2018/06/19 20:07:45 Couldn't classify license(s)
2018/06/19 20:07:46 Classifying license(s): /zlib-1.2.11.tar.gz/trees.h
2018/06/19 20:07:46 detected language: 4
2018/06/19 20:07:46 " header created automatically with -DGEN_TREES_H "
2018/06/19 20:07:46 Finished Classifying License "/zlib-1.2.11.tar.gz/trees.h": 1.295685ms
2018/06/19 20:07:46 Couldn't classify license(s)
2018/06/19 20:07:47 Classifying license(s): /zlib-1.2.11.tar.gz/ChangeLog
2018/06/19 20:07:47 Finished Classifying License "/zlib-1.2.11.tar.gz/ChangeLog": 316.215022ms
2018/06/19 20:07:47 Couldn't classify license(s)
2018/06/19 20:07:48 Classifying license(s): /zlib-1.2.11.tar.gz/old/visual-basic.txt
2018/06/19 20:07:48 Finished Classifying License "/zlib-1.2.11.tar.gz/old/visual-basic.txt": 23.929873ms
2018/06/19 20:07:48 Couldn't classify license(s)
2018/06/19 20:07:49 Classifying license(s): /zlib-1.2.11.tar.gz/old/os2/zlib.def
2018/06/19 20:07:49 Finished Classifying License "/zlib-1.2.11.tar.gz/old/os2/zlib.def": 6.883247ms
2018/06/19 20:07:49 Couldn't classify license(s)
2018/06/19 20:07:49 Classifying license(s): /zlib-1.2.11.tar.gz/old/os2/Makefile.os2
2018/06/19 20:07:49 Finished Classifying License "/zlib-1.2.11.tar.gz/old/os2/Makefile.os2": 16.324638ms
2018/06/19 20:07:49 Couldn't classify license(s)
2018/06/19 20:07:50 Classifying license(s): /zlib-1.2.11.tar.gz/old/Makefile.riscos
2018/06/19 20:07:50 Finished Classifying License "/zlib-1.2.11.tar.gz/old/Makefile.riscos": 7.434549ms
2018/06/19 20:07:50 Couldn't classify license(s)
2018/06/19 20:07:51 Classifying license(s): /zlib-1.2.11.tar.gz/old/Makefile.emx
2018/06/19 20:07:51 Finished Classifying License "/zlib-1.2.11.tar.gz/old/Makefile.emx": 2.804753ms
2018/06/19 20:07:51 Couldn't classify license(s)
2018/06/19 20:07:52 Classifying license(s): /zlib-1.2.11.tar.gz/old/descrip.mms
2018/06/19 20:07:52 Finished Classifying License "/zlib-1.2.11.tar.gz/old/descrip.mms": 2.977116ms
2018/06/19 20:07:52 Couldn't classify license(s)
2018/06/19 20:07:53 Classifying license(s): /zlib-1.2.11.tar.gz/old/README
2018/06/19 20:07:53 Finished Classifying License "/zlib-1.2.11.tar.gz/old/README": 622.736µs
2018/06/19 20:07:53 Couldn't classify license(s)
2018/06/19 20:07:53 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc9/zlibvc.def
2018/06/19 20:07:53 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc9/zlibvc.def": 18.638872ms
2018/06/19 20:07:53 Couldn't classify license(s)
2018/06/19 20:07:54 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc9/zlibvc.sln
2018/06/19 20:07:54 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc9/zlibvc.sln": 36.97945ms
2018/06/19 20:07:54 Couldn't classify license(s)
2018/06/19 20:07:55 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc9/testzlib.vcproj
2018/06/19 20:07:55 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc9/testzlib.vcproj": 55.500455ms
2018/06/19 20:07:55 Couldn't classify license(s)
2018/06/19 20:07:56 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc9/minizip.vcproj
2018/06/19 20:07:56 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc9/minizip.vcproj": 37.880671ms
2018/06/19 20:07:56 Couldn't classify license(s)
2018/06/19 20:07:57 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc9/zlibvc.vcproj
2018/06/19 20:07:57 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc9/zlibvc.vcproj": 87.833699ms
2018/06/19 20:07:57 Couldn't classify license(s)
2018/06/19 20:07:57 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc9/zlibstat.vcproj
2018/06/19 20:07:58 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc9/zlibstat.vcproj": 55.419329ms
2018/06/19 20:07:58 Couldn't classify license(s)
2018/06/19 20:07:58 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc9/testzlibdll.vcproj
2018/06/19 20:07:58 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc9/testzlibdll.vcproj": 37.997678ms
2018/06/19 20:07:58 Couldn't classify license(s)
2018/06/19 20:07:59 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc9/zlib.rc
2018/06/19 20:07:59 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc9/zlib.rc": 2.047408ms
2018/06/19 20:07:59 Couldn't classify license(s)
2018/06/19 20:08:00 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc9/miniunz.vcproj
2018/06/19 20:08:00 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc9/miniunz.vcproj": 39.822238ms
2018/06/19 20:08:00 Couldn't classify license(s)
2018/06/19 20:08:01 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/readme.txt
2018/06/19 20:08:01 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/readme.txt": 12.933585ms
2018/06/19 20:08:01 Couldn't classify license(s)
2018/06/19 20:08:02 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc10/testzlib.vcxproj.filters
2018/06/19 20:08:02 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc10/testzlib.vcxproj.filters": 10.540691ms
2018/06/19 20:08:02 Couldn't classify license(s)
2018/06/19 20:08:02 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc10/minizip.vcxproj
2018/06/19 20:08:02 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc10/minizip.vcxproj": 58.550755ms
2018/06/19 20:08:02 Couldn't classify license(s)
2018/06/19 20:08:03 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc10/testzlib.vcxproj
2018/06/19 20:08:03 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc10/testzlib.vcxproj": 86.761375ms
2018/06/19 20:08:03 Couldn't classify license(s)
2018/06/19 20:08:04 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc10/zlibvc.vcxproj
2018/06/19 20:08:04 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc10/zlibvc.vcxproj": 136.630945ms
2018/06/19 20:08:04 Couldn't classify license(s)
2018/06/19 20:08:05 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc10/zlibvc.def
2018/06/19 20:08:05 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc10/zlibvc.def": 18.043241ms
2018/06/19 20:08:05 Couldn't classify license(s)
2018/06/19 20:08:06 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc10/zlibvc.sln
2018/06/19 20:08:06 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc10/zlibvc.sln": 35.711743ms
2018/06/19 20:08:06 Couldn't classify license(s)
2018/06/19 20:08:06 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc10/testzlibdll.vcxproj.filters
2018/06/19 20:08:07 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc10/testzlibdll.vcxproj.filters": 7.584152ms
2018/06/19 20:08:07 Couldn't classify license(s)
2018/06/19 20:08:07 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc10/minizip.vcxproj.filters
2018/06/19 20:08:07 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc10/minizip.vcxproj.filters": 8.256379ms
2018/06/19 20:08:07 Couldn't classify license(s)
2018/06/19 20:08:08 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc10/miniunz.vcxproj
2018/06/19 20:08:08 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc10/miniunz.vcxproj": 58.118562ms
2018/06/19 20:08:08 Couldn't classify license(s)
2018/06/19 20:08:09 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc10/testzlibdll.vcxproj
2018/06/19 20:08:09 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc10/testzlibdll.vcxproj": 54.557635ms
2018/06/19 20:08:09 Couldn't classify license(s)
2018/06/19 20:08:10 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc10/zlibstat.vcxproj.filters
2018/06/19 20:08:10 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc10/zlibstat.vcxproj.filters": 11.257129ms
2018/06/19 20:08:10 Couldn't classify license(s)
2018/06/19 20:08:10 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc10/zlibstat.vcxproj
2018/06/19 20:08:11 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc10/zlibstat.vcxproj": 88.39157ms
2018/06/19 20:08:11 Couldn't classify license(s)
2018/06/19 20:08:11 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc10/miniunz.vcxproj.filters
2018/06/19 20:08:11 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc10/miniunz.vcxproj.filters": 7.57132ms
2018/06/19 20:08:11 Couldn't classify license(s)
2018/06/19 20:08:12 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc10/zlib.rc
2018/06/19 20:08:12 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc10/zlib.rc": 1.962916ms
2018/06/19 20:08:12 Couldn't classify license(s)
2018/06/19 20:08:13 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc10/zlibvc.vcxproj.filters
2018/06/19 20:08:13 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc10/zlibvc.vcxproj.filters": 14.948214ms
2018/06/19 20:08:13 Couldn't classify license(s)
2018/06/19 20:08:14 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc14/minizip.vcxproj
2018/06/19 20:08:14 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc14/minizip.vcxproj": 57.335001ms
2018/06/19 20:08:14 Couldn't classify license(s)
2018/06/19 20:08:14 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc14/testzlib.vcxproj
2018/06/19 20:08:15 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc14/testzlib.vcxproj": 86.596196ms
2018/06/19 20:08:15 Couldn't classify license(s)
2018/06/19 20:08:15 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc14/zlibvc.vcxproj
2018/06/19 20:08:15 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc14/zlibvc.vcxproj": 149.450739ms
2018/06/19 20:08:15 Couldn't classify license(s)
2018/06/19 20:08:16 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc14/zlibvc.def
2018/06/19 20:08:16 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc14/zlibvc.def": 18.85355ms
2018/06/19 20:08:16 Couldn't classify license(s)
2018/06/19 20:08:17 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc14/zlibvc.sln
2018/06/19 20:08:17 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc14/zlibvc.sln": 31.437191ms
2018/06/19 20:08:17 Couldn't classify license(s)
2018/06/19 20:08:18 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc14/miniunz.vcxproj
2018/06/19 20:08:18 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc14/miniunz.vcxproj": 57.745002ms
2018/06/19 20:08:18 Couldn't classify license(s)
2018/06/19 20:08:19 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc14/testzlibdll.vcxproj
2018/06/19 20:08:19 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc14/testzlibdll.vcxproj": 61.938555ms
2018/06/19 20:08:19 Couldn't classify license(s)
2018/06/19 20:08:20 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc14/zlibstat.vcxproj
2018/06/19 20:08:20 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc14/zlibstat.vcxproj": 87.023518ms
2018/06/19 20:08:20 Couldn't classify license(s)
2018/06/19 20:08:20 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc14/zlib.rc
2018/06/19 20:08:20 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc14/zlib.rc": 1.93307ms
2018/06/19 20:08:20 Couldn't classify license(s)
2018/06/19 20:08:21 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc11/minizip.vcxproj
2018/06/19 20:08:21 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc11/minizip.vcxproj": 56.129695ms
2018/06/19 20:08:21 Couldn't classify license(s)
2018/06/19 20:08:22 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc11/testzlib.vcxproj
2018/06/19 20:08:22 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc11/testzlib.vcxproj": 87.966082ms
2018/06/19 20:08:22 Couldn't classify license(s)
2018/06/19 20:08:23 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc11/zlibvc.vcxproj
2018/06/19 20:08:23 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc11/zlibvc.vcxproj": 144.34105ms
2018/06/19 20:08:23 Couldn't classify license(s)
2018/06/19 20:08:24 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc11/zlibvc.def
2018/06/19 20:08:24 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc11/zlibvc.def": 19.294038ms
2018/06/19 20:08:24 Couldn't classify license(s)
2018/06/19 20:08:25 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc11/zlibvc.sln
2018/06/19 20:08:25 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc11/zlibvc.sln": 29.900352ms
2018/06/19 20:08:25 Couldn't classify license(s)
2018/06/19 20:08:25 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc11/miniunz.vcxproj
2018/06/19 20:08:25 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc11/miniunz.vcxproj": 56.648854ms
2018/06/19 20:08:25 Couldn't classify license(s)
2018/06/19 20:08:26 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc11/testzlibdll.vcxproj
2018/06/19 20:08:26 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc11/testzlibdll.vcxproj": 56.625698ms
2018/06/19 20:08:26 Couldn't classify license(s)
2018/06/19 20:08:27 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc11/zlibstat.vcxproj
2018/06/19 20:08:27 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc11/zlibstat.vcxproj": 88.408123ms
2018/06/19 20:08:27 Couldn't classify license(s)
2018/06/19 20:08:28 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc11/zlib.rc
2018/06/19 20:08:28 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc11/zlib.rc": 2.058511ms
2018/06/19 20:08:28 Couldn't classify license(s)
2018/06/19 20:08:29 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc12/minizip.vcxproj
2018/06/19 20:08:29 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc12/minizip.vcxproj": 59.264573ms
2018/06/19 20:08:29 Couldn't classify license(s)
2018/06/19 20:08:30 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc12/testzlib.vcxproj
2018/06/19 20:08:30 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc12/testzlib.vcxproj": 89.768354ms
2018/06/19 20:08:30 Couldn't classify license(s)
2018/06/19 20:08:30 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc12/zlibvc.vcxproj
2018/06/19 20:08:31 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc12/zlibvc.vcxproj": 143.781374ms
2018/06/19 20:08:31 Couldn't classify license(s)
2018/06/19 20:08:31 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc12/zlibvc.def
2018/06/19 20:08:31 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc12/zlibvc.def": 18.809398ms
2018/06/19 20:08:31 Couldn't classify license(s)
2018/06/19 20:08:32 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc12/zlibvc.sln
2018/06/19 20:08:32 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc12/zlibvc.sln": 30.780025ms
2018/06/19 20:08:32 Couldn't classify license(s)
2018/06/19 20:08:33 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc12/miniunz.vcxproj
2018/06/19 20:08:33 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc12/miniunz.vcxproj": 58.394425ms
2018/06/19 20:08:33 Couldn't classify license(s)
2018/06/19 20:08:34 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc12/testzlibdll.vcxproj
2018/06/19 20:08:34 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc12/testzlibdll.vcxproj": 58.804093ms
2018/06/19 20:08:34 Couldn't classify license(s)
2018/06/19 20:08:35 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc12/zlibstat.vcxproj
2018/06/19 20:08:35 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc12/zlibstat.vcxproj": 92.56608ms
2018/06/19 20:08:35 Couldn't classify license(s)
2018/06/19 20:08:35 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/vstudio/vc12/zlib.rc
2018/06/19 20:08:35 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/vstudio/vc12/zlib.rc": 1.984426ms
2018/06/19 20:08:35 Couldn't classify license(s)
2018/06/19 20:08:36 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/README.contrib
2018/06/19 20:08:36 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/README.contrib": 13.572124ms
2018/06/19 20:08:36 Couldn't classify license(s)
2018/06/19 20:08:37 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/minizip/minizip.1
2018/06/19 20:08:37 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/minizip/minizip.1": 2.738385ms
2018/06/19 20:08:37 Couldn't classify license(s)
2018/06/19 20:08:38 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/minizip/miniunz.c
2018/06/19 20:08:38 detected language: 4
2018/06/19 20:08:38 "\n   miniunz.c\n   Version 1.1, February 14h, 2010\n   sample part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )\n\n         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )\n\n         Modifications of Unzip for Zip64\n         Copyright (C) 2007-2008 Even Rouault\n\n         Modifications for Zip64 support on both zip and unzip\n         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )\n"
2018/06/19 20:08:38 " In darwin and perhaps other BSD variants off_t is a 64 bit value, hence no need for specific 64 bit functions"
2018/06/19 20:08:38 "\n  mini unzip, demo of unzip package\n\n  usage :\n  Usage : miniunz [-exvlo] file.zip [file_to_extract] [-d extractdir]\n\n  list the file in the zipfile, and print the content of FILE_ID.ZIP or README.TXT\n    if it exists\n"
2018/06/19 20:08:38 " change_file_date : change the date/time of a file\n    filename : the filename of the file where date/time must be modified\n    dosdate : the new date at the MSDos format (4 bytes)\n    tmu_date : the SAME new date at the tm_unz format "
2018/06/19 20:08:38 " mymkdir and change_file_date are not 100 % portable\n   As I don't know well Unix, I wait feedback for the unix portion "
2018/06/19 20:08:38 " to avoid compatibility problem , we do here the conversion "
2018/06/19 20:08:38 " display a '*' if the file is crypted "
2018/06/19 20:08:38 " 2:fast , 3 : extra fast"
2018/06/19 20:08:38 " some zipfile don't contain directory alone before file "
2018/06/19 20:08:38 " don't lose the error "
2018/06/19 20:08:38 " strncpy doesnt append the trailing NULL, of the string is too long. "
2018/06/19 20:08:38 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/minizip/miniunz.c": 10.364683ms
2018/06/19 20:08:38 Couldn't classify license(s)
2018/06/19 20:08:39 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/minizip/crypt.h
2018/06/19 20:08:39 detected language: 4
2018/06/19 20:08:39 " crypt.h -- base code for crypt/uncrypt ZIPfile\n\n\n   Version 1.01e, February 12th, 2005\n\n   Copyright (C) 1998-2005 Gilles Vollant\n\n   This code is a modified version of crypting code in Infozip distribution\n\n   The encryption/decryption parts of this source code (as opposed to the\n   non-echoing password parts) were originally written in Europe.  The\n   whole source package can be freely distributed, including from the USA.\n   (Prior to January 2000, re-export from the US was a violation of US law.)\n\n   This encryption code is a direct transcription of the algorithm from\n   Roger Schlafly, described by Phil Katz in the file appnote.txt.  This\n   file (appnote.txt) is distributed with the PKZIP program (even in the\n   version without encryption capabilities).\n\n   If you don't need crypting in your application, just define symbols\n   NOCRYPT and NOUNCRYPT.\n\n   This code support the \"Traditional PKWARE Encryption\".\n\n   The new AES encryption added on Zip format by Winzip (see the page\n   http://www.winzip.com/aes_info.htm ) and PKWare PKZip 5.x Strong\n   Encryption is not supported.\n"
2018/06/19 20:08:39 "**********************************************************************\n * Return the next byte in the pseudo-random sequence\n "
2018/06/19 20:08:39 " POTENTIAL BUG:  temp*(temp^1) may overflow in an\n                     * unpredictable manner on 16-bit systems; not a problem\n                     * with any known compiler so far, though "
2018/06/19 20:08:39 "**********************************************************************\n * Update the encryption keys with the next byte of plain text\n "
2018/06/19 20:08:39 "**********************************************************************\n * Initialize the encryption keys and the random header according to\n * the given password.\n "
2018/06/19 20:08:39 " \"last resort\" source for second part of crypt seed pattern "
2018/06/19 20:08:39 " use PI as default pattern "
2018/06/19 20:08:39 " password string \n where to write header "
2018/06/19 20:08:39 " index in random header \n temporary \n random byte \n random header \n ensure different random header each time "
2018/06/19 20:08:39 " First generate RAND_HEAD_LEN-2 random bytes. We encrypt the\n     * output of rand() to get less predictability, since rand() is\n     * often poorly implemented.\n     "
2018/06/19 20:08:39 " Encrypt random header (last two bytes is high word of crc) "
2018/06/19 20:08:39 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/minizip/crypt.h": 10.986517ms
2018/06/19 20:08:39 Couldn't classify license(s)
2018/06/19 20:08:39 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/minizip/unzip.h
2018/06/19 20:08:39 detected language: 4
2018/06/19 20:08:39 " unzip.h -- IO for uncompress .zip files using zlib\n   Version 1.1, February 14h, 2010\n   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )\n\n         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )\n\n         Modifications of Unzip for Zip64\n         Copyright (C) 2007-2008 Even Rouault\n\n         Modifications for Zip64 support on both zip and unzip\n         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )\n\n         For more info read MiniZip_info.txt\n\n         ---------------------------------------------------------------------------------\n\n        Condition of use and distribution are the same than zlib :\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n\n  ---------------------------------------------------------------------------------\n\n        Changes\n\n        See header of unzip64.c\n\n"
2018/06/19 20:08:39 " like the STRICT of WIN32, we define a pointer that cannot be converted\n    from (void*) without cast "
2018/06/19 20:08:39 " tm_unz contain date/time info "
2018/06/19 20:08:39 " seconds after the minute - [0,59] \n minutes after the hour - [0,59] \n hours since midnight - [0,23] \n day of the month - [1,31] \n months since January - [0,11] \n years - [1980..2044] "
2018/06/19 20:08:39 " unz_global_info structure contain global data about the ZIPfile\n   These data comes from the end of central dir "
2018/06/19 20:08:39 " total number of entries in\n                                     the central dir on this disk "
2018/06/19 20:08:39 " size of the global comment of the zipfile "
2018/06/19 20:08:39 " total number of entries in\n                                     the central dir on this disk "
2018/06/19 20:08:39 " size of the global comment of the zipfile "
2018/06/19 20:08:39 " unz_file_info contain information about a file in the zipfile "
2018/06/19 20:08:39 " version made by                 2 bytes \n version needed to extract       2 bytes \n general purpose bit flag        2 bytes \n compression method              2 bytes \n last mod file date in Dos fmt   4 bytes \n crc-32                          4 bytes \n compressed size                 8 bytes \n uncompressed size               8 bytes \n filename length                 2 bytes \n extra field length              2 bytes \n file comment length             2 bytes "
2018/06/19 20:08:39 " disk number start               2 bytes \n internal file attributes        2 bytes \n external file attributes        4 bytes "
2018/06/19 20:08:39 " version made by                 2 bytes \n version needed to extract       2 bytes \n general purpose bit flag        2 bytes \n compression method              2 bytes \n last mod file date in Dos fmt   4 bytes \n crc-32                          4 bytes \n compressed size                 4 bytes \n uncompressed size               4 bytes \n filename length                 2 bytes \n extra field length              2 bytes \n file comment length             2 bytes "
2018/06/19 20:08:39 " disk number start               2 bytes \n internal file attributes        2 bytes \n external file attributes        4 bytes "
2018/06/19 20:08:39 "\n   Compare two filename (fileName1,fileName2).\n   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)\n   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi\n                                or strcasecmp)\n   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system\n    (like 1 on Unix, 2 on Windows)\n"
2018/06/19 20:08:39 "\n  Open a Zip file. path contain the full pathname (by example,\n     on a Windows XP computer \"c:\\\\zlib\\\\zlib113.zip\" or on an Unix computer\n     \"zlib/zlib113.zip\".\n     If the zipfile cannot be opened (file don't exist or in not valid), the\n       return value is NULL.\n     Else, the return value is a unzFile Handle, usable with other function\n       of this unzip package.\n     the \"64\" function take a const void* pointer, because the path is just the\n       value passed to the open64_file_func callback.\n     Under Windows, if UNICODE is defined, using fill_fopen64_filefunc, the path\n       is a pointer to a wide unicode string (LPCTSTR is LPCWSTR), so const char*\n       does not describe the reality\n"
2018/06/19 20:08:39 "\n   Open a Zip file, like unzOpen, but provide a set of file low level API\n      for read/write the zip file (see ioapi.h)\n"
2018/06/19 20:08:39 "\n   Open a Zip file, like unz64Open, but provide a set of file low level API\n      for read/write the zip file (see ioapi.h)\n"
2018/06/19 20:08:39 "\n  Close a ZipFile opened with unzOpen.\n  If there is files inside the .Zip opened with unzOpenCurrentFile (see later),\n    these files MUST be closed with unzCloseCurrentFile before call unzClose.\n  return UNZ_OK if there is no problem. "
2018/06/19 20:08:39 "\n  Write info about the ZipFile in the *pglobal_info structure.\n  No preparation of the structure is needed\n  return UNZ_OK if there is no problem. "
2018/06/19 20:08:39 "\n  Get the global comment string of the ZipFile, in the szComment buffer.\n  uSizeBuf is the size of the szComment buffer.\n  return the number of byte copied or an error code <0\n"
2018/06/19 20:08:39 "*************************************************************************\n Unzip package allow you browse the directory of the zipfile "
2018/06/19 20:08:39 "\n  Set the current file of the zipfile to the first file.\n  return UNZ_OK if there is no problem\n"
2018/06/19 20:08:39 "\n  Set the current file of the zipfile to the next file.\n  return UNZ_OK if there is no problem\n  return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest.\n"
2018/06/19 20:08:39 "\n  Try locate the file szFileName in the zipfile.\n  For the iCaseSensitivity signification, see unzStringFileNameCompare\n\n  return value :\n  UNZ_OK if the file is found. It becomes the current file.\n  UNZ_END_OF_LIST_OF_FILE if the file is not found\n"
2018/06/19 20:08:39 " ****************************************** \n Ryan supplied functions \n unz_file_info contain information about a file in the zipfile "
2018/06/19 20:08:39 " offset in zip file directory \n # of file "
2018/06/19 20:08:39 " offset in zip file directory \n # of file "
2018/06/19 20:08:39 " ****************************************** "
2018/06/19 20:08:39 "\n  Get Info about the current file\n  if pfile_info!=NULL, the *pfile_info structure will contain somes info about\n        the current file\n  if szFileName!=NULL, the filemane string will be copied in szFileName\n            (fileNameBufferSize is the size of the buffer)\n  if extraField!=NULL, the extra field information will be copied in extraField\n            (extraFieldBufferSize is the size of the buffer).\n            This is the Central-header version of the extra field\n  if szComment!=NULL, the comment string of the file will be copied in szComment\n            (commentBufferSize is the size of the buffer)\n"
2018/06/19 20:08:39 "* Addition for GDAL : START "
2018/06/19 20:08:39 "* Addition for GDAL : END "
2018/06/19 20:08:39 "*************************************************************************\n for reading the content of the current zipfile, you can open it, read data\n   from it, and close it (you can close it before reading all the file)\n   "
2018/06/19 20:08:39 "\n  Open for reading data the current file in the zipfile.\n  If there is no error, the return value is UNZ_OK.\n"
2018/06/19 20:08:39 "\n  Open for reading data the current file in the zipfile.\n  password is a crypting password\n  If there is no error, the return value is UNZ_OK.\n"
2018/06/19 20:08:39 "\n  Same than unzOpenCurrentFile, but open for read raw the file (not uncompress)\n    if raw==1\n  *method will receive method of compression, *level will receive level of\n     compression\n  note : you can set level parameter as NULL (if you did not want known level,\n         but you CANNOT set method parameter as NULL\n"
2018/06/19 20:08:39 "\n  Same than unzOpenCurrentFile, but open for read raw the file (not uncompress)\n    if raw==1\n  *method will receive method of compression, *level will receive level of\n     compression\n  note : you can set level parameter as NULL (if you did not want known level,\n         but you CANNOT set method parameter as NULL\n"
2018/06/19 20:08:39 "\n  Close the file in zip opened with unzOpenCurrentFile\n  Return UNZ_CRCERROR if all the file was read but the CRC is not good\n"
2018/06/19 20:08:39 "\n  Read bytes from the current file (opened by unzOpenCurrentFile)\n  buf contain buffer where data must be copied\n  len the size of buf.\n\n  return the number of byte copied if somes bytes are copied\n  return 0 if the end of file was reached\n  return <0 with error code if there is an error\n    (UNZ_ERRNO for IO error, or zLib error for uncompress error)\n"
2018/06/19 20:08:39 "\n  Give the current position in uncompressed data\n"
2018/06/19 20:08:39 "\n  return 1 if the end of file was reached, 0 elsewhere\n"
2018/06/19 20:08:39 "\n  Read extra field from the current file (opened by unzOpenCurrentFile)\n  This is the local-header version of the extra field (sometimes, there is\n    more info in the local-header version than in the central-header)\n\n  if buf==NULL, it return the size of the local extra field\n\n  if buf!=NULL, len is the size of the buffer, the extra header is copied in\n    buf.\n  the return value is the number of bytes copied in buf, or (if <0)\n    the error code\n"
2018/06/19 20:08:39 "*************************************************************************"
2018/06/19 20:08:39 " Get the current file offset "
2018/06/19 20:08:39 " Set the current file offset "
2018/06/19 20:08:39 " _unz64_H "
2018/06/19 20:08:39 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/minizip/unzip.h": 41.897555ms
2018/06/19 20:08:40 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/minizip/make_vms.com
2018/06/19 20:08:40 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/minizip/make_vms.com": 1.863108ms
2018/06/19 20:08:40 Couldn't classify license(s)
2018/06/19 20:08:41 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/minizip/mztools.h
2018/06/19 20:08:41 detected language: 4
2018/06/19 20:08:41 "\n  Additional tools for Minizip\n  Code: Xavier Roche '2004\n  License: Same as ZLIB (www.gzip.org)\n"
2018/06/19 20:08:41 " Repair a ZIP file (missing central directory)\n   file: file to recover\n   fileOut: output file after recovery\n   fileOutTmp: temporary file name used for recovery\n"
2018/06/19 20:08:41 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/minizip/mztools.h": 5.570289ms
2018/06/19 20:08:41 Couldn't classify license(s)
2018/06/19 20:08:42 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/minizip/iowin32.h
2018/06/19 20:08:42 detected language: 4
2018/06/19 20:08:42 " iowin32.h -- IO base function header for compress/uncompress .zip\n     Version 1.1, February 14h, 2010\n     part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )\n\n         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )\n\n         Modifications for Zip64 support\n         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )\n\n         For more info read MiniZip_info.txt\n\n"
2018/06/19 20:08:42 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/minizip/iowin32.h": 7.396991ms
2018/06/19 20:08:42 Couldn't classify license(s)
2018/06/19 20:08:43 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/minizip/miniunzip.1
2018/06/19 20:08:43 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/minizip/miniunzip.1": 3.370651ms
2018/06/19 20:08:43 Couldn't classify license(s)
2018/06/19 20:08:43 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/minizip/minizip.pc.in
2018/06/19 20:08:43 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/minizip/minizip.pc.in": 6.054942ms
2018/06/19 20:08:43 Couldn't classify license(s)
2018/06/19 20:08:44 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/minizip/zip.c
2018/06/19 20:08:44 detected language: 4
2018/06/19 20:08:44 " zip.c -- IO on .zip files using zlib\n   Version 1.1, February 14h, 2010\n   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )\n\n         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )\n\n         Modifications for Zip64 support\n         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )\n\n         For more info read MiniZip_info.txt\n\n         Changes\n   Oct-2009 - Mathias Svensson - Remove old C style function prototypes\n   Oct-2009 - Mathias Svensson - Added Zip64 Support when creating new file archives\n   Oct-2009 - Mathias Svensson - Did some code cleanup and refactoring to get better overview of some functions.\n   Oct-2009 - Mathias Svensson - Added zipRemoveExtraInfoBlock to strip extra field data from its ZIP64 data\n                                 It is used when recreting zip archive with RAW when deleting items from a zip.\n                                 ZIP64 data is automatically added to items that needs it, and existing ZIP64 data need to be removed.\n   Oct-2009 - Mathias Svensson - Added support for BZIP2 as compression mode (bzip2 lib is required)\n   Jan-2010 - back to unzip and minizip 1.0 name scheme, with compatibility layer\n\n"
2018/06/19 20:08:44 " compile with -Dlocal if your debugger can't find static symbols "
2018/06/19 20:08:44 " platform depedent "
2018/06/19 20:08:44 "(16384)"
2018/06/19 20:08:44 "\n#define SIZECENTRALDIRITEM (0x2e)\n#define SIZEZIPLOCALHEADER (0x1e)\n"
2018/06/19 20:08:44 " I've found an old Unix (a SunOS 4.1.3_U1) without all SEEK_* defined.... "
2018/06/19 20:08:44 " NOT sure that this work on ALL platform"
2018/06/19 20:08:44 " 46 "
2018/06/19 20:08:44 " for future use and alignment "
2018/06/19 20:08:44 " zLib stream structure for inflate "
2018/06/19 20:08:44 " bzLib stream structure for bziped "
2018/06/19 20:08:44 " 1 is stream is initialised \n last written byte in buffered_data "
2018/06/19 20:08:44 " offset of the local header of the file\n                                     currenty writing "
2018/06/19 20:08:44 " central header data for the current file "
2018/06/19 20:08:44 " size of the central header for cur file \n Extra bytes allocated to the centralheader but that are not used \n flag of the file currently writing "
2018/06/19 20:08:44 " compression method of file currenty wr.\n 1 for directly writing raw data \n buffer contain compressed data to be writ"
2018/06/19 20:08:44 " Add ZIP64 extened information in the extra field "
2018/06/19 20:08:44 " keys defining the pseudo-random sequence "
2018/06/19 20:08:44 " io structore of the zipfile \n datablock with central dir in construction\n 1 if a file in the zip is currently writ.\n info on the file curretly writing "
2018/06/19 20:08:44 " position of the beginning of the zipfile "
2018/06/19 20:08:44 "**************************************************************************"
2018/06/19 20:08:44 " ===========================================================================\n   Inputs a long in LSB order to the given file\n   nbByte == 1, 2 ,4 or 8 (byte, short or long, ZPOS64_T)\n"
2018/06/19 20:08:44 " data overflow - hack for ZIP64 (X Roche) "
2018/06/19 20:08:44 " data overflow - hack for ZIP64 "
2018/06/19 20:08:44 "**************************************************************************"
2018/06/19 20:08:44 "**************************************************************************"
2018/06/19 20:08:44 " ===========================================================================\n   Reads a long in LSB order from the given gz_stream. Sets\n"
2018/06/19 20:08:44 "\n  Locate the Central directory of a zipfile (at the end, just before\n    the global comment)\n"
2018/06/19 20:08:44 " maximum size of global comment "
2018/06/19 20:08:44 "\nLocate the End of Zip64 Central directory locator and from there find the CD of a zipfile (at the end, just before\nthe global comment)\n"
2018/06/19 20:08:44 " maximum size of global comment "
2018/06/19 20:08:44 " Signature \"0x07064b50\" Zip64 end of central directory locater"
2018/06/19 20:08:44 " Zip64 end of central directory locator "
2018/06/19 20:08:44 " the signature, already checked "
2018/06/19 20:08:44 " number of the disk with the start of the zip64 end of  central directory "
2018/06/19 20:08:44 " relative offset of the zip64 end of central directory record "
2018/06/19 20:08:44 " total number of disks "
2018/06/19 20:08:44 " Goto Zip64 end of central directory record "
2018/06/19 20:08:44 " the signature "
2018/06/19 20:08:44 " signature of 'Zip64 end of central directory'"
2018/06/19 20:08:44 " byte before the zipfile, (>0 for sfx)"
2018/06/19 20:08:44 " size of the central directory  \n offset of start of central directory "
2018/06/19 20:08:44 " number of the current dist, used for\n                              spaning ZIP, unsupported, always 0"
2018/06/19 20:08:44 " number the the disk with central dir, used\n                              for spaning ZIP, unsupported, always 0"
2018/06/19 20:08:44 " total number of entries in\n                                the central dir\n                                (same than number_entry on nospan) "
2018/06/19 20:08:44 " check first if we find a ZIP64 record"
2018/06/19 20:08:44 " disable to allow appending to empty ZIP archive\n        if (central_pos==0)\n            err=ZIP_ERRNO;\n"
2018/06/19 20:08:44 " the signature, already checked "
2018/06/19 20:08:44 " size of zip64 end of central directory record "
2018/06/19 20:08:44 " version made by "
2018/06/19 20:08:44 " version needed to extract "
2018/06/19 20:08:44 " number of this disk "
2018/06/19 20:08:44 " number of the disk with the start of the central directory "
2018/06/19 20:08:44 " total number of entries in the central directory on this disk "
2018/06/19 20:08:44 " total number of entries in the central directory "
2018/06/19 20:08:44 " size of the central directory "
2018/06/19 20:08:44 " offset of start of central directory with respect to the\n    starting disk number "
2018/06/19 20:08:44 " TODO..\n read the comment from the standard central header."
2018/06/19 20:08:44 " Read End of central Directory info"
2018/06/19 20:08:44 " the signature, already checked "
2018/06/19 20:08:44 " number of this disk "
2018/06/19 20:08:44 " number of the disk with the start of the central directory "
2018/06/19 20:08:44 " total number of entries in the central dir on this disk "
2018/06/19 20:08:44 " total number of entries in the central dir "
2018/06/19 20:08:44 " size of the central directory "
2018/06/19 20:08:44 " offset of start of central directory with respect to the starting disk number "
2018/06/19 20:08:44 " zipfile global comment length "
2018/06/19 20:08:44 " !NO_ADDFILEINEXISTINGZIP"
2018/06/19 20:08:44 "**********************************************************"
2018/06/19 20:08:44 " now we add file in a zipfile "
2018/06/19 20:08:44 " Read and Cache Central Directory Records"
2018/06/19 20:08:44 " !NO_ADDFILEINEXISTINGZIP"
2018/06/19 20:08:44 " !NO_ADDFILEINEXISTINGZIP"
2018/06/19 20:08:44 " write the local header "
2018/06/19 20:08:44 " version needed to extract "
2018/06/19 20:08:44 " version needed to extract "
2018/06/19 20:08:44 " CRC / Compressed size / Uncompressed size will be filled in later and rewritten later"
2018/06/19 20:08:44 " crc 32, unknown "
2018/06/19 20:08:44 " compressed size, unknown "
2018/06/19 20:08:44 " compressed size, unknown "
2018/06/19 20:08:44 " uncompressed size, unknown "
2018/06/19 20:08:44 " uncompressed size, unknown "
2018/06/19 20:08:44 " write the Zip64 extended info"
2018/06/19 20:08:44 " Remember position of Zip64 extended info for the local file header. (needed when we update size after done with file)"
2018/06/19 20:08:44 "\n NOTE.\n When writing RAW the ZIP64 extended information in extrafield_local and extrafield_global needs to be stripped\n before calling this function it can be done with zipRemoveExtraInfoBlock\n\n It is not done here because then we need to realloc a new buffer since parameters are 'const' and I want to minimize\n unnecessary allocations.\n "
2018/06/19 20:08:44 " Extra space we have reserved in case we need to add ZIP64 extra info data"
2018/06/19 20:08:44 " version info "
2018/06/19 20:08:44 "crc\ncompr size\nuncompr size"
2018/06/19 20:08:44 "disk nm start"
2018/06/19 20:08:44 " Init BZip stuff here"
2018/06/19 20:08:44 "init_keys(password,zi->ci.keys,zi->ci.pcrc_32_tab);"
2018/06/19 20:08:44 "          uLong uTotalOutBefore_hi = zi->ci.bstream.total_out_hi32;"
2018/06/19 20:08:44 " while(...)"
2018/06/19 20:08:44 " this is normal "
2018/06/19 20:08:44 " update Current Item crc and sizes,"
2018/06/19 20:08:44 "version Made by"
2018/06/19 20:08:44 "version needed"
2018/06/19 20:08:44 "crc"
2018/06/19 20:08:44 "compr size"
2018/06/19 20:08:44 "compr size"
2018/06/19 20:08:44 "/ set internal file attributes field"
2018/06/19 20:08:44 "uncompr size"
2018/06/19 20:08:44 "uncompr size"
2018/06/19 20:08:44 " Add ZIP64 extra info field for uncompressed size"
2018/06/19 20:08:44 " Add ZIP64 extra info field for compressed size"
2018/06/19 20:08:44 " Add ZIP64 extra info field for relative offset to local file header of current file"
2018/06/19 20:08:44 " we can not write more data to the buffer that we have room for."
2018/06/19 20:08:44 " Add Extra Information Header for 'ZIP64 information'\n HeaderID"
2018/06/19 20:08:44 " DataSize"
2018/06/19 20:08:44 " Update how much extra free space we got in the memory buffer\n and increase the centralheader size so the new ZIP64 fields are included\n ( 4 below is the size of HeaderID and DataSize field )"
2018/06/19 20:08:44 " Update the extra info size field"
2018/06/19 20:08:44 " Update the LocalFileHeader with the new values."
2018/06/19 20:08:44 " crc 32, unknown "
2018/06/19 20:08:44 " Update the size in the ZIP64 extended field."
2018/06/19 20:08:44 " compressed size, unknown "
2018/06/19 20:08:44 " uncompressed size, unknown "
2018/06/19 20:08:44 " Caller passed zip64 = 0, so no room for zip64 info -> fatal"
2018/06/19 20:08:44 " compressed size, unknown "
2018/06/19 20:08:44 " uncompressed size, unknown "
2018/06/19 20:08:44 "num disks\n number of the disk with the start of the central directory "
2018/06/19 20:08:44 "relative offset\n Relative offset to the Zip64EndOfCentralDirectory "
2018/06/19 20:08:44 "total disks\n Do not support spawning of disk so always say 1 here\n number of the disk with the start of the central directory "
2018/06/19 20:08:44 " size of this 'zip64 end of central directory' \n why ZPOS64_T of this ?"
2018/06/19 20:08:44 " version made by "
2018/06/19 20:08:44 " version needed "
2018/06/19 20:08:44 " number of this disk "
2018/06/19 20:08:44 " number of the disk with the start of the central directory "
2018/06/19 20:08:44 " total number of entries in the central dir on this disk "
2018/06/19 20:08:44 " total number of entries in the central dir "
2018/06/19 20:08:44 " size of the central directory "
2018/06/19 20:08:44 " offset of start of central directory with respect to the starting disk number "
2018/06/19 20:08:44 "signature"
2018/06/19 20:08:44 " number of this disk "
2018/06/19 20:08:44 " number of the disk with the start of the central directory "
2018/06/19 20:08:44 " total number of entries in the central dir on this disk "
2018/06/19 20:08:44 " use value in ZIP64 record"
2018/06/19 20:08:44 " total number of entries in the central dir "
2018/06/19 20:08:44 " use value in ZIP64 record"
2018/06/19 20:08:44 " size of the central directory "
2018/06/19 20:08:44 " offset of start of central directory with respect to the starting disk number "
2018/06/19 20:08:44 " Header found."
2018/06/19 20:08:44 " skip it. do not copy to temp buffer"
2018/06/19 20:08:44 " Extra Info block should not be removed, So copy it to the temp buffer."
2018/06/19 20:08:44 " clean old extra info block."
2018/06/19 20:08:44 " copy the new extra info block over the old"
2018/06/19 20:08:44 " set the new extra info size"
2018/06/19 20:08:44 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/minizip/zip.c": 45.303881ms
2018/06/19 20:08:44 Couldn't classify license(s)
2018/06/19 20:08:45 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/minizip/MiniZip64_Changes.txt
2018/06/19 20:08:45 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/minizip/MiniZip64_Changes.txt": 5.384241ms
2018/06/19 20:08:45 Couldn't classify license(s)
2018/06/19 20:08:46 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/minizip/mztools.c
2018/06/19 20:08:46 detected language: 4
2018/06/19 20:08:46 "\n  Additional tools for Minizip\n  Code: Xavier Roche '2004\n  License: Same as ZLIB (www.gzip.org)\n"
2018/06/19 20:08:46 " Code "
2018/06/19 20:08:46 " File entry "
2018/06/19 20:08:46 " crc \n compressed size \n uncompressed sz \n file name length \n extra field length "
2018/06/19 20:08:46 " Header "
2018/06/19 20:08:46 " Filename "
2018/06/19 20:08:46 " Extra field "
2018/06/19 20:08:46 " Data "
2018/06/19 20:08:46 " Central directory entry "
2018/06/19 20:08:46 " disk # \n int attrb \n ext attrb "
2018/06/19 20:08:46 " Header "
2018/06/19 20:08:46 " Filename "
2018/06/19 20:08:46 " Extra field "
2018/06/19 20:08:46 " Comment field "
2018/06/19 20:08:46 " Success "
2018/06/19 20:08:46 " Final central directory  "
2018/06/19 20:08:46 " \"ZIP File recovered by zlib/minizip/mztools\";"
2018/06/19 20:08:46 " disk # \n disk # \n hack \n hack \n size of CD \n offset to CD \n comment "
2018/06/19 20:08:46 " Header "
2018/06/19 20:08:46 " Comment field "
2018/06/19 20:08:46 " Final merge (file + central directory) "
2018/06/19 20:08:46 " Close "
2018/06/19 20:08:46 " Wipe temporary file "
2018/06/19 20:08:46 " Number of recovered entries "
2018/06/19 20:08:46 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/minizip/mztools.c": 9.191011ms
2018/06/19 20:08:46 Couldn't classify license(s)
2018/06/19 20:08:47 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/minizip/MiniZip64_info.txt
2018/06/19 20:08:47 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/minizip/MiniZip64_info.txt": 13.235813ms
2018/06/19 20:08:47 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/minizip/Makefile.am
2018/06/19 20:08:47 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/minizip/Makefile.am": 7.794384ms
2018/06/19 20:08:47 Couldn't classify license(s)
2018/06/19 20:08:48 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/minizip/configure.ac
2018/06/19 20:08:48 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/minizip/configure.ac": 1.730862ms
2018/06/19 20:08:48 Couldn't classify license(s)
2018/06/19 20:08:49 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/minizip/iowin32.c
2018/06/19 20:08:49 detected language: 4
2018/06/19 20:08:49 " iowin32.c -- IO base function header for compress/uncompress .zip\n     Version 1.1, February 14h, 2010\n     part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )\n\n         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )\n\n         Modifications for Zip64 support\n         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )\n\n     For more info read MiniZip_info.txt\n\n"
2018/06/19 20:08:49 " see Include/shared/winapifamily.h in the Windows Kit"
2018/06/19 20:08:49 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/minizip/iowin32.c": 7.931113ms
2018/06/19 20:08:49 Couldn't classify license(s)
2018/06/19 20:08:50 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/minizip/Makefile
2018/06/19 20:08:50 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/minizip/Makefile": 1.127538ms
2018/06/19 20:08:50 Couldn't classify license(s)
2018/06/19 20:08:51 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/minizip/unzip.c
2018/06/19 20:08:51 detected language: 4
2018/06/19 20:08:51 " unzip.c -- IO for uncompress .zip files using zlib\n   Version 1.1, February 14h, 2010\n   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )\n\n         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )\n\n         Modifications of Unzip for Zip64\n         Copyright (C) 2007-2008 Even Rouault\n\n         Modifications for Zip64 support on both zip and unzip\n         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )\n\n         For more info read MiniZip_info.txt\n\n\n  ------------------------------------------------------------------------------------\n  Decryption code comes from crypt.c by Info-ZIP but has been greatly reduced in terms of\n  compatibility with older software. The following is from the original crypt.c.\n  Code woven in by Terry Thorsen 1/2003.\n\n  Copyright (c) 1990-2000 Info-ZIP.  All rights reserved.\n\n  See the accompanying file LICENSE, version 2000-Apr-09 or later\n  (the contents of which are also included in zip.h) for terms of use.\n  If, for some reason, all these files are missing, the Info-ZIP license\n  also may be found at:  ftp://ftp.info-zip.org/pub/infozip/license.html\n\n        crypt.c (full version) by Info-ZIP.      Last revised:  [see crypt.h]\n\n  The encryption/decryption parts of this source code (as opposed to the\n  non-echoing password parts) were originally written in Europe.  The\n  whole source package can be freely distributed, including from the USA.\n  (Prior to January 2000, re-export from the US was a violation of US law.)\n\n        This encryption code is a direct transcription of the algorithm from\n  Roger Schlafly, described by Phil Katz in the file appnote.txt.  This\n  file (appnote.txt) is distributed with the PKZIP program (even in the\n  version without encryption capabilities).\n\n        ------------------------------------------------------------------------------------\n\n        Changes in unzip.c\n\n        2007-2008 - Even Rouault - Addition of cpl_unzGetCurrentFileZStreamPos\n  2007-2008 - Even Rouault - Decoration of symbol names unz* -> cpl_unz*\n  2007-2008 - Even Rouault - Remove old C style function prototypes\n  2007-2008 - Even Rouault - Add unzip support for ZIP64\n\n        Copyright (C) 2007-2008 Even Rouault\n\n\n        Oct-2009 - Mathias Svensson - Removed cpl_* from symbol names (Even Rouault added them but since this is now moved to a new project (minizip64) I renamed them again).\n  Oct-2009 - Mathias Svensson - Fixed problem if uncompressed size was > 4G and compressed size was <4G\n                                should only read the compressed/uncompressed size from the Zip64 format if\n                                the size from normal header was 0xFFFFFFFF\n  Oct-2009 - Mathias Svensson - Applied some bug fixes from paches recived from Gilles Vollant\n        Oct-2009 - Mathias Svensson - Applied support to unzip files with compression mathod BZIP2 (bzip2 lib is required)\n                                Patch created by Daniel Borca\n\n  Jan-2010 - back to unzip and minizip 1.0 name scheme, with compatibility layer\n\n  Copyright (C) 1998 - 2010 Gilles Vollant, Even Rouault, Mathias Svensson\n\n"
2018/06/19 20:08:51 " compile with -Dlocal if your debugger can't find static symbols "
2018/06/19 20:08:51 " unz_file_info_interntal contain internal info about a file in zipfile"
2018/06/19 20:08:51 " relative offset of local header 8 bytes "
2018/06/19 20:08:51 " file_in_zip_read_info_s contain internal information about a file in zipfile,\n    when reading and decompress it "
2018/06/19 20:08:51 " internal buffer for compressed data \n zLib stream structure for inflate "
2018/06/19 20:08:51 " bzLib stream structure for bziped "
2018/06/19 20:08:51 " position in byte on the zipfile, for fseek\n flag set if stream structure is initialised"
2018/06/19 20:08:51 " offset of the local extra field \n size of the local extra field \n position in the local extra field in read"
2018/06/19 20:08:51 " crc32 of all data uncompressed \n crc32 we must obtain after decompress all \n number of byte to be decompressed \nnumber of byte to be obtained after decomp"
2018/06/19 20:08:51 " io structore of the zipfile \n compression method (0==store) \n byte before the zipfile, (>0 for sfx)"
2018/06/19 20:08:51 " unz64_s contain internal information about the zipfile\n"
2018/06/19 20:08:51 " io structore of the zipfile \n public global information \n byte before the zipfile, (>0 for sfx)\n number of the current file in the zipfile\n pos of the current file in the central dir\n flag about the usability of the current file\n position of the beginning of the central dir"
2018/06/19 20:08:51 " size of the central directory  \n offset of start of central directory with\n                                   respect to the starting disk number "
2018/06/19 20:08:51 " public info about the current file in zip\n private info about it\n structure about the current\n                                        file if we are decompressing it "
2018/06/19 20:08:51 " keys defining the pseudo-random sequence "
2018/06/19 20:08:51 " ===========================================================================\n     Read a byte from a gz_stream; update next_in and avail_in. Return EOF\n   for end of file.\n   IN assertion: the stream s has been successfully opened for reading.\n"
2018/06/19 20:08:51 " ===========================================================================\n   Reads a long in LSB order from the given gz_stream. Sets\n"
2018/06/19 20:08:51 " My own strcmpi / strcasecmp "
2018/06/19 20:08:51 "\n   Compare two filename (fileName1,fileName2).\n   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)\n   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi\n                                                                or strcasecmp)\n   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system\n        (like 1 on Unix, 2 on Windows)\n\n"
2018/06/19 20:08:51 "\n  Locate the Central directory of a zipfile (at the end, just before\n    the global comment)\n"
2018/06/19 20:08:51 " maximum size of global comment "
2018/06/19 20:08:51 "\n  Locate the Central directory 64 of a zipfile (at the end, just before\n    the global comment)\n"
2018/06/19 20:08:51 " maximum size of global comment "
2018/06/19 20:08:51 " Zip64 end of central directory locator "
2018/06/19 20:08:51 " the signature, already checked "
2018/06/19 20:08:51 " number of the disk with the start of the zip64 end of  central directory "
2018/06/19 20:08:51 " relative offset of the zip64 end of central directory record "
2018/06/19 20:08:51 " total number of disks "
2018/06/19 20:08:51 " Goto end of central directory record "
2018/06/19 20:08:51 " the signature "
2018/06/19 20:08:51 "\n  Open a Zip file. path contain the full pathname (by example,\n     on a Windows NT computer \"c:\\\\test\\\\zlib114.zip\" or on an Unix computer\n     \"zlib/zlib114.zip\".\n     If the zipfile cannot be opened (file doesn't exist or in not valid), the\n       return value is NULL.\n     Else, the return value is a unzFile Handle, usable with other function\n       of this unzip package.\n"
2018/06/19 20:08:51 " number of the current dist, used for\n                                   spaning ZIP, unsupported, always 0"
2018/06/19 20:08:51 " number the the disk with central dir, used\n                                   for spaning ZIP, unsupported, always 0"
2018/06/19 20:08:51 " total number of entries in\n                                   the central dir\n                                   (same than number_entry on nospan) "
2018/06/19 20:08:51 " the signature, already checked "
2018/06/19 20:08:51 " size of zip64 end of central directory record "
2018/06/19 20:08:51 " version made by "
2018/06/19 20:08:51 " version needed to extract "
2018/06/19 20:08:51 " number of this disk "
2018/06/19 20:08:51 " number of the disk with the start of the central directory "
2018/06/19 20:08:51 " total number of entries in the central directory on this disk "
2018/06/19 20:08:51 " total number of entries in the central directory "
2018/06/19 20:08:51 " size of the central directory "
2018/06/19 20:08:51 " offset of start of central directory with respect to the\n          starting disk number "
2018/06/19 20:08:51 " the signature, already checked "
2018/06/19 20:08:51 " number of this disk "
2018/06/19 20:08:51 " number of the disk with the start of the central directory "
2018/06/19 20:08:51 " total number of entries in the central dir on this disk "
2018/06/19 20:08:51 " total number of entries in the central dir "
2018/06/19 20:08:51 " size of the central directory "
2018/06/19 20:08:51 " offset of start of central directory with respect to the\n            starting disk number "
2018/06/19 20:08:51 " zipfile comment length "
2018/06/19 20:08:51 "\n  Close a ZipFile opened with unzOpen.\n  If there is files inside the .Zip opened with unzOpenCurrentFile (see later),\n    these files MUST be closed with unzCloseCurrentFile before call unzClose.\n  return UNZ_OK if there is no problem. "
2018/06/19 20:08:51 "\n  Write info about the ZipFile in the *pglobal_info structure.\n  No preparation of the structure is needed\n  return UNZ_OK if there is no problem. "
2018/06/19 20:08:51 " to do : check if number_entry is not truncated "
2018/06/19 20:08:51 "\n   Translate date/time from Dos format to tm_unz (readable more easilty)\n"
2018/06/19 20:08:51 "\n  Get Info about the current file in the zipfile, with internal only info\n"
2018/06/19 20:08:51 " we check the magic "
2018/06/19 20:08:51 " relative offset of local header"
2018/06/19 20:08:51 " Read extrafield"
2018/06/19 20:08:51 " since lSeek now points to after the extra field we need to move back"
2018/06/19 20:08:51 " ZIP64 extra fields "
2018/06/19 20:08:51 " Relative Header offset "
2018/06/19 20:08:51 " Disk Start Number "
2018/06/19 20:08:51 "\n  Write info about the ZipFile in the *pglobal_info structure.\n  No preparation of the structure is needed\n  return UNZ_OK if there is no problem.\n"
2018/06/19 20:08:51 "\n  Set the current file of the zipfile to the first file.\n  return UNZ_OK if there is no problem\n"
2018/06/19 20:08:51 "\n  Set the current file of the zipfile to the next file.\n  return UNZ_OK if there is no problem\n  return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest.\n"
2018/06/19 20:08:51 " 2^16 files overflow hack "
2018/06/19 20:08:51 "\n  Try locate the file szFileName in the zipfile.\n  For the iCaseSensitivity signification, see unzStringFileNameCompare\n\n  return value :\n  UNZ_OK if the file is found. It becomes the current file.\n  UNZ_END_OF_LIST_OF_FILE if the file is not found\n"
2018/06/19 20:08:51 " We remember the 'current' position in the file so that we can jump\n     * back there if we fail.\n     "
2018/06/19 20:08:51 " Save the current state "
2018/06/19 20:08:51 " We failed, so restore the state of the 'current file' to where we\n     * were.\n     "
2018/06/19 20:08:51 "\n///////////////////////////////////////////\n// Contributed by Ryan Haksi (mailto://cryogen@infoserve.net)\n// I need random access\n//\n// Further optimization could be realized by adding an ability\n// to cache the directory in memory. The goal being a single\n// comprehensive file read to put the file I need in a memory.\n"
2018/06/19 20:08:51 "\ntypedef struct unz_file_pos_s\n{\n    ZPOS64_T pos_in_zip_directory;   // offset in file\n    ZPOS64_T num_of_file;            // # of file\n} unz_file_pos;\n"
2018/06/19 20:08:51 " jump to the right spot "
2018/06/19 20:08:51 " set the current file "
2018/06/19 20:08:51 " return results "
2018/06/19 20:08:51 "\n// Unzip Helper Functions - should be here?\n///////////////////////////////////////////\n"
2018/06/19 20:08:51 "\n  Read the local header of the current zipfile\n  Check the coherency of the local header and info in the end of central\n        directory about this file\n  store in *piSizeVar the size of extra info in local header\n        (filename and size of extra field data)\n"
2018/06/19 20:08:51 "\n    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.wVersion))\n        err=UNZ_BADZIPFILE;\n"
2018/06/19 20:08:51 " #ifdef HAVE_BZIP2 "
2018/06/19 20:08:51 " #endif "
2018/06/19 20:08:51 " date/time "
2018/06/19 20:08:51 " crc "
2018/06/19 20:08:51 " size compr "
2018/06/19 20:08:51 " size uncompr "
2018/06/19 20:08:51 "\n  Open for reading data the current file in the zipfile.\n  If there is no error and the file is opened, the return value is UNZ_OK.\n"
2018/06/19 20:08:51 " offset of the local extra field \n size of the local extra field "
2018/06/19 20:08:51 " #ifdef HAVE_BZIP2 "
2018/06/19 20:08:51 " #endif "
2018/06/19 20:08:51 " windowBits is passed < 0 to tell that there is no zlib header.\n         * Note that in this case inflate *requires* an extra \"dummy\" byte\n         * after the compressed stream in order to complete decompression and\n         * return Z_STREAM_END.\n         * In unzip, i don't wait absolutely Z_STREAM_END because I known the\n         * size of both compressed and uncompressed data\n         "
2018/06/19 20:08:51 "* Addition for GDAL : START "
2018/06/19 20:08:51 "UNZ_PARAMERROR;"
2018/06/19 20:08:51 "UNZ_PARAMERROR;"
2018/06/19 20:08:51 "* Addition for GDAL : END "
2018/06/19 20:08:51 "\n  Read bytes from the current file.\n  buf contain buffer where data must be copied\n  len the size of buf.\n\n  return the number of byte copied if somes bytes are copied\n  return 0 if the end of file was reached\n  return <0 with error code if there is an error\n    (UNZ_ERRNO for IO error, or zLib error for uncompress error)\n"
2018/06/19 20:08:51 " end Z_BZIP2ED"
2018/06/19 20:08:51 "\n            if ((pfile_in_zip_read_info->rest_read_uncompressed ==\n                     pfile_in_zip_read_info->stream.avail_out) &&\n                (pfile_in_zip_read_info->rest_read_compressed == 0))\n                flush = Z_FINISH;\n            "
2018/06/19 20:08:51 "\n  Give the current position in uncompressed data\n"
2018/06/19 20:08:51 "\n  return 1 if the end of file was reached, 0 elsewhere\n"
2018/06/19 20:08:51 "\nRead extra field from the current file (opened by unzOpenCurrentFile)\nThis is the local-header version of the extra field (sometimes, there is\nmore info in the local-header version than in the central-header)\n\n  if buf==NULL, it return the size of the local extra field that can be read\n\n  if buf!=NULL, len is the size of the buffer, the extra header is copied in\n    buf.\n  the return value is the number of bytes copied in buf, or (if <0)\n    the error code\n"
2018/06/19 20:08:51 "\n  Close the file in zip opened with unzOpenCurrentFile\n  Return UNZ_CRCERROR if all the file was read but the CRC is not good\n"
2018/06/19 20:08:51 "\n  Get the global comment string of the ZipFile, in the szComment buffer.\n  uSizeBuf is the size of the szComment buffer.\n  return the number of byte copied or an error code <0\n"
2018/06/19 20:08:51 " Additions by RX '2004 "
2018/06/19 20:08:51 "UNZ_PARAMERROR;"
2018/06/19 20:08:51 "UNZ_PARAMERROR;"
2018/06/19 20:08:51 " hack "
2018/06/19 20:08:51 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/minizip/unzip.c": 49.807445ms
2018/06/19 20:08:51 Couldn't classify license(s)
2018/06/19 20:08:51 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/minizip/ioapi.h
2018/06/19 20:08:51 detected language: 4
2018/06/19 20:08:51 " ioapi.h -- IO base function header for compress/uncompress .zip\n   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )\n\n         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )\n\n         Modifications for Zip64 support\n         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )\n\n         For more info read MiniZip_info.txt\n\n         Changes\n\n    Oct-2009 - Defined ZPOS64_T to fpos_t on windows and u_int64_t on linux. (might need to find a better why for this)\n    Oct-2009 - Change to fseeko64, ftello64 and fopen64 so large files would work on linux.\n               More if/def section may be needed to support other platforms\n    Oct-2009 - Defined fxxxx64 calls to normal fopen/ftell/fseek so they would compile on windows.\n                          (but you should use iowin32.c for windows instead)\n\n"
2018/06/19 20:08:51 " Linux needs this to support file operation on files larger then 4+GB\n But might need better if/def to select just the platforms that needs them."
2018/06/19 20:08:51 " old MSC"
2018/06/19 20:08:51 "\n#ifndef ZPOS64_T\n  #ifdef _WIN32\n                #define ZPOS64_T fpos_t\n  #else\n    #include <stdint.h>\n    #define ZPOS64_T uint64_t\n  #endif\n#endif\n"
2018/06/19 20:08:51 " a type choosen by DEFINE "
2018/06/19 20:08:51 " Maximum unsigned 32-bit value used as placeholder for zip64 "
2018/06/19 20:08:51 " here is the \"old\" 32 bits structure structure "
2018/06/19 20:08:51 " now internal definition, only for zip.c and unzip.h "
2018/06/19 20:08:51 "#define ZTELL64(filefunc,filestream)            ((*((filefunc).ztell64_file)) ((filefunc).opaque,filestream))\n#define ZSEEK64(filefunc,filestream,pos,mode)   ((*((filefunc).zseek64_file)) ((filefunc).opaque,filestream,pos,mode))"
2018/06/19 20:08:51 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/minizip/ioapi.h": 9.916624ms
2018/06/19 20:08:51 Couldn't classify license(s)
2018/06/19 20:08:52 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/minizip/zip.h
2018/06/19 20:08:52 detected language: 4
2018/06/19 20:08:52 " zip.h -- IO on .zip files using zlib\n   Version 1.1, February 14h, 2010\n   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )\n\n         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )\n\n         Modifications for Zip64 support\n         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )\n\n         For more info read MiniZip_info.txt\n\n         ---------------------------------------------------------------------------\n\n   Condition of use and distribution are the same than zlib :\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n\n        ---------------------------------------------------------------------------\n\n        Changes\n\n        See header of zip.h\n\n"
2018/06/19 20:08:52 "#define HAVE_BZIP2"
2018/06/19 20:08:52 " like the STRICT of WIN32, we define a pointer that cannot be converted\n    from (void*) without cast "
2018/06/19 20:08:52 " default memLevel "
2018/06/19 20:08:52 " tm_zip contain date/time info "
2018/06/19 20:08:52 " seconds after the minute - [0,59] \n minutes after the hour - [0,59] \n hours since midnight - [0,23] \n day of the month - [1,31] \n months since January - [0,11] \n years - [1980..2044] "
2018/06/19 20:08:52 " date in understandable format           \n if dos_date == 0, tmu_date is used      \n    uLong       flag;        \n general purpose bit flag        2 bytes "
2018/06/19 20:08:52 " internal file attributes        2 bytes \n external file attributes        4 bytes "
2018/06/19 20:08:52 "\n  Create a zipfile.\n     pathname contain on Windows XP a filename like \"c:\\\\zlib\\\\zlib113.zip\" or on\n       an Unix computer \"zlib/zlib113.zip\".\n     if the file pathname exist and append==APPEND_STATUS_CREATEAFTER, the zip\n       will be created at the end of the file.\n         (useful if the file contain a self extractor code)\n     if the file pathname exist and append==APPEND_STATUS_ADDINZIP, we will\n       add files in existing zip (be sure you don't add file that doesn't exist)\n     If the zipfile cannot be opened, the return value is NULL.\n     Else, the return value is a zipFile Handle, usable with other function\n       of this zip package.\n"
2018/06/19 20:08:52 " Note : there is no delete function into a zipfile.\n   If you want delete file into a zipfile, you must open a zipfile, and create another\n   Of couse, you can use RAW reading and writing to copy the file you did not want delte\n"
2018/06/19 20:08:52 "\n  Open a file in the ZIP for writing.\n  filename : the filename in zip (if NULL, '-' without quote will be used\n  *zipfi contain supplemental information\n  if extrafield_local!=NULL and size_extrafield_local>0, extrafield_local\n    contains the extrafield data the the local header\n  if extrafield_global!=NULL and size_extrafield_global>0, extrafield_global\n    contains the extrafield data the the local header\n  if comment != NULL, comment contain the comment string\n  method contain the compression method (0 for store, Z_DEFLATED for deflate)\n  level contain the level of compression (can be Z_DEFAULT_COMPRESSION)\n  zip64 is set to 1 if a zip64 extended information block should be added to the local file header.\n                    this MUST be '1' if the uncompressed size is >= 0xffffffff.\n\n"
2018/06/19 20:08:52 "\n  Same than zipOpenNewFileInZip, except if raw=1, we write raw file\n "
2018/06/19 20:08:52 "\n  Same than zipOpenNewFileInZip2, except\n    windowBits,memLevel,,strategy : see parameter strategy in deflateInit2\n    password : crypting password (NULL for no crypting)\n    crcForCrypting : crc of file to compress (needed for crypting)\n "
2018/06/19 20:08:52 "\n  Same than zipOpenNewFileInZip4, except\n    versionMadeBy : value for Version made by field\n    flag : value for flag field (compression level info will be added)\n "
2018/06/19 20:08:52 "\n  Write data in the zipfile\n"
2018/06/19 20:08:52 "\n  Close the current file in the zipfile\n"
2018/06/19 20:08:52 "\n  Close the current file in the zipfile, for file opened with\n    parameter raw=1 in zipOpenNewFileInZip2\n  uncompressed_size and crc32 are value for the uncompressed size\n"
2018/06/19 20:08:52 "\n  Close the zipfile\n"
2018/06/19 20:08:52 "\n  zipRemoveExtraInfoBlock -  Added by Mathias Svensson\n\n  Remove extra information block from a extra information data for the local file header or central directory header\n\n  It is needed to remove ZIP64 extra information blocks when before data is written if using RAW mode.\n\n  0x0001 is the signature header for the ZIP64 extra information blocks\n\n  usage.\n                        Remove ZIP64 Extra information from a central director extra field data\n              zipRemoveExtraInfoBlock(pCenDirExtraFieldData, &nCenDirExtraFieldDataLen, 0x0001);\n\n                        Remove ZIP64 Extra information from a Local File Header extra field data\n        zipRemoveExtraInfoBlock(pLocalHeaderExtraFieldData, &nLocalHeaderExtraFieldDataLen, 0x0001);\n"
2018/06/19 20:08:52 " _zip64_H "
2018/06/19 20:08:52 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/minizip/zip.h": 23.236524ms
2018/06/19 20:08:53 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/minizip/minizip.c
2018/06/19 20:08:53 detected language: 4
2018/06/19 20:08:53 "\n   minizip.c\n   Version 1.1, February 14h, 2010\n   sample part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )\n\n         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )\n\n         Modifications of Unzip for Zip64\n         Copyright (C) 2007-2008 Even Rouault\n\n         Modifications for Zip64 support on both zip and unzip\n         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )\n"
2018/06/19 20:08:53 " In darwin and perhaps other BSD variants off_t is a 64 bit value, hence no need for specific 64 bit functions"
2018/06/19 20:08:53 " name of file to get info on \n return value: access, modific. and creation times \n dostime "
2018/06/19 20:08:53 " name of file to get info on \n return value: access, modific. and creation times \n dostime "
2018/06/19 20:08:53 " results of stat() "
2018/06/19 20:08:53 " strncpy doesnt append the trailing NULL, of the string is too long. "
2018/06/19 20:08:53 " not all systems allow stat'ing a file with / appended "
2018/06/19 20:08:53 " name of file to get info on \n return value: access, modific. and creation times \n dostime "
2018/06/19 20:08:53 " calculate the CRC32 of a file,\n   because to encrypt a file, we need known the CRC32 of the file before "
2018/06/19 20:08:53 " strncpy doesnt append the trailing NULL, of the string is too long. "
2018/06/19 20:08:53 " if the file don't exist, we not append file "
2018/06/19 20:08:53 "\n                err = zipOpenNewFileInZip(zf,filenameinzip,&zi,\n                                 NULL,0,NULL,0,NULL / * comment * /,\n                                 (opt_compress_level != 0) ? Z_DEFLATED : 0,\n                                 opt_compress_level);\n"
2018/06/19 20:08:53 " The path name saved, should not include a leading slash. \nif it did, windows/xp and dynazip couldn't read the zip file. "
2018/06/19 20:08:53 "should the zip file contain any path at all?"
2018/06/19 20:08:53 " base filename follows last slash."
2018/06/19 20:08:53 "*/\n                err = zipOpenNewFileInZip3_64(zf,savefilenameinzip,&zi,\n                                 NULL,0,NULL,0,NULL /* comment"
2018/06/19 20:08:53 " -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY, "
2018/06/19 20:08:53 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/minizip/minizip.c": 11.386283ms
2018/06/19 20:08:53 Couldn't classify license(s)
2018/06/19 20:08:54 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/minizip/ioapi.c
2018/06/19 20:08:54 detected language: 4
2018/06/19 20:08:54 " ioapi.h -- IO base function header for compress/uncompress .zip\n   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )\n\n         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )\n\n         Modifications for Zip64 support\n         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )\n\n         For more info read MiniZip_info.txt\n\n"
2018/06/19 20:08:54 " In darwin and perhaps other BSD variants off_t is a 64 bit value, hence no need for specific 64 bit functions"
2018/06/19 20:08:54 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/minizip/ioapi.c": 2.093585ms
2018/06/19 20:08:54 Couldn't classify license(s)
2018/06/19 20:08:54 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/asm686/match.S
2018/06/19 20:08:54 detected language: 2
2018/06/19 20:08:54 " match.S -- x86 assembly version of the zlib longest_match() function.\n * Optimized for the Intel 686 chips (PPro and later).\n *\n * Copyright (C) 1998, 2007 Brian Raiter <breadbox@muppetlabs.com>\n *\n * This software is provided 'as-is', without any express or implied\n * warranty.  In no event will the author be held liable for any damages\n * arising from the use of this software.\n *\n * Permission is granted to anyone to use this software for any purpose,\n * including commercial applications, and to alter it and redistribute it\n * freely, subject to the following restrictions:\n *\n * 1. The origin of this software must not be misrepresented; you must not\n *    claim that you wrote the original software. If you use this software\n *    in a product, an acknowledgment in the product documentation would be\n *    appreciated but is not required.\n * 2. Altered source versions must be plainly marked as such, and must not be\n *    misrepresented as being the original software.\n * 3. This notice may not be removed or altered from any source distribution.\n "
2018/06/19 20:08:54 " stack frame offsets "
2018/06/19 20:08:54 " high word: current chain len\t\n low word: s->wmask\t\t\n local copy of s->window\t\n s->window + bestlen\t\t\n first two bytes of string\t\n last two bytes of string\t\n dword-misalignment of string\t\n a good enough match size\t\n size of best match so far\t\n ptr to string wanting match\t"
2018/06/19 20:08:54 "\tsaved ebx\t\t36 \n\tsaved edi\t\t40 \n\tsaved esi\t\t44 \n\tsaved ebp\t\t48 \n\treturn address\t\t52 \n the function arguments\t"
2018/06/19 20:08:54 " All the +zlib1222add offsets are due to the addition of fields\n *  in zlib in the deflate_state structure since the asm code was first written\n * (if you compile with zlib 1.0.4 or older, use \"zlib1222add equ (-4)\").\n * (if you compile with zlib between 1.0.5 and 1.2.2.1, use \"zlib1222add equ 0\").\n * if you compile with zlib 1.2.2.2 or later , use \"zlib1222add equ 8\").\n "
2018/06/19 20:08:54 " uInt longest_match(deflate_state *deflatestate, IPos curmatch) "
2018/06/19 20:08:54 " Save registers that the compiler may be using, and adjust %esp to\t\n make room for our stack frame.\t\t\t\t\t"
2018/06/19 20:08:54 " Retrieve the function arguments. %ecx will hold cur_match\t\t\n throughout the entire function. %edx will hold the pointer to the\t\n deflate_state structure during the function's setup (before\t\t\n entering the main loop).\t\t\t\t\t\t"
2018/06/19 20:08:54 " uInt wmask = s->w_mask;\t\t\t\t\t\t\n unsigned chain_length = s->max_chain_length;\t\t\t\t\n if (s->prev_length >= s->good_match) {\t\t\t\t\n     chain_length >>= 2;\t\t\t\t\t\t\n }\t\t\t\t\t\t\t\t\t"
2018/06/19 20:08:54 " chainlen is decremented once beforehand so that the function can\t\n use the sign flag instead of the zero flag for the exit test.\t\n It is then shifted into the high word, to make room for the wmask\t\n value, which it will always accompany.\t\t\t\t"
2018/06/19 20:08:54 " if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;\t"
2018/06/19 20:08:55 " register Bytef *scan = s->window + s->strstart;\t\t\t"
2018/06/19 20:08:55 " Determine how many bytes the scan ptr is off from being\t\t\n dword-aligned.\t\t\t\t\t\t\t"
2018/06/19 20:08:55 " IPos limit = s->strstart > (IPos)MAX_DIST(s) ?\t\t\t\n     s->strstart - (IPos)MAX_DIST(s) : NIL;\t\t\t\t"
2018/06/19 20:08:55 " int best_len = s->prev_length;\t\t\t\t\t"
2018/06/19 20:08:55 " Store the sum of s->window + best_len in %esi locally, and in %esi.\t"
2018/06/19 20:08:55 " register ush scan_start = *(ushf*)scan;\t\t\t\t\n register ush scan_end   = *(ushf*)(scan+best_len-1);\t\t\t\n Posf *prev = s->prev;\t\t\t\t\t\t"
2018/06/19 20:08:55 " Jump into the main loop.\t\t\t\t\t\t"
2018/06/19 20:08:55 " do {\n *     match = s->window + cur_match;\n *     if (*(ushf*)(match+best_len-1) != scan_end ||\n *         *(ushf*)match != scan_start) continue;\n *     [...]\n * } while ((cur_match = prev[cur_match & wmask]) > limit\n *          && --chain_length != 0);\n *\n * Here is the inner loop of the function. The function will spend the\n * majority of its time in this loop, and majority of that time will\n * be spent in the first ten instructions.\n *\n * Within this loop:\n * %ebx = scanend\n * %ecx = curmatch\n * %edx = chainlenwmask - i.e., ((chainlen << 16) | wmask)\n * %esi = windowbestlen - i.e., (window + bestlen)\n * %edi = prev\n * %ebp = limit\n "
2018/06/19 20:08:55 " Store the current value of chainlen.\t\t\t\t\t"
2018/06/19 20:08:55 " Point %edi to the string under scrutiny, and %esi to the string we\t\n are hoping to match it up with. In actuality, %esi and %edi are\t\n both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and %edx is\t\n initialized to -(MAX_MATCH_8 - scanalign).\t\t\t\t"
2018/06/19 20:08:55 " Test the strings for equality, 8 bytes at a time. At the end,\n * adjust %edx so that it is offset to the exact byte that mismatched.\n *\n * We already know at this point that the first three bytes of the\n * strings match each other, and they can be safely passed over before\n * starting the compare loop. So what this code does is skip over 0-3\n * bytes, as much as necessary in order to dword-align the %edi\n * pointer. (%esi will still be misaligned three times out of four.)\n *\n * It should be confessed that this loop usually does not represent\n * much of the total running time. Replacing it with a more\n * straightforward \"rep cmpsb\" would not drastically degrade\n * performance.\n "
2018/06/19 20:08:55 " Calculate the length of the match. If it is longer than MAX_MATCH,\t\n then automatically accept it as the best possible match and leave.\t"
2018/06/19 20:08:55 " If the length of the match is not longer than the best match we\t\n have so far, then forget it and return to the lookup loop.\t\t"
2018/06/19 20:08:55 "         s->match_start = cur_match;\t\t\t\t\t\n         best_len = len;\t\t\t\t\t\t\n         if (len >= nice_match) break;\t\t\t\t\n         scan_end = *(ushf*)(scan+best_len-1);\t\t\t"
2018/06/19 20:08:55 " Accept the current string, with the maximum possible length.\t\t"
2018/06/19 20:08:55 " if ((uInt)best_len <= s->lookahead) return (uInt)best_len;\t\t\n return s->lookahead;\t\t\t\t\t\t\t"
2018/06/19 20:08:55 " Restore the stack and return from whence we came.\t\t\t"
2018/06/19 20:08:55 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/asm686/match.S": 24.027589ms
2018/06/19 20:08:55 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/asm686/README.686
2018/06/19 20:08:55 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/asm686/README.686": 9.720603ms
2018/06/19 20:08:55 Couldn't classify license(s)
2018/06/19 20:08:56 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/puff/puff.c
2018/06/19 20:08:56 detected language: 4
2018/06/19 20:08:56 "\n * puff.c\n * Copyright (C) 2002-2013 Mark Adler\n * For conditions of distribution and use, see copyright notice in puff.h\n * version 2.3, 21 Jan 2013\n *\n * puff.c is a simple inflate written to be an unambiguous way to specify the\n * deflate format.  It is not written for speed but rather simplicity.  As a\n * side benefit, this code might actually be useful when small code is more\n * important than speed, such as bootstrap applications.  For typical deflate\n * data, zlib's inflate() is about four times as fast as puff().  zlib's\n * inflate compiles to around 20K on my machine, whereas puff.c compiles to\n * around 4K on my machine (a PowerPC using GNU cc).  If the faster decode()\n * function here is used, then puff() is only twice as slow as zlib's\n * inflate().\n *\n * All dynamically allocated memory comes from the stack.  The stack required\n * is less than 2K bytes.  This code is compatible with 16-bit int's and\n * assumes that long's are at least 32 bits.  puff.c uses the short data type,\n * assumed to be 16 bits, for arrays in order to conserve memory.  The code\n * works whether integers are stored big endian or little endian.\n *\n * In the comments below are \"Format notes\" that describe the inflate process\n * and document some of the less obvious aspects of the format.  This source\n * code is meant to supplement RFC 1951, which formally describes the deflate\n * format:\n *\n *    http://www.zlib.org/rfc-deflate.html\n "
2018/06/19 20:08:56 "\n * Change history:\n *\n * 1.0  10 Feb 2002     - First version\n * 1.1  17 Feb 2002     - Clarifications of some comments and notes\n *                      - Update puff() dest and source pointers on negative\n *                        errors to facilitate debugging deflators\n *                      - Remove longest from struct huffman -- not needed\n *                      - Simplify offs[] index in construct()\n *                      - Add input size and checking, using longjmp() to\n *                        maintain easy readability\n *                      - Use short data type for large arrays\n *                      - Use pointers instead of long to specify source and\n *                        destination sizes to avoid arbitrary 4 GB limits\n * 1.2  17 Mar 2002     - Add faster version of decode(), doubles speed (!),\n *                        but leave simple version for readabilty\n *                      - Make sure invalid distances detected if pointers\n *                        are 16 bits\n *                      - Fix fixed codes table error\n *                      - Provide a scanning mode for determining size of\n *                        uncompressed data\n * 1.3  20 Mar 2002     - Go back to lengths for puff() parameters [Gailly]\n *                      - Add a puff.h file for the interface\n *                      - Add braces in puff() for else do [Gailly]\n *                      - Use indexes instead of pointers for readability\n * 1.4  31 Mar 2002     - Simplify construct() code set check\n *                      - Fix some comments\n *                      - Add FIXLCODES #define\n * 1.5   6 Apr 2002     - Minor comment fixes\n * 1.6   7 Aug 2002     - Minor format changes\n * 1.7   3 Mar 2003     - Added test code for distribution\n *                      - Added zlib-like license\n * 1.8   9 Jan 2004     - Added some comments on no distance codes case\n * 1.9  21 Feb 2008     - Fix bug on 16-bit integer architectures [Pohland]\n *                      - Catch missing end-of-block symbol error\n * 2.0  25 Jul 2008     - Add #define to permit distance too far back\n *                      - Add option in TEST code for puff to write the data\n *                      - Add option in TEST code to skip input bytes\n *                      - Allow TEST code to read from piped stdin\n * 2.1   4 Apr 2010     - Avoid variable initialization for happier compilers\n *                      - Avoid unsigned comparisons for even happier compilers\n * 2.2  25 Apr 2010     - Fix bug in variable initializations [Oberhumer]\n *                      - Add const where appropriate [Oberhumer]\n *                      - Split if's and ?'s for coverage testing\n *                      - Break out test code to separate file\n *                      - Move NIL to puff.h\n *                      - Allow incomplete code only if single code length is 1\n *                      - Add full code coverage test to Makefile\n * 2.3  21 Jan 2013     - Check for invalid code length codes in dynamic blocks\n "
2018/06/19 20:08:56 " for setjmp(), longjmp(), and jmp_buf \n prototype for puff() "
2018/06/19 20:08:56 " for local function definitions "
2018/06/19 20:08:56 "\n * Maximums for allocations and loops.  It is not useful to change these --\n * they are fixed by the deflate format.\n "
2018/06/19 20:08:56 " maximum bits in a code \n maximum number of literal/length codes \n maximum number of distance codes \n maximum codes lengths to read \n number of fixed literal/length codes "
2018/06/19 20:08:56 " input and output state "
2018/06/19 20:08:56 " output state \n output buffer \n available space at out \n bytes written to out so far "
2018/06/19 20:08:56 " input state \n input buffer \n available input at in \n bytes read so far \n bit buffer \n number of bits in bit buffer "
2018/06/19 20:08:56 " input limit error return state for bits() and decode() "
2018/06/19 20:08:56 "\n * Return need bits from the input stream.  This always leaves less than\n * eight bits in the buffer.  bits() works properly for need == 0.\n *\n * Format notes:\n *\n * - Bits are stored in bytes from the least significant bit to the most\n *   significant bit.  Therefore bits are dropped from the bottom of the bit\n *   buffer, using shift right, and new bytes are appended to the top of the\n *   bit buffer, using shift left.\n "
2018/06/19 20:08:56 " bit accumulator (can use up to 20 bits) "
2018/06/19 20:08:56 " load at least need bits into val "
2018/06/19 20:08:56 " out of input \n load eight bits "
2018/06/19 20:08:56 " drop need bits and update buffer, always zero to seven bits left "
2018/06/19 20:08:56 " return need bits, zeroing the bits above that "
2018/06/19 20:08:56 "\n * Process a stored block.\n *\n * Format notes:\n *\n * - After the two-bit stored block type (00), the stored block length and\n *   stored bytes are byte-aligned for fast copying.  Therefore any leftover\n *   bits in the byte that has the last bit of the type, as many as seven, are\n *   discarded.  The value of the discarded bits are not defined and should not\n *   be checked against any expectation.\n *\n * - The second inverted copy of the stored block length does not have to be\n *   checked, but it's probably a good idea to do so anyway.\n *\n * - A stored block can have zero length.  This is sometimes used to byte-align\n *   subsets of the compressed data for random access or partial recovery.\n "
2018/06/19 20:08:56 " length of stored block "
2018/06/19 20:08:56 " discard leftover bits from current byte (assumes s->bitcnt < 8) "
2018/06/19 20:08:56 " get length and check against its one's complement "
2018/06/19 20:08:56 " not enough input "
2018/06/19 20:08:56 " didn't match complement! "
2018/06/19 20:08:56 " copy len bytes from in to out "
2018/06/19 20:08:56 " not enough input "
2018/06/19 20:08:56 " not enough output space "
2018/06/19 20:08:56 " just scanning "
2018/06/19 20:08:56 " done with a valid stored block "
2018/06/19 20:08:56 "\n * Huffman code decoding tables.  count[1..MAXBITS] is the number of symbols of\n * each length, which for a canonical code are stepped through in order.\n * symbol[] are the symbol values in canonical order, where the number of\n * entries is the sum of the counts in count[].  The decoding process can be\n * seen in the function decode() below.\n "
2018/06/19 20:08:56 " number of symbols of each length \n canonically ordered symbols "
2018/06/19 20:08:56 "\n * Decode a code from the stream s using huffman table h.  Return the symbol or\n * a negative value if there is an error.  If all of the lengths are zero, i.e.\n * an empty code, or if the code is incomplete and an invalid code is received,\n * then -10 is returned after reading MAXBITS bits.\n *\n * Format notes:\n *\n * - The codes as stored in the compressed data are bit-reversed relative to\n *   a simple integer ordering of codes of the same lengths.  Hence below the\n *   bits are pulled from the compressed data one at a time and used to\n *   build the code value reversed from what is in the stream in order to\n *   permit simple integer comparisons for decoding.  A table-based decoding\n *   scheme (as used in zlib) does not need to do this reversal.\n *\n * - The first code for the shortest length is all zeros.  Subsequent codes of\n *   the same length are simply integer increments of the previous code.  When\n *   moving up a length, a zero bit is appended to the code.  For a complete\n *   code, the last code of the longest length will be all ones.\n *\n * - Incomplete codes are handled by this decoder, since they are permitted\n *   in the deflate format.  See the format notes for fixed() and dynamic().\n "
2018/06/19 20:08:56 " current number of bits in code \n len bits being decoded \n first code of length len \n number of codes of length len \n index of first code of length len in symbol table "
2018/06/19 20:08:56 " get next bit "
2018/06/19 20:08:56 " if length len, return symbol "
2018/06/19 20:08:56 " else update for next length "
2018/06/19 20:08:56 " ran out of codes "
2018/06/19 20:08:56 "\n * A faster version of decode() for real applications of this code.   It's not\n * as readable, but it makes puff() twice as fast.  And it only makes the code\n * a few percent larger.\n "
2018/06/19 20:08:56 " !SLOW "
2018/06/19 20:08:56 " current number of bits in code \n len bits being decoded \n first code of length len \n number of codes of length len \n index of first code of length len in symbol table \n bits from stream \n bits left in next or left to process \n next number of codes "
2018/06/19 20:08:56 " if length len, return symbol "
2018/06/19 20:08:56 " else update for next length "
2018/06/19 20:08:56 " out of input "
2018/06/19 20:08:56 " ran out of codes "
2018/06/19 20:08:56 " SLOW "
2018/06/19 20:08:56 "\n * Given the list of code lengths length[0..n-1] representing a canonical\n * Huffman code for n symbols, construct the tables required to decode those\n * codes.  Those tables are the number of codes of each length, and the symbols\n * sorted by length, retaining their original order within each length.  The\n * return value is zero for a complete code set, negative for an over-\n * subscribed code set, and positive for an incomplete code set.  The tables\n * can be used if the return value is zero or positive, but they cannot be used\n * if the return value is negative.  If the return value is zero, it is not\n * possible for decode() using that table to return an error--any stream of\n * enough bits will resolve to a symbol.  If the return value is positive, then\n * it is possible for decode() using that table to return an error for received\n * codes past the end of the incomplete lengths.\n *\n * Not used by decode(), but used for error checking, h->count[0] is the number\n * of the n symbols not in the code.  So n - h->count[0] is the number of\n * codes.  This is useful for checking for incomplete codes that have more than\n * one symbol, which is an error in a dynamic block.\n *\n * Assumption: for all i in 0..n-1, 0 <= length[i] <= MAXBITS\n * This is assured by the construction of the length arrays in dynamic() and\n * fixed() and is not verified by construct().\n *\n * Format notes:\n *\n * - Permitted and expected examples of incomplete codes are one of the fixed\n *   codes and any code with a single symbol which in deflate is coded as one\n *   bit instead of zero bits.  See the format notes for fixed() and dynamic().\n *\n * - Within a given code length, the symbols are kept in ascending order for\n *   the code bits definition.\n "
2018/06/19 20:08:56 " current symbol when stepping through length[] \n current length when stepping through h->count[] \n number of possible codes left of current length \n offsets in symbol table for each length "
2018/06/19 20:08:56 " count number of codes of each length "
2018/06/19 20:08:56 " assumes lengths are within bounds \n no codes! \n complete, but decode() will fail "
2018/06/19 20:08:56 " check for an over-subscribed or incomplete set of lengths \n one possible code of zero length "
2018/06/19 20:08:56 " one more bit, double codes left \n deduct count from possible codes "
2018/06/19 20:08:56 " over-subscribed--return negative \n left > 0 means incomplete "
2018/06/19 20:08:56 " generate offsets into symbol table for each length for sorting "
2018/06/19 20:08:56 "\n     * put symbols in table sorted by length, by symbol order within each\n     * length\n     "
2018/06/19 20:08:56 " return zero for complete set, positive for incomplete set "
2018/06/19 20:08:56 "\n * Decode literal/length and distance codes until an end-of-block code.\n *\n * Format notes:\n *\n * - Compressed data that is after the block type if fixed or after the code\n *   description if dynamic is a combination of literals and length/distance\n *   pairs terminated by and end-of-block code.  Literals are simply Huffman\n *   coded bytes.  A length/distance pair is a coded length followed by a\n *   coded distance to represent a string that occurs earlier in the\n *   uncompressed data that occurs again at the current location.\n *\n * - Literals, lengths, and the end-of-block code are combined into a single\n *   code of up to 286 symbols.  They are 256 literals (0..255), 29 length\n *   symbols (257..285), and the end-of-block symbol (256).\n *\n * - There are 256 possible lengths (3..258), and so 29 symbols are not enough\n *   to represent all of those.  Lengths 3..10 and 258 are in fact represented\n *   by just a length symbol.  Lengths 11..257 are represented as a symbol and\n *   some number of extra bits that are added as an integer to the base length\n *   of the length symbol.  The number of extra bits is determined by the base\n *   length symbol.  These are in the static arrays below, lens[] for the base\n *   lengths and lext[] for the corresponding number of extra bits.\n *\n * - The reason that 258 gets its own symbol is that the longest length is used\n *   often in highly redundant files.  Note that 258 can also be coded as the\n *   base value 227 plus the maximum extra value of 31.  While a good deflate\n *   should never do this, it is not an error, and should be decoded properly.\n *\n * - If a length is decoded, including its extra bits if any, then it is\n *   followed a distance code.  There are up to 30 distance symbols.  Again\n *   there are many more possible distances (1..32768), so extra bits are added\n *   to a base value represented by the symbol.  The distances 1..4 get their\n *   own symbol, but the rest require extra bits.  The base distances and\n *   corresponding number of extra bits are below in the static arrays dist[]\n *   and dext[].\n *\n * - Literal bytes are simply written to the output.  A length/distance pair is\n *   an instruction to copy previously uncompressed bytes to the output.  The\n *   copy is from distance bytes back in the output stream, copying for length\n *   bytes.\n *\n * - Distances pointing before the beginning of the output data are not\n *   permitted.\n *\n * - Overlapped copies, where the length is greater than the distance, are\n *   allowed and common.  For example, a distance of one and a length of 258\n *   simply copies the last byte 258 times.  A distance of four and a length of\n *   twelve copies the last four bytes three times.  A simple forward copy\n *   ignoring whether the length is greater than the distance or not implements\n *   this correctly.  You should not use memcpy() since its behavior is not\n *   defined for overlapped arrays.  You should not use memmove() or bcopy()\n *   since though their behavior -is- defined for overlapping arrays, it is\n *   defined to do the wrong thing in this case.\n "
2018/06/19 20:08:56 " decoded symbol \n length for copy \n distance for copy \n Size base for length codes 257..285 "
2018/06/19 20:08:56 " Extra bits for length codes 257..285 "
2018/06/19 20:08:56 " Offset base for distance codes 0..29 "
2018/06/19 20:08:56 " Extra bits for distance codes 0..29 "
2018/06/19 20:08:56 " decode literals and length/distance pairs "
2018/06/19 20:08:56 " invalid symbol \n literal: symbol is the byte \n write out the literal "
2018/06/19 20:08:56 " length \n get and compute length "
2018/06/19 20:08:56 " invalid fixed code "
2018/06/19 20:08:56 " get and check distance "
2018/06/19 20:08:56 " invalid symbol "
2018/06/19 20:08:56 " distance too far back "
2018/06/19 20:08:56 " copy length bytes from distance bytes back "
2018/06/19 20:08:56 " end of block symbol "
2018/06/19 20:08:56 " done with a valid fixed or dynamic block "
2018/06/19 20:08:56 "\n * Process a fixed codes block.\n *\n * Format notes:\n *\n * - This block type can be useful for compressing small amounts of data for\n *   which the size of the code descriptions in a dynamic block exceeds the\n *   benefit of custom codes for that block.  For fixed codes, no bits are\n *   spent on code descriptions.  Instead the code lengths for literal/length\n *   codes and distance codes are fixed.  The specific lengths for each symbol\n *   can be seen in the \"for\" loops below.\n *\n * - The literal/length code is complete, but has two symbols that are invalid\n *   and should result in an error if received.  This cannot be implemented\n *   simply as an incomplete code since those two symbols are in the \"middle\"\n *   of the code.  They are eight bits long and the longest literal/length\\\n *   code is nine bits.  Therefore the code must be constructed with those\n *   symbols, and the invalid symbols must be detected after decoding.\n *\n * - The fixed distance codes also have two invalid symbols that should result\n *   in an error if received.  Since all of the distance codes are the same\n *   length, this can be implemented as an incomplete code.  Then the invalid\n *   codes are detected while decoding.\n "
2018/06/19 20:08:56 " build fixed huffman tables if first call (may not be thread safe) "
2018/06/19 20:08:56 " construct lencode and distcode "
2018/06/19 20:08:56 " literal/length table "
2018/06/19 20:08:56 " distance table "
2018/06/19 20:08:56 " do this just once "
2018/06/19 20:08:56 " decode data until end-of-block code "
2018/06/19 20:08:56 "\n * Process a dynamic codes block.\n *\n * Format notes:\n *\n * - A dynamic block starts with a description of the literal/length and\n *   distance codes for that block.  New dynamic blocks allow the compressor to\n *   rapidly adapt to changing data with new codes optimized for that data.\n *\n * - The codes used by the deflate format are \"canonical\", which means that\n *   the actual bits of the codes are generated in an unambiguous way simply\n *   from the number of bits in each code.  Therefore the code descriptions\n *   are simply a list of code lengths for each symbol.\n *\n * - The code lengths are stored in order for the symbols, so lengths are\n *   provided for each of the literal/length symbols, and for each of the\n *   distance symbols.\n *\n * - If a symbol is not used in the block, this is represented by a zero as\n *   as the code length.  This does not mean a zero-length code, but rather\n *   that no code should be created for this symbol.  There is no way in the\n *   deflate format to represent a zero-length code.\n *\n * - The maximum number of bits in a code is 15, so the possible lengths for\n *   any code are 1..15.\n *\n * - The fact that a length of zero is not permitted for a code has an\n *   interesting consequence.  Normally if only one symbol is used for a given\n *   code, then in fact that code could be represented with zero bits.  However\n *   in deflate, that code has to be at least one bit.  So for example, if\n *   only a single distance base symbol appears in a block, then it will be\n *   represented by a single code of length one, in particular one 0 bit.  This\n *   is an incomplete code, since if a 1 bit is received, it has no meaning,\n *   and should result in an error.  So incomplete distance codes of one symbol\n *   should be permitted, and the receipt of invalid codes should be handled.\n *\n * - It is also possible to have a single literal/length code, but that code\n *   must be the end-of-block code, since every dynamic block has one.  This\n *   is not the most efficient way to create an empty block (an empty fixed\n *   block is fewer bits), but it is allowed by the format.  So incomplete\n *   literal/length codes of one symbol should also be permitted.\n *\n * - If there are only literal codes and no lengths, then there are no distance\n *   codes.  This is represented by one distance code with zero bits.\n *\n * - The list of up to 286 length/literal lengths and up to 30 distance lengths\n *   are themselves compressed using Huffman codes and run-length encoding.  In\n *   the list of code lengths, a 0 symbol means no code, a 1..15 symbol means\n *   that length, and the symbols 16, 17, and 18 are run-length instructions.\n *   Each of 16, 17, and 18 are follwed by extra bits to define the length of\n *   the run.  16 copies the last length 3 to 6 times.  17 represents 3 to 10\n *   zero lengths, and 18 represents 11 to 138 zero lengths.  Unused symbols\n *   are common, hence the special coding for zero lengths.\n *\n * - The symbols for 0..18 are Huffman coded, and so that code must be\n *   described first.  This is simply a sequence of up to 19 three-bit values\n *   representing no code (0) or the code length for that symbol (1..7).\n *\n * - A dynamic block starts with three fixed-size counts from which is computed\n *   the number of literal/length code lengths, the number of distance code\n *   lengths, and the number of code length code lengths (ok, you come up with\n *   a better name!) in the code descriptions.  For the literal/length and\n *   distance codes, lengths after those provided are considered zero, i.e. no\n *   code.  The code length code lengths are received in a permuted order (see\n *   the order[] array below) to make a short code length code length list more\n *   likely.  As it turns out, very short and very long codes are less likely\n *   to be seen in a dynamic code description, hence what may appear initially\n *   to be a peculiar ordering.\n *\n * - Given the number of literal/length code lengths (nlen) and distance code\n *   lengths (ndist), then they are treated as one long list of nlen + ndist\n *   code lengths.  Therefore run-length coding can and often does cross the\n *   boundary between the two sets of lengths.\n *\n * - So to summarize, the code description at the start of a dynamic block is\n *   three counts for the number of code lengths for the literal/length codes,\n *   the distance codes, and the code length codes.  This is followed by the\n *   code length code lengths, three bits each.  This is used to construct the\n *   code length code which is used to read the remainder of the lengths.  Then\n *   the literal/length code lengths and distance lengths are read as a single\n *   set of lengths using the code length codes.  Codes are constructed from\n *   the resulting two sets of lengths, and then finally you can start\n *   decoding actual compressed data in the block.\n *\n * - For reference, a \"typical\" size for the code description in a dynamic\n *   block is around 80 bytes.\n "
2018/06/19 20:08:56 " number of lengths in descriptor \n index of lengths[] \n construct() return value \n descriptor code lengths \n lencode memory \n distcode memory \n length and distance codes \n permutation of code length codes "
2018/06/19 20:08:56 " construct lencode and distcode "
2018/06/19 20:08:56 " get number of lengths in each table, check lengths "
2018/06/19 20:08:56 " bad counts "
2018/06/19 20:08:56 " read code length code lengths (really), missing lengths are zero "
2018/06/19 20:08:56 " build huffman table for code lengths codes (use lencode temporarily) "
2018/06/19 20:08:56 " require complete code set here "
2018/06/19 20:08:56 " read length/literal and distance code length tables "
2018/06/19 20:08:56 " decoded value \n last length to repeat "
2018/06/19 20:08:56 " invalid symbol \n length in 0..15 "
2018/06/19 20:08:56 " repeat instruction \n assume repeating zeros \n repeat last length 3..6 times "
2018/06/19 20:08:56 " no last length! \n last length "
2018/06/19 20:08:56 " repeat zero 3..10 times "
2018/06/19 20:08:56 " == 18, repeat zero 11..138 times "
2018/06/19 20:08:56 " too many lengths! \n repeat last or zero symbol times "
2018/06/19 20:08:56 " check for end-of-block code -- there better be one! "
2018/06/19 20:08:56 " build huffman table for literal/length codes "
2018/06/19 20:08:56 " incomplete code ok only for single length 1 code "
2018/06/19 20:08:56 " build huffman table for distance codes "
2018/06/19 20:08:56 " incomplete code ok only for single length 1 code "
2018/06/19 20:08:56 " decode data until end-of-block code "
2018/06/19 20:08:56 "\n * Inflate source to dest.  On return, destlen and sourcelen are updated to the\n * size of the uncompressed data and the size of the deflate data respectively.\n * On success, the return value of puff() is zero.  If there is an error in the\n * source data, i.e. it is not in the deflate format, then a negative value is\n * returned.  If there is not enough input available or there is not enough\n * output space, then a positive error is returned.  In that case, destlen and\n * sourcelen are not updated to facilitate retrying from the beginning with the\n * provision of more input data or more output space.  In the case of invalid\n * inflate data (a negative error), the dest and source pointers are updated to\n * facilitate the debugging of deflators.\n *\n * puff() also has a mode to determine the size of the uncompressed output with\n * no output written.  For this dest must be (unsigned char *)0.  In this case,\n * the input value of *destlen is ignored, and on return *destlen is set to the\n * size of the uncompressed output.\n *\n * The return codes are:\n *\n *   2:  available inflate data did not terminate\n *   1:  output space exhausted before completing inflate\n *   0:  successful inflate\n *  -1:  invalid block type (type == 3)\n *  -2:  stored block length did not match one's complement\n *  -3:  dynamic block code description: too many length or distance codes\n *  -4:  dynamic block code description: code lengths codes incomplete\n *  -5:  dynamic block code description: repeat lengths with no first length\n *  -6:  dynamic block code description: repeat more than specified lengths\n *  -7:  dynamic block code description: invalid literal/length code lengths\n *  -8:  dynamic block code description: invalid distance code lengths\n *  -9:  dynamic block code description: missing end-of-block code\n * -10:  invalid literal/length or distance code in fixed or dynamic block\n * -11:  distance is too far back in fixed or dynamic block\n *\n * Format notes:\n *\n * - Three bits are read for each block to determine the kind of block and\n *   whether or not it is the last block.  Then the block is decoded and the\n *   process repeated if it was not the last block.\n *\n * - The leftover bits in the last byte of the deflate data after the last\n *   block (if it was a fixed or dynamic block) are undefined and have no\n *   expected values to check.\n "
2018/06/19 20:08:56 " pointer to destination pointer \n amount of output space \n pointer to source data pointer \n amount of input available "
2018/06/19 20:08:56 " input/output state \n block information \n return value "
2018/06/19 20:08:56 " initialize output state "
2018/06/19 20:08:56 " ignored if dest is NIL "
2018/06/19 20:08:56 " initialize input state "
2018/06/19 20:08:56 " return if bits() or decode() tries to read past available input \n if came back here via longjmp() \n then skip do-loop, return error "
2018/06/19 20:08:56 " process blocks until last block or error "
2018/06/19 20:08:56 " one if last block \n block type 0..3 "
2018/06/19 20:08:56 " type == 3, invalid "
2018/06/19 20:08:56 " return with error "
2018/06/19 20:08:56 " update the lengths and return "
2018/06/19 20:08:56 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/puff/puff.c": 122.790876ms
2018/06/19 20:08:56 Couldn't classify license(s)
2018/06/19 20:08:57 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/puff/puff.h
2018/06/19 20:08:57 detected language: 4
2018/06/19 20:08:57 " puff.h\n  Copyright (C) 2002-2013 Mark Adler, all rights reserved\n  version 2.3, 21 Jan 2013\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the author be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n\n  Mark Adler    madler@alumni.caltech.edu\n "
2018/06/19 20:08:57 "\n * See puff.c for purpose and usage.\n "
2018/06/19 20:08:57 " for no output option "
2018/06/19 20:08:57 " pointer to destination pointer \n amount of output space \n pointer to source data pointer \n amount of input available "
2018/06/19 20:08:57 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/puff/puff.h": 9.018512ms
2018/06/19 20:08:58 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/puff/zeros.raw
2018/06/19 20:08:58 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/puff/zeros.raw": 4.351414ms
2018/06/19 20:08:58 Couldn't classify license(s)
2018/06/19 20:08:59 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/puff/pufftest.c
2018/06/19 20:08:59 detected language: 4
2018/06/19 20:08:59 "\n * pufftest.c\n * Copyright (C) 2002-2013 Mark Adler\n * For conditions of distribution and use, see copyright notice in puff.h\n * version 2.3, 21 Jan 2013\n "
2018/06/19 20:08:59 " Example of how to use puff().\n\n   Usage: puff [-w] [-f] [-nnn] file\n          ... | puff [-w] [-f] [-nnn]\n\n   where file is the input file with deflate data, nnn is the number of bytes\n   of input to skip before inflating (e.g. to skip a zlib or gzip header), and\n   -w is used to write the decompressed data to stdout.  -f is for coverage\n   testing, and causes pufftest to fail with not enough output space (-f does\n   a write like -w, so -w is not required). "
2018/06/19 20:08:59 " Return size times approximately the cube root of 2, keeping the result as 1,\n   3, or 5 times a power of 2 -- the result is always > size, until the result\n   is the maximum value of an unsigned long, where it remains.  This is useful\n   to keep reallocations less than ~33% over the actual data. "
2018/06/19 20:08:59 " Read the input file *name, or stdin if name is NULL, into allocated memory.\n   Reallocate to larger buffers until the entire file is read in.  Return a\n   pointer to the allocated data, or NULL if there was a memory allocation\n   failure.  *len is the number of bytes of data read from the input file (even\n   if load() returns NULL).  If the input file was empty or could not be opened\n   or read, *len is zero. "
2018/06/19 20:08:59 " process arguments "
2018/06/19 20:08:59 " test inflate data with offset skip "
2018/06/19 20:08:59 " if requested, inflate again and write decompressd data to stdout "
2018/06/19 20:08:59 " clean up "
2018/06/19 20:08:59 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/puff/pufftest.c": 9.444451ms
2018/06/19 20:08:59 Couldn't classify license(s)
2018/06/19 20:08:59 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/puff/Makefile
2018/06/19 20:08:59 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/puff/Makefile": 3.453149ms
2018/06/19 20:08:59 Couldn't classify license(s)
2018/06/19 20:09:00 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/puff/README
2018/06/19 20:09:00 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/puff/README": 13.490881ms
2018/06/19 20:09:00 Couldn't classify license(s)
2018/06/19 20:09:01 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/pascal/zlibd32.mak
2018/06/19 20:09:01 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/pascal/zlibd32.mak": 4.34689ms
2018/06/19 20:09:01 Couldn't classify license(s)
2018/06/19 20:09:02 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/pascal/readme.txt
2018/06/19 20:09:02 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/pascal/readme.txt": 14.195565ms
2018/06/19 20:09:02 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/pascal/zlibpas.pas
2018/06/19 20:09:02 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/pascal/zlibpas.pas": 30.713589ms
2018/06/19 20:09:02 Couldn't classify license(s)
2018/06/19 20:09:03 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/pascal/example.pas
2018/06/19 20:09:03 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/pascal/example.pas": 43.571532ms
2018/06/19 20:09:03 Couldn't classify license(s)
2018/06/19 20:09:04 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/infback9/infback9.h
2018/06/19 20:09:04 detected language: 4
2018/06/19 20:09:04 " infback9.h -- header for using inflateBack9 functions\n * Copyright (C) 2003 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n "
2018/06/19 20:09:04 "\n * This header file and associated patches provide a decoder for PKWare's\n * undocumented deflate64 compression method (method 9).  Use with infback9.c,\n * inftree9.h, inftree9.c, and inffix9.h.  These patches are not supported.\n * This should be compiled with zlib, since it uses zutil.h and zutil.o.\n * This code has not yet been tested on 16-bit architectures.  See the\n * comments in zlib.h for inflateBack() usage.  These functions are used\n * identically, except that there is no windowBits parameter, and a 64K\n * window must be provided.  Also if int's are 16 bits, then a zero for\n * the third parameter of the \"out\" function actually means 65536UL.\n * zlib.h must be included before this header file.\n "
2018/06/19 20:09:04 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/infback9/infback9.h": 7.700295ms
2018/06/19 20:09:04 Couldn't classify license(s)
2018/06/19 20:09:05 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/infback9/inftree9.h
2018/06/19 20:09:05 detected language: 4
2018/06/19 20:09:05 " inftree9.h -- header to use inftree9.c\n * Copyright (C) 1995-2008 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n "
2018/06/19 20:09:05 " WARNING: this file should *not* be used by applications. It is\n   part of the implementation of the compression library and is\n   subject to change. Applications should only use zlib.h.\n "
2018/06/19 20:09:05 " Structure for decoding tables.  Each entry provides either the\n   information needed to do the operation requested by the code that\n   indexed that table entry, or it provides a pointer to another\n   table that indexes more bits of the code.  op indicates whether\n   the entry is a pointer to another table, a literal, a length or\n   distance, an end-of-block, or an invalid code.  For a table\n   pointer, the low four bits of op is the number of index bits of\n   that table.  For a length or distance, the low four bits of op\n   is the number of extra bits to get after the code.  bits is\n   the number of bits in this code or part of the code to drop off\n   of the bit buffer.  val is the actual byte to output in the case\n   of a literal, the base length or distance, or the offset from\n   the current table to the next table.  Each entry is four bytes. "
2018/06/19 20:09:05 " operation, extra bits, table bits \n bits in this part of the code \n offset in table or code value "
2018/06/19 20:09:05 " op values as set by inflate_table():\n    00000000 - literal\n    0000tttt - table link, tttt != 0 is the number of table index bits\n    100eeeee - length or distance, eeee is the number of extra bits\n    01100000 - end of block\n    01000000 - invalid code\n "
2018/06/19 20:09:05 " Maximum size of the dynamic table.  The maximum number of code structures is\n   1446, which is the sum of 852 for literal/length codes and 594 for distance\n   codes.  These values were found by exhaustive searches using the program\n   examples/enough.c found in the zlib distribtution.  The arguments to that\n   program are the number of symbols, the initial root table size, and the\n   maximum bit length of a code.  \"enough 286 9 15\" for literal/length codes\n   returns returns 852, and \"enough 32 6 15\" for distance codes returns 594.\n   The initial root table size (9 or 6) is found in the fifth argument of the\n   inflate_table() calls in infback9.c.  If the root table size is changed,\n   then these maximum sizes would be need to be recalculated and updated. "
2018/06/19 20:09:05 " Type of code to build for inflate_table9() "
2018/06/19 20:09:05 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/infback9/inftree9.h": 19.986037ms
2018/06/19 20:09:05 Couldn't classify license(s)
2018/06/19 20:09:06 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/infback9/inflate9.h
2018/06/19 20:09:06 detected language: 4
2018/06/19 20:09:06 " inflate9.h -- internal inflate state definition\n * Copyright (C) 1995-2003 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n "
2018/06/19 20:09:06 " WARNING: this file should *not* be used by applications. It is\n   part of the implementation of the compression library and is\n   subject to change. Applications should only use zlib.h.\n "
2018/06/19 20:09:06 " Possible inflate modes between inflate() calls "
2018/06/19 20:09:06 " i: waiting for type bits, including last-flag bit \n i: waiting for stored size (length and complement) \n i: waiting for dynamic block table lengths \n i: waiting for length/lit code \n finished check, done -- remain here until reset \n got a data error -- remain here until reset "
2018/06/19 20:09:06 "\n    State transitions between above modes -\n\n    (most modes can go to the BAD mode -- not shown for clarity)\n\n    Read deflate blocks:\n            TYPE -> STORED or TABLE or LEN or DONE\n            STORED -> TYPE\n            TABLE -> LENLENS -> CODELENS -> LEN\n    Read deflate codes:\n                LEN -> LEN or TYPE\n "
2018/06/19 20:09:06 " state maintained between inflate() calls.  Approximately 7K bytes. "
2018/06/19 20:09:06 " sliding window \n allocated sliding window, if needed \n dynamic table building \n number of code length code lengths \n number of length code lengths \n number of distance code lengths \n number of code lengths in lens[] \n next available space in codes[] \n temporary storage for code lengths \n work area for code table building \n space for code tables "
2018/06/19 20:09:06 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/infback9/inflate9.h": 10.883437ms
2018/06/19 20:09:06 Couldn't classify license(s)
2018/06/19 20:09:06 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/infback9/inffix9.h
2018/06/19 20:09:06 detected language: 4
2018/06/19 20:09:06 " inffix9.h -- table for decoding deflate64 fixed codes\n     * Generated automatically by makefixed9().\n     "
2018/06/19 20:09:06 " WARNING: this file should *not* be used by applications.\n       It is part of the implementation of this library and is\n       subject to change. Applications should only use zlib.h.\n     "
2018/06/19 20:09:06 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/infback9/inffix9.h": 1.714303ms
2018/06/19 20:09:06 Couldn't classify license(s)
2018/06/19 20:09:07 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/infback9/inftree9.c
2018/06/19 20:09:07 detected language: 4
2018/06/19 20:09:07 " inftree9.c -- generate Huffman trees for efficient decoding\n * Copyright (C) 1995-2017 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n "
2018/06/19 20:09:07 "\n  If you use the zlib library in a product, an acknowledgment is welcome\n  in the documentation of your product. If for some reason you cannot\n  include such an acknowledgment, I would appreciate that you keep this\n  copyright string in the executable of your product.\n "
2018/06/19 20:09:07 "\n   Build a set of tables to decode the provided canonical Huffman code.\n   The code lengths are lens[0..codes-1].  The result starts at *table,\n   whose indices are 0..2^bits-1.  work is a writable array of at least\n   lens shorts, which is used as a work area.  type is the type of code\n   to be generated, CODES, LENS, or DISTS.  On return, zero is success,\n   -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table\n   on return points to the next available entry's address.  bits is the\n   requested root table index bits, and on return it is the actual root\n   table index bits.  It will differ if the request is greater than the\n   longest code or if it is less than the shortest code.\n "
2018/06/19 20:09:07 " a code's length in bits \n index of code symbols \n minimum and maximum code lengths \n number of index bits for root table \n number of index bits for current table \n code bits to drop for sub-table \n number of prefix codes available \n code entries in table used \n Huffman code \n for incrementing code, index \n index for replicating entries \n low bits for current root entry \n mask for low root bits \n table entry for duplication \n next available space in table \n base value table to use \n extra bits table to use \n use base and extra for symbol > end \n number of codes of each length \n offsets in table for each length \n Length codes 257..285 base "
2018/06/19 20:09:07 " Length codes 257..285 extra "
2018/06/19 20:09:07 " Distance codes 0..31 base "
2018/06/19 20:09:07 " Distance codes 0..31 extra "
2018/06/19 20:09:07 "\n       Process a set of code lengths to create a canonical Huffman code.  The\n       code lengths are lens[0..codes-1].  Each length corresponds to the\n       symbols 0..codes-1.  The Huffman code is generated by first sorting the\n       symbols by length from short to long, and retaining the symbol order\n       for codes with equal lengths.  Then the code starts with all zero bits\n       for the first code of the shortest length, and the codes are integer\n       increments for the same length, and zeros are appended as the length\n       increases.  For the deflate format, these bits are stored backwards\n       from their more natural integer increment ordering, and so when the\n       decoding tables are built in the large loop below, the integer codes\n       are incremented backwards.\n\n       This routine assumes, but does not check, that all of the entries in\n       lens[] are in the range 0..MAXBITS.  The caller must assure this.\n       1..MAXBITS is interpreted as that code length.  zero means that that\n       symbol does not occur in this code.\n\n       The codes are sorted by computing a count of codes for each length,\n       creating from that a table of starting indices for each length in the\n       sorted table, and then entering the symbols in order in the sorted\n       table.  The sorted table is work[], with that space being provided by\n       the caller.\n\n       The length counts are used for other purposes as well, i.e. finding\n       the minimum and maximum length codes, determining if there are any\n       codes at all, checking for a valid set of lengths, and looking ahead\n       at length counts to determine sub-table sizes when building the\n       decoding tables.\n     "
2018/06/19 20:09:07 " accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) "
2018/06/19 20:09:07 " bound code lengths, force root to be within code lengths "
2018/06/19 20:09:07 " no codes! "
2018/06/19 20:09:07 " check for an over-subscribed or incomplete set of lengths "
2018/06/19 20:09:07 " over-subscribed "
2018/06/19 20:09:07 " incomplete set "
2018/06/19 20:09:07 " generate offsets into symbol table for each length for sorting "
2018/06/19 20:09:07 " sort symbols by length, by symbol order within each length "
2018/06/19 20:09:07 "\n       Create and fill in decoding tables.  In this loop, the table being\n       filled is at next and has curr index bits.  The code being used is huff\n       with length len.  That code is converted to an index by dropping drop\n       bits off of the bottom.  For codes where len is less than drop + curr,\n       those top drop + curr - len bits are incremented through all values to\n       fill the table with replicated entries.\n\n       root is the number of index bits for the root table.  When len exceeds\n       root, sub-tables are created pointed to by the root entry with an index\n       of the low root bits of huff.  This is saved in low to check for when a\n       new sub-table should be started.  drop is zero when the root table is\n       being filled, and drop is root when sub-tables are being filled.\n\n       When a new sub-table is needed, it is necessary to look ahead in the\n       code lengths to determine what size sub-table is needed.  The length\n       counts are used for this, and so count[] is decremented as codes are\n       entered in the tables.\n\n       used keeps track of how many table entries have been allocated from the\n       provided *table space.  It is checked for LENS and DIST tables against\n       the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n       the initial root table size constants.  See the comments in inftree9.h\n       for more information.\n\n       sym increments through all symbols, and the loop terminates when\n       all codes of length max, i.e. all codes, have been processed.  This\n       routine permits incomplete codes, so another loop after this one fills\n       in the rest of the decoding tables with invalid code markers.\n     "
2018/06/19 20:09:07 " set up for code type "
2018/06/19 20:09:07 " dummy value--not used "
2018/06/19 20:09:07 " DISTS "
2018/06/19 20:09:07 " initialize state for loop \n starting code \n starting code symbol \n starting code length \n current table to fill in \n current table index bits \n current bits to drop from code for index \n trigger new sub-table when len > root \n use root table entries \n mask for comparing low "
2018/06/19 20:09:07 " check available table space "
2018/06/19 20:09:07 " process all codes and make table entries "
2018/06/19 20:09:07 " create table entry "
2018/06/19 20:09:07 " end of block "
2018/06/19 20:09:07 " replicate for those indices with low len bits equal to huff "
2018/06/19 20:09:07 " backwards increment the len-bit code huff "
2018/06/19 20:09:07 " go to next symbol, update count, len "
2018/06/19 20:09:07 " create new sub-table if needed "
2018/06/19 20:09:07 " if first time, transition to sub-tables "
2018/06/19 20:09:07 " increment past last table "
2018/06/19 20:09:07 " determine length of next table "
2018/06/19 20:09:07 " check for enough space "
2018/06/19 20:09:07 " point entry in root table to sub-table "
2018/06/19 20:09:07 "\n       Fill in rest of table for incomplete codes.  This loop is similar to the\n       loop above in incrementing huff for table indices.  It is assumed that\n       len is equal to curr + drop, so there is no loop needed to increment\n       through high index bits.  When the current sub-table is filled, the loop\n       drops back to the root table to fill in any remaining entries there.\n     "
2018/06/19 20:09:07 " invalid code marker "
2018/06/19 20:09:07 " when done with sub-table, drop back to root table "
2018/06/19 20:09:07 " put invalid code marker in table "
2018/06/19 20:09:07 " backwards increment the len-bit code huff "
2018/06/19 20:09:07 " set return parameters "
2018/06/19 20:09:07 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/infback9/inftree9.c": 42.346943ms
2018/06/19 20:09:07 Couldn't classify license(s)
2018/06/19 20:09:08 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/infback9/infback9.c
2018/06/19 20:09:08 detected language: 4
2018/06/19 20:09:08 " infback9.c -- inflate deflate64 data using a call-back interface\n * Copyright (C) 1995-2008 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n "
2018/06/19 20:09:08 "\n   strm provides memory allocation functions in zalloc and zfree, or\n   Z_NULL to use the library memory allocation functions.\n\n   window is a user-supplied window and output buffer that is 64K bytes.\n "
2018/06/19 20:09:08 " in case we return an error "
2018/06/19 20:09:08 "\n   Build and output length and distance decoding tables for fixed code\n   decoding.\n "
2018/06/19 20:09:08 " literal/length table "
2018/06/19 20:09:08 " distance table "
2018/06/19 20:09:08 " write tables "
2018/06/19 20:09:08 " MAKEFIXED "
2018/06/19 20:09:08 " Macros for inflateBack(): "
2018/06/19 20:09:08 " Clear the input bit accumulator "
2018/06/19 20:09:08 " Assure that some input is available.  If input is requested, but denied,\n   then return a Z_BUF_ERROR from inflateBack(). "
2018/06/19 20:09:08 " Get a byte of input into the bit accumulator, or return from inflateBack()\n   with an error if there is no input available. "
2018/06/19 20:09:08 " Assure that there are at least n bits in the bit accumulator.  If there is\n   not enough available input to do that, then return from inflateBack() with\n   an error. "
2018/06/19 20:09:08 " Return the low n bits of the bit accumulator (n <= 16) "
2018/06/19 20:09:08 " Remove n bits from the bit accumulator "
2018/06/19 20:09:08 " Remove zero to seven bits as needed to go to a byte boundary "
2018/06/19 20:09:08 " Assure that some output space is available, by writing out the window\n   if it's full.  If the write fails, return from inflateBack() with a\n   Z_BUF_ERROR. "
2018/06/19 20:09:08 "\n   strm provides the memory allocation functions and window buffer on input,\n   and provides information on the unused input on return.  For Z_DATA_ERROR\n   returns, strm will also provide an error message.\n\n   in() and out() are the call-back input and output functions.  When\n   inflateBack() needs more input, it calls in().  When inflateBack() has\n   filled the window with output, or when it completes with data in the\n   window, it calls out() to write out the data.  The application must not\n   change the provided input until in() is called again or inflateBack()\n   returns.  The application must not change the window/output buffer until\n   inflateBack() returns.\n\n   in() and out() are called with a descriptor parameter provided in the\n   inflateBack() call.  This parameter can be a structure that provides the\n   information required to do the read or write, as well as accumulated\n   information on the input and output such as totals and check values.\n\n   in() should return zero on failure.  out() should return non-zero on\n   failure.  If either in() or out() fails, than inflateBack() returns a\n   Z_BUF_ERROR.  strm->next_in can be checked for Z_NULL to see whether it\n   was in() or out() that caused in the error.  Otherwise,  inflateBack()\n   returns Z_STREAM_END on success, Z_DATA_ERROR for an deflate format\n   error, or Z_MEM_ERROR if it could not allocate memory for the state.\n   inflateBack() can also return Z_STREAM_ERROR if the input parameters\n   are not correct, i.e. strm is Z_NULL or the state was not initialized.\n "
2018/06/19 20:09:08 " next input \n next output \n available input \n available output \n current inflate mode \n true if processing last block \n true if the window has wrapped \n allocated sliding window, if needed \n bit buffer \n bits in bit buffer \n extra bits needed \n literal or length of data to copy \n distance back to copy string from \n number of stored or match bytes to copy \n where to copy match bytes from \n starting table for length/literal codes \n starting table for distance codes \n index bits for lencode \n index bits for distcode \n current decoding table entry \n parent table entry \n length to copy for repeats, bits to drop \n return code \n permutation of code lengths "
2018/06/19 20:09:08 " Check that the strm exists and that the state was initialized "
2018/06/19 20:09:08 " Reset the state "
2018/06/19 20:09:08 " Inflate until end of block marked as last "
2018/06/19 20:09:08 " determine and dispatch block type "
2018/06/19 20:09:08 " stored block "
2018/06/19 20:09:08 " fixed block "
2018/06/19 20:09:08 " decode codes "
2018/06/19 20:09:08 " dynamic block "
2018/06/19 20:09:08 " get and verify stored block length \n go to byte boundary "
2018/06/19 20:09:08 " copy stored block from input to output "
2018/06/19 20:09:08 " get dynamic table entries descriptor "
2018/06/19 20:09:08 " get code length code lengths (not a typo) "
2018/06/19 20:09:08 " get length and distance code code lengths "
2018/06/19 20:09:08 " handle error breaks in while "
2018/06/19 20:09:08 " check for end-of-block code (better have one) "
2018/06/19 20:09:08 " build code tables -- note: do not change the lenbits or distbits\n               values here (9 and 6) without reading the comments in inftree9.h\n               concerning the ENOUGH constants, which depend on those values "
2018/06/19 20:09:08 " get a literal, length, or end-of-block code "
2018/06/19 20:09:08 " process literal "
2018/06/19 20:09:08 " process end of block "
2018/06/19 20:09:08 " invalid code "
2018/06/19 20:09:08 " length code -- get extra bits, if any "
2018/06/19 20:09:08 " get distance code "
2018/06/19 20:09:08 " get distance extra bits, if any "
2018/06/19 20:09:08 " copy match from window to output "
2018/06/19 20:09:08 " inflate stream terminated properly -- write leftover output "
2018/06/19 20:09:08 " can't happen, but makes compilers happy "
2018/06/19 20:09:08 " Return unused input "
2018/06/19 20:09:08 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/infback9/infback9.c": 32.785657ms
2018/06/19 20:09:08 Couldn't classify license(s)
2018/06/19 20:09:09 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/infback9/README
2018/06/19 20:09:09 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/infback9/README": 499.88µs
2018/06/19 20:09:09 Couldn't classify license(s)
2018/06/19 20:09:10 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/iostream/zfstream.cpp
2018/06/19 20:09:10 detected language: 4
2018/06/19 20:09:10 " Hard code the compression level"
2018/06/19 20:09:10 " Put the end-of-string indicator"
2018/06/19 20:09:10 " Hard code the compression level"
2018/06/19 20:09:10 " Put the end-of-string indicator"
2018/06/19 20:09:10 " If the file hasn't been opened for reading, error."
2018/06/19 20:09:10 " if a buffer doesn't exists, allocate one."
2018/06/19 20:09:10 " Attempt to fill the buffer."
2018/06/19 20:09:10 " disable get area"
2018/06/19 20:09:10 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/iostream/zfstream.cpp": 8.194589ms
2018/06/19 20:09:10 Couldn't classify license(s)
2018/06/19 20:09:10 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/iostream/test.cpp
2018/06/19 20:09:10 detected language: 4
2018/06/19 20:09:10 " Construct a stream object with this filebuffer.  Anything sent\n to this stream will go to standard out."
2018/06/19 20:09:10 " This text is getting compressed and sent to stdout.\n To prove this, run 'test | zcat'."
2018/06/19 20:09:10 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/iostream/test.cpp": 1.103773ms
2018/06/19 20:09:10 Couldn't classify license(s)
2018/06/19 20:09:11 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/iostream/zfstream.h
2018/06/19 20:09:11 detected language: 4
2018/06/19 20:09:11 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/iostream/zfstream.h": 448.617µs
2018/06/19 20:09:11 Couldn't classify license(s)
2018/06/19 20:09:12 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/ada/zlib.adb
2018/06/19 20:09:12 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/ada/zlib.adb": 53.934312ms
2018/06/19 20:09:12 Couldn't classify license(s)
2018/06/19 20:09:13 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/ada/zlib.gpr
2018/06/19 20:09:13 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/ada/zlib.gpr": 1.277098ms
2018/06/19 20:09:13 Couldn't classify license(s)
2018/06/19 20:09:13 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/ada/zlib-thin.adb
2018/06/19 20:09:13 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/ada/zlib-thin.adb": 11.525483ms
2018/06/19 20:09:13 Couldn't classify license(s)
2018/06/19 20:09:14 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/ada/test.adb
2018/06/19 20:09:14 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/ada/test.adb": 35.217056ms
2018/06/19 20:09:14 Couldn't classify license(s)
2018/06/19 20:09:15 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/ada/zlib-streams.ads
2018/06/19 20:09:15 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/ada/zlib-streams.ads": 16.342077ms
2018/06/19 20:09:15 Couldn't classify license(s)
2018/06/19 20:09:16 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/ada/mtest.adb
2018/06/19 20:09:16 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/ada/mtest.adb": 15.374238ms
2018/06/19 20:09:16 Couldn't classify license(s)
2018/06/19 20:09:17 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/ada/readme.txt
2018/06/19 20:09:17 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/ada/readme.txt": 11.320584ms
2018/06/19 20:09:17 Couldn't classify license(s)
2018/06/19 20:09:17 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/ada/zlib-streams.adb
2018/06/19 20:09:17 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/ada/zlib-streams.adb": 18.152952ms
2018/06/19 20:09:17 Couldn't classify license(s)
2018/06/19 20:09:18 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/ada/read.adb
2018/06/19 20:09:18 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/ada/read.adb": 15.310136ms
2018/06/19 20:09:18 Couldn't classify license(s)
2018/06/19 20:09:19 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/ada/zlib-thin.ads
2018/06/19 20:09:19 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/ada/zlib-thin.ads": 40.76547ms
2018/06/19 20:09:19 Couldn't classify license(s)
2018/06/19 20:09:20 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/ada/buffer_demo.adb
2018/06/19 20:09:20 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/ada/buffer_demo.adb": 14.393477ms
2018/06/19 20:09:20 Couldn't classify license(s)
2018/06/19 20:09:21 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/ada/zlib.ads
2018/06/19 20:09:21 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/ada/zlib.ads": 40.043596ms
2018/06/19 20:09:21 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/masmx64/bld_ml64.bat
2018/06/19 20:09:21 detected language: 3
2018/06/19 20:09:21 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/masmx64/bld_ml64.bat": 26.847µs
2018/06/19 20:09:21 Couldn't classify license(s)
2018/06/19 20:09:22 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/masmx64/inffas8664.c
2018/06/19 20:09:22 detected language: 4
2018/06/19 20:09:22 " inffas8664.c is a hand tuned assembler version of inffast.c - fast decoding\r\n * version for AMD64 on Windows using Microsoft C compiler\r\n *\r\n * Copyright (C) 1995-2003 Mark Adler\r\n * For conditions of distribution and use, see copyright notice in zlib.h\r\n *\r\n * Copyright (C) 2003 Chris Anderson <christop@charm.net>\r\n * Please use the copyright conditions above.\r\n *\r\n * 2005 - Adaptation to Microsoft C Compiler for AMD64 by Gilles Vollant\r\n *\r\n * inffas8664.c call function inffas8664fnc in inffasx64.asm\r\n *  inffasx64.asm is automatically convert from AMD64 portion of inffas86.c\r\n *\r\n * Dec-29-2003 -- I added AMD64 inflate asm support.  This version is also\r\n * slightly quicker on x86 systems because, instead of using rep movsb to copy\r\n * data, it uses rep movsw, which moves data in 2-byte chunks instead of single\r\n * bytes.  I've tested the AMD64 code on a Fedora Core 1 + the x86_64 updates\r\n * from http://fedora.linux.duke.edu/fc1_x86_64\r\n * which is running on an Athlon 64 3000+ / Gigabyte GA-K8VT800M system with\r\n * 1GB ram.  The 64-bit version is about 4% faster than the 32-bit version,\r\n * when decompressing mozilla-source-1.3.tar.gz.\r\n *\r\n * Mar-13-2003 -- Most of this is derived from inffast.S which is derived from\r\n * the gcc -S output of zlib-1.2.0/inffast.c.  Zlib-1.2.0 is in beta release at\r\n * the moment.  I have successfully compiled and tested this code with gcc2.96,\r\n * gcc3.2, icc5.0, msvc6.0.  It is very close to the speed of inffast.S\r\n * compiled with gcc -DNO_MMX, but inffast.S is still faster on the P3 with MMX\r\n * enabled.  I will attempt to merge the MMX code into this version.  Newer\r\n * versions of this and inffast.S can be found at\r\n * http://www.eetbeetee.com/zlib/ and http://www.charm.net/~christop/zlib/\r\n *\r\n "
2018/06/19 20:09:22 " Mark Adler's comments from inffast.c: "
2018/06/19 20:09:22 "\r\n   Decode literal, length, and distance codes and write out the resulting\r\n   literal and match bytes until either not enough input or output is\r\n   available, an end-of-block is encountered, or a data error is encountered.\r\n   When large enough input and output buffers are supplied to inflate(), for\r\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\r\n   inflate execution time is spent in this routine.\r\n\r\n   Entry assumptions:\r\n\r\n        state->mode == LEN\r\n        strm->avail_in >= 6\r\n        strm->avail_out >= 258\r\n        start >= strm->avail_out\r\n        state->bits < 8\r\n\r\n   On return, state->mode is one of:\r\n\r\n        LEN -- ran out of enough output space or enough available input\r\n        TYPE -- reached end of block code, inflate() to interpret next block\r\n        BAD -- error in block data\r\n\r\n   Notes:\r\n\r\n    - The maximum input bits used by a length/distance pair is 15 bits for the\r\n      length code, 5 bits for the length extra, 15 bits for the distance code,\r\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\r\n      Therefore if strm->avail_in >= 6, then there is enough input to avoid\r\n      checking for available input while decoding.\r\n\r\n    - The maximum bytes that a single length/distance pair can output is 258\r\n      bytes, which is the maximum length that can be coded.  inflate_fast()\r\n      requires strm->avail_out >= 258 for each loop to avoid checking for\r\n      output space.\r\n "
2018/06/19 20:09:22 " 64   32                               x86  x86_64 \n ar offset                              register \n  0    0 \n esp save \n  8    4 \n ebp save \n 16    8 \n esi rsi  local strm->next_in \n 24   12 \n     r9   while in < last \n 32   16 \n edi rdi  local strm->next_out \n 40   20 \n          inflate()'s init next_out \n 48   24 \n     r10  while out < end \n 56   28 \n          size of window, wsize!=0 \n 64   32 \n ebp rbp  local strm->lencode \n 72   36 \n     r11  local strm->distcode \n 80   40 \nunsigned long \n edx rdx  local strm->hold \n 88   44 \n ebx rbx  local strm->bits \n 92   48 \n          window size \n 96   52 \n          window write index \n100   56 \n     r12  mask for lcode \n104   60 \n     r13  mask for dcode \n108   64 \n     r14  match length \n112   68 \n     r15  match distance \n116   72 \n          set when state chng"
2018/06/19 20:09:22 " inflate()'s starting value for strm->avail_out "
2018/06/19 20:09:22 " copy state to local variables "
2018/06/19 20:09:22 " decode literals and length/distances until end-of-block or not enough\r\n       input data or output space "
2018/06/19 20:09:22 " align in on 1/2 hold size boundary "
2018/06/19 20:09:22 " return unused bytes (on entry, bits < 8, so in won't go too far back) "
2018/06/19 20:09:22 " update state and return "
2018/06/19 20:09:22 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/masmx64/inffas8664.c": 19.925893ms
2018/06/19 20:09:22 Couldn't classify license(s)
2018/06/19 20:09:23 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/masmx64/readme.txt
2018/06/19 20:09:23 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/masmx64/readme.txt": 8.9081ms
2018/06/19 20:09:23 Couldn't classify license(s)
2018/06/19 20:09:24 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/masmx64/gvmat64.asm
2018/06/19 20:09:24 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/masmx64/gvmat64.asm": 46.932169ms
2018/06/19 20:09:25 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/masmx64/inffasx64.asm
2018/06/19 20:09:25 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/masmx64/inffasx64.asm": 29.048232ms
2018/06/19 20:09:25 Couldn't classify license(s)
2018/06/19 20:09:25 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/dotzlib/LICENSE_1_0.txt
2018/06/19 20:09:25 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/dotzlib/LICENSE_1_0.txt": 9.507873ms
2018/06/19 20:09:26 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/dotzlib/readme.txt
2018/06/19 20:09:26 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/dotzlib/readme.txt": 11.817205ms
2018/06/19 20:09:26 Couldn't classify license(s)
2018/06/19 20:09:27 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/dotzlib/DotZLib.chm
2018/06/19 20:09:27 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/dotzlib/DotZLib.chm": 389.072544ms
2018/06/19 20:09:27 Couldn't classify license(s)
2018/06/19 20:09:28 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/dotzlib/DotZLib.sln
2018/06/19 20:09:28 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/dotzlib/DotZLib.sln": 7.465806ms
2018/06/19 20:09:28 Couldn't classify license(s)
2018/06/19 20:09:29 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/dotzlib/DotZLib.build
2018/06/19 20:09:29 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/dotzlib/DotZLib.build": 7.776595ms
2018/06/19 20:09:29 Couldn't classify license(s)
2018/06/19 20:09:30 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/dotzlib/DotZLib/AssemblyInfo.cs
2018/06/19 20:09:30 detected language: 8
2018/06/19 20:09:30 "\r\n General Information about an assembly is controlled through the following\r\n set of attributes. Change these attribute values to modify the information\r\n associated with an assembly.\r\n\r"
2018/06/19 20:09:30 "\r\n Version information for an assembly consists of the following four values:\r\n\r\n      Major Version\r\n      Minor Version\r\n      Build Number\r\n      Revision\r\n\r\n You can specify all the values or you can default the Revision and Build Numbers\r\n by using the '*' as shown below:\r"
2018/06/19 20:09:30 "\r\n In order to sign your assembly you must specify a key to use. Refer to the\r\n Microsoft .NET Framework documentation for more information on assembly signing.\r\n\r\n Use the attributes below to control which key is used for signing.\r\n\r\n Notes:\r\n   (*) If no key is specified, the assembly is not signed.\r\n   (*) KeyName refers to a key that has been installed in the Crypto Service\r\n       Provider (CSP) on your machine. KeyFile refers to a file which contains\r\n       a key.\r\n   (*) If the KeyFile and the KeyName values are both specified, the\r\n       following processing occurs:\r\n       (1) If the KeyName can be found in the CSP, that key is used.\r\n       (2) If the KeyName does not exist and the KeyFile does exist, the key\r\n           in the KeyFile is installed into the CSP and used.\r\n   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.\r\n       When specifying the KeyFile, the location of the KeyFile should be\r\n       relative to the project output directory which is\r\n       %Project Directory%\\obj\\<configuration>. For example, if your KeyFile is\r\n       located in the project directory, you would specify the AssemblyKeyFile\r\n       attribute as [assembly: AssemblyKeyFile(\"..\\\\..\\\\mykey.snk\")]\r\n   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework\r\n       documentation for more information on this.\r\n\r"
2018/06/19 20:09:30 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/dotzlib/DotZLib/AssemblyInfo.cs": 9.216124ms
2018/06/19 20:09:30 Couldn't classify license(s)
2018/06/19 20:09:30 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/dotzlib/DotZLib/ChecksumImpl.cs
2018/06/19 20:09:30 detected language: 8
2018/06/19 20:09:30 "\r\n � Copyright Henrik Ravn 2004\r\n\r\n Use, modification and distribution are subject to the Boost Software License, Version 1.0.\r\n (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\r\n\r"
2018/06/19 20:09:30 "/ <summary>\r\n/ Implements the common functionality needed for all <see cref=\"ChecksumGenerator\"/>s\r\n/ </summary>\r\n/ <example></example>\r"
2018/06/19 20:09:30 "/ <summary>\r\n/ The value of the current checksum\r\n/ </summary>\r"
2018/06/19 20:09:30 "/ <summary>\r\n/ Initializes a new instance of the checksum generator base - the current checksum is\r\n/ set to zero\r\n/ </summary>\r"
2018/06/19 20:09:30 "/ <summary>\r\n/ Initializes a new instance of the checksum generator basewith a specified value\r\n/ </summary>\r\n/ <param name=\"initialValue\">The value to set the current checksum to</param>\r"
2018/06/19 20:09:30 "/ <summary>\r\n/ Resets the current checksum to zero\r\n/ </summary>\r"
2018/06/19 20:09:30 "/ <summary>\r\n/ Gets the current checksum value\r\n/ </summary>\r"
2018/06/19 20:09:30 "/ <summary>\r\n/ Updates the current checksum with part of an array of bytes\r\n/ </summary>\r\n/ <param name=\"data\">The data to update the checksum with</param>\r\n/ <param name=\"offset\">Where in <c>data</c> to start updating</param>\r\n/ <param name=\"count\">The number of bytes from <c>data</c> to use</param>\r\n/ <exception cref=\"ArgumentException\">The sum of offset and count is larger than the length of <c>data</c></exception>\r\n/ <exception cref=\"NullReferenceException\"><c>data</c> is a null reference</exception>\r\n/ <exception cref=\"ArgumentOutOfRangeException\">Offset or count is negative.</exception>\r\n/ <remarks>All the other <c>Update</c> methods are implmeneted in terms of this one.\r\n/ This is therefore the only method a derived class has to implement</remarks>\r"
2018/06/19 20:09:30 "/ <summary>\r\n/ Updates the current checksum with an array of bytes.\r\n/ </summary>\r\n/ <param name=\"data\">The data to update the checksum with</param>\r"
2018/06/19 20:09:30 "/ <summary>\r\n/ Updates the current checksum with the data from a string\r\n/ </summary>\r\n/ <param name=\"data\">The string to update the checksum with</param>\r\n/ <remarks>The characters in the string are converted by the UTF-8 encoding</remarks>\r"
2018/06/19 20:09:30 "/ <summary>\r\n/ Updates the current checksum with the data from a string, using a specific encoding\r\n/ </summary>\r\n/ <param name=\"data\">The string to update the checksum with</param>\r\n/ <param name=\"encoding\">The encoding to use</param>\r"
2018/06/19 20:09:30 "/ <summary>\r\n/ Implements a CRC32 checksum generator\r\n/ </summary>\r"
2018/06/19 20:09:30 "/ <summary>\r\n/ Initializes a new instance of the CRC32 checksum generator\r\n/ </summary>\r"
2018/06/19 20:09:30 "/ <summary>\r\n/ Initializes a new instance of the CRC32 checksum generator with a specified value\r\n/ </summary>\r\n/ <param name=\"initialValue\">The value to set the current checksum to</param>\r"
2018/06/19 20:09:30 "/ <summary>\r\n/ Updates the current checksum with part of an array of bytes\r\n/ </summary>\r\n/ <param name=\"data\">The data to update the checksum with</param>\r\n/ <param name=\"offset\">Where in <c>data</c> to start updating</param>\r\n/ <param name=\"count\">The number of bytes from <c>data</c> to use</param>\r\n/ <exception cref=\"ArgumentException\">The sum of offset and count is larger than the length of <c>data</c></exception>\r\n/ <exception cref=\"NullReferenceException\"><c>data</c> is a null reference</exception>\r\n/ <exception cref=\"ArgumentOutOfRangeException\">Offset or count is negative.</exception>\r"
2018/06/19 20:09:30 "/ <summary>\r\n/ Implements a checksum generator that computes the Adler checksum on data\r\n/ </summary>\r"
2018/06/19 20:09:30 "/ <summary>\r\n/ Initializes a new instance of the Adler checksum generator\r\n/ </summary>\r"
2018/06/19 20:09:30 "/ <summary>\r\n/ Initializes a new instance of the Adler checksum generator with a specified value\r\n/ </summary>\r\n/ <param name=\"initialValue\">The value to set the current checksum to</param>\r"
2018/06/19 20:09:30 "/ <summary>\r\n/ Updates the current checksum with part of an array of bytes\r\n/ </summary>\r\n/ <param name=\"data\">The data to update the checksum with</param>\r\n/ <param name=\"offset\">Where in <c>data</c> to start updating</param>\r\n/ <param name=\"count\">The number of bytes from <c>data</c> to use</param>\r\n/ <exception cref=\"ArgumentException\">The sum of offset and count is larger than the length of <c>data</c></exception>\r\n/ <exception cref=\"NullReferenceException\"><c>data</c> is a null reference</exception>\r\n/ <exception cref=\"ArgumentOutOfRangeException\">Offset or count is negative.</exception>\r"
2018/06/19 20:09:30 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/dotzlib/DotZLib/ChecksumImpl.cs": 18.626152ms
2018/06/19 20:09:30 Couldn't classify license(s)
2018/06/19 20:09:31 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/dotzlib/DotZLib/Deflater.cs
2018/06/19 20:09:31 detected language: 8
2018/06/19 20:09:31 "\r\n � Copyright Henrik Ravn 2004\r\n\r\n Use, modification and distribution are subject to the Boost Software License, Version 1.0.\r\n (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\r\n\r"
2018/06/19 20:09:31 "/ <summary>\r\n/ Implements a data compressor, using the deflate algorithm in the ZLib dll\r\n/ </summary>\r"
2018/06/19 20:09:31 "/ <summary>\r\n/ Constructs an new instance of the <c>Deflater</c>\r\n/ </summary>\r\n/ <param name=\"level\">The compression level to use for this <c>Deflater</c></param>\r"
2018/06/19 20:09:31 "/ <summary>\r\n/ Adds more data to the codec to be processed.\r\n/ </summary>\r\n/ <param name=\"data\">Byte array containing the data to be added to the codec</param>\r\n/ <param name=\"offset\">The index of the first byte to add from <c>data</c></param>\r\n/ <param name=\"count\">The number of bytes to add</param>\r\n/ <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>\r"
2018/06/19 20:09:31 "/ <summary>\r\n/ Finishes up any pending data that needs to be processed and handled.\r\n/ </summary>\r"
2018/06/19 20:09:31 "/ <summary>\r\n/ Closes the internal zlib deflate stream\r\n/ </summary>\r"
2018/06/19 20:09:31 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/dotzlib/DotZLib/Deflater.cs": 8.381724ms
2018/06/19 20:09:31 Couldn't classify license(s)
2018/06/19 20:09:32 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/dotzlib/DotZLib/Inflater.cs
2018/06/19 20:09:32 detected language: 8
2018/06/19 20:09:32 "\r\n � Copyright Henrik Ravn 2004\r\n\r\n Use, modification and distribution are subject to the Boost Software License, Version 1.0.\r\n (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\r\n\r"
2018/06/19 20:09:32 "/ <summary>\r\n/ Implements a data decompressor, using the inflate algorithm in the ZLib dll\r\n/ </summary>\r"
2018/06/19 20:09:32 "/ <summary>\r\n/ Constructs an new instance of the <c>Inflater</c>\r\n/ </summary>\r"
2018/06/19 20:09:32 "/ <summary>\r\n/ Adds more data to the codec to be processed.\r\n/ </summary>\r\n/ <param name=\"data\">Byte array containing the data to be added to the codec</param>\r\n/ <param name=\"offset\">The index of the first byte to add from <c>data</c></param>\r\n/ <param name=\"count\">The number of bytes to add</param>\r\n/ <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>\r"
2018/06/19 20:09:32 "/ <summary>\r\n/ Finishes up any pending data that needs to be processed and handled.\r\n/ </summary>\r"
2018/06/19 20:09:32 "/ <summary>\r\n/ Closes the internal zlib inflate stream\r\n/ </summary>\r"
2018/06/19 20:09:32 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/dotzlib/DotZLib/Inflater.cs": 7.556796ms
2018/06/19 20:09:32 Couldn't classify license(s)
2018/06/19 20:09:33 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/dotzlib/DotZLib/UnitTests.cs
2018/06/19 20:09:33 detected language: 8
2018/06/19 20:09:33 "\r\n © Copyright Henrik Ravn 2004\r\n\r\n Use, modification and distribution are subject to the Boost Software License, Version 1.0.\r\n (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\r\n\r"
2018/06/19 20:09:33 " uncomment the define below to include unit tests\r\n#define nunit\r"
2018/06/19 20:09:33 " Unit tests for the DotZLib class library\r\n ----------------------------------------\r\n\r\n Use this with NUnit 2 from http://www.nunit.org\r\n\r"
2018/06/19 20:09:33 " helper methods\r"
2018/06/19 20:09:33 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/dotzlib/DotZLib/UnitTests.cs": 7.469623ms
2018/06/19 20:09:33 Couldn't classify license(s)
2018/06/19 20:09:34 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/dotzlib/DotZLib/GZipStream.cs
2018/06/19 20:09:34 detected language: 8
2018/06/19 20:09:34 "\r\n � Copyright Henrik Ravn 2004\r\n\r\n Use, modification and distribution are subject to the Boost Software License, Version 1.0.\r\n (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\r\n\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ Implements a compressed <see cref=\"Stream\"/>, in GZip (.gz) format.\r\n/ </summary>\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ Creates a new file as a writeable GZipStream\r\n/ </summary>\r\n/ <param name=\"fileName\">The name of the compressed file to create</param>\r\n/ <param name=\"level\">The compression level to use when adding data</param>\r\n/ <exception cref=\"ZLibException\">If an error occurred in the internal zlib function</exception>\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ Opens an existing file as a readable GZipStream\r\n/ </summary>\r\n/ <param name=\"fileName\">The name of the file to open</param>\r\n/ <exception cref=\"ZLibException\">If an error occurred in the internal zlib function</exception>\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ Returns true of this stream can be read from, false otherwise\r\n/ </summary>\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ Returns false.\r\n/ </summary>\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ Returns true if this tsream is writeable, false otherwise\r\n/ </summary>\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ Destroys this instance\r\n/ </summary>\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ Closes the external file handle\r\n/ </summary>\r"
2018/06/19 20:09:34 " Does the actual closing of the file handle.\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ Attempts to read a number of bytes from the stream.\r\n/ </summary>\r\n/ <param name=\"buffer\">The destination data buffer</param>\r\n/ <param name=\"offset\">The index of the first destination byte in <c>buffer</c></param>\r\n/ <param name=\"count\">The number of bytes requested</param>\r\n/ <returns>The number of bytes read</returns>\r\n/ <exception cref=\"ArgumentNullException\">If <c>buffer</c> is null</exception>\r\n/ <exception cref=\"ArgumentOutOfRangeException\">If <c>count</c> or <c>offset</c> are negative</exception>\r\n/ <exception cref=\"ArgumentException\">If <c>offset</c>  + <c>count</c> is &gt; buffer.Length</exception>\r\n/ <exception cref=\"NotSupportedException\">If this stream is not readable.</exception>\r\n/ <exception cref=\"ObjectDisposedException\">If this stream has been disposed.</exception>\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ Attempts to read a single byte from the stream.\r\n/ </summary>\r\n/ <returns>The byte that was read, or -1 in case of error or End-Of-File</returns>\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ Writes a number of bytes to the stream\r\n/ </summary>\r\n/ <param name=\"buffer\"></param>\r\n/ <param name=\"offset\"></param>\r\n/ <param name=\"count\"></param>\r\n/ <exception cref=\"ArgumentNullException\">If <c>buffer</c> is null</exception>\r\n/ <exception cref=\"ArgumentOutOfRangeException\">If <c>count</c> or <c>offset</c> are negative</exception>\r\n/ <exception cref=\"ArgumentException\">If <c>offset</c>  + <c>count</c> is &gt; buffer.Length</exception>\r\n/ <exception cref=\"NotSupportedException\">If this stream is not writeable.</exception>\r\n/ <exception cref=\"ObjectDisposedException\">If this stream has been disposed.</exception>\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ Writes a single byte to the stream\r\n/ </summary>\r\n/ <param name=\"value\">The byte to add to the stream.</param>\r\n/ <exception cref=\"NotSupportedException\">If this stream is not writeable.</exception>\r\n/ <exception cref=\"ObjectDisposedException\">If this stream has been disposed.</exception>\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ Not supported.\r\n/ </summary>\r\n/ <param name=\"value\"></param>\r\n/ <exception cref=\"NotSupportedException\">Always thrown</exception>\r"
2018/06/19 20:09:34 "/ <summary>\r\n/  Not suppported.\r\n/ </summary>\r\n/ <param name=\"offset\"></param>\r\n/ <param name=\"origin\"></param>\r\n/ <returns></returns>\r\n/ <exception cref=\"NotSupportedException\">Always thrown</exception>\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ Flushes the <c>GZipStream</c>.\r\n/ </summary>\r\n/ <remarks>In this implementation, this method does nothing. This is because excessive\r\n/ flushing may degrade the achievable compression rates.</remarks>\r"
2018/06/19 20:09:34 " left empty on purpose\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ Gets/sets the current position in the <c>GZipStream</c>. Not suppported.\r\n/ </summary>\r\n/ <remarks>In this implementation this property is not supported</remarks>\r\n/ <exception cref=\"NotSupportedException\">Always thrown</exception>\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ Gets the size of the stream. Not suppported.\r\n/ </summary>\r\n/ <remarks>In this implementation this property is not supported</remarks>\r\n/ <exception cref=\"NotSupportedException\">Always thrown</exception>\r"
2018/06/19 20:09:34 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/dotzlib/DotZLib/GZipStream.cs": 14.289815ms
2018/06/19 20:09:34 Couldn't classify license(s)
2018/06/19 20:09:34 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/dotzlib/DotZLib/CodecBase.cs
2018/06/19 20:09:34 detected language: 8
2018/06/19 20:09:34 "\r\n � Copyright Henrik Ravn 2004\r\n\r\n Use, modification and distribution are subject to the Boost Software License, Version 1.0.\r\n (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\r\n\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ Implements the common functionality needed for all <see cref=\"Codec\"/>s\r\n/ </summary>\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ Instance of the internal zlib buffer structure that is\r\n/ passed to all functions in the zlib dll\r\n/ </summary>\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ True if the object instance has been disposed, false otherwise\r\n/ </summary>\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ The size of the internal buffers\r\n/ </summary>\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ Initializes a new instance of the <c>CodeBase</c> class.\r\n/ </summary>\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ Occurs when more processed data are available.\r\n/ </summary>\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ Fires the <see cref=\"DataAvailable\"/> event\r\n/ </summary>\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ Adds more data to the codec to be processed.\r\n/ </summary>\r\n/ <param name=\"data\">Byte array containing the data to be added to the codec</param>\r\n/ <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ Adds more data to the codec to be processed.\r\n/ </summary>\r\n/ <param name=\"data\">Byte array containing the data to be added to the codec</param>\r\n/ <param name=\"offset\">The index of the first byte to add from <c>data</c></param>\r\n/ <param name=\"count\">The number of bytes to add</param>\r\n/ <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>\r\n/ <remarks>This must be implemented by a derived class</remarks>\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ Finishes up any pending data that needs to be processed and handled.\r\n/ </summary>\r\n/ <remarks>This must be implemented by a derived class</remarks>\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ Gets the checksum of the data that has been added so far\r\n/ </summary>\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ Destroys this instance\r\n/ </summary>\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ Releases any unmanaged resources and calls the <see cref=\"CleanUp()\"/> method of the derived class\r\n/ </summary>\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ Performs any codec specific cleanup\r\n/ </summary>\r\n/ <remarks>This must be implemented by a derived class</remarks>\r"
2018/06/19 20:09:34 " performs the release of the handles and calls the dereived CleanUp()\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ Copies a number of bytes to the internal codec buffer - ready for proccesing\r\n/ </summary>\r\n/ <param name=\"data\">The byte array that contains the data to copy</param>\r\n/ <param name=\"startIndex\">The index of the first byte to copy</param>\r\n/ <param name=\"count\">The number of bytes to copy from <c>data</c></param>\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ Resets the internal output buffers to a known state - ready for processing\r\n/ </summary>\r"
2018/06/19 20:09:34 "/ <summary>\r\n/ Updates the running checksum property\r\n/ </summary>\r\n/ <param name=\"newSum\">The new checksum value</param>\r"
2018/06/19 20:09:34 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/dotzlib/DotZLib/CodecBase.cs": 11.636624ms
2018/06/19 20:09:34 Couldn't classify license(s)
2018/06/19 20:09:35 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/dotzlib/DotZLib/DotZLib.cs
2018/06/19 20:09:35 detected language: 8
2018/06/19 20:09:35 "\r\n � Copyright Henrik Ravn 2004\r\n\r\n Use, modification and distribution are subject to the Boost Software License, Version 1.0.\r\n (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\r\n\r"
2018/06/19 20:09:35 "/ <summary>\r\n/ Defines constants for the various flush types used with zlib\r\n/ </summary>\r"
2018/06/19 20:09:35 " internal mapping of the zlib zstream structure for marshalling\r"
2018/06/19 20:09:35 "/ <summary>\r\n/ Defines constants for the available compression levels in zlib\r\n/ </summary>\r"
2018/06/19 20:09:35 "/ <summary>\r\n/ The default compression level with a reasonable compromise between compression and speed\r\n/ </summary>\r"
2018/06/19 20:09:35 "/ <summary>\r\n/ No compression at all. The data are passed straight through.\r\n/ </summary>\r"
2018/06/19 20:09:35 "/ <summary>\r\n/ The maximum compression rate available.\r\n/ </summary>\r"
2018/06/19 20:09:35 "/ <summary>\r\n/ The fastest available compression level.\r\n/ </summary>\r"
2018/06/19 20:09:35 "/ <summary>\r\n/ The exception that is thrown when an error occurs on the zlib dll\r\n/ </summary>\r"
2018/06/19 20:09:35 "/ <summary>\r\n/ Initializes a new instance of the <see cref=\"ZLibException\"/> class with a specified\r\n/ error message and error code\r\n/ </summary>\r\n/ <param name=\"errorCode\">The zlib error code that caused the exception</param>\r\n/ <param name=\"msg\">A message that (hopefully) describes the error</param>\r"
2018/06/19 20:09:35 "/ <summary>\r\n/ Initializes a new instance of the <see cref=\"ZLibException\"/> class with a specified\r\n/ error code\r\n/ </summary>\r\n/ <param name=\"errorCode\">The zlib error code that caused the exception</param>\r"
2018/06/19 20:09:35 "/ <summary>\r\n/ Declares methods and properties that enables a running checksum to be calculated\r\n/ </summary>\r"
2018/06/19 20:09:35 "/ <summary>\r\n/ Gets the current value of the checksum\r\n/ </summary>\r"
2018/06/19 20:09:35 "/ <summary>\r\n/ Clears the current checksum to 0\r\n/ </summary>\r"
2018/06/19 20:09:35 "/ <summary>\r\n/ Updates the current checksum with an array of bytes\r\n/ </summary>\r\n/ <param name=\"data\">The data to update the checksum with</param>\r"
2018/06/19 20:09:35 "/ <summary>\r\n/ Updates the current checksum with part of an array of bytes\r\n/ </summary>\r\n/ <param name=\"data\">The data to update the checksum with</param>\r\n/ <param name=\"offset\">Where in <c>data</c> to start updating</param>\r\n/ <param name=\"count\">The number of bytes from <c>data</c> to use</param>\r\n/ <exception cref=\"ArgumentException\">The sum of offset and count is larger than the length of <c>data</c></exception>\r\n/ <exception cref=\"ArgumentNullException\"><c>data</c> is a null reference</exception>\r\n/ <exception cref=\"ArgumentOutOfRangeException\">Offset or count is negative.</exception>\r"
2018/06/19 20:09:35 "/ <summary>\r\n/ Updates the current checksum with the data from a string\r\n/ </summary>\r\n/ <param name=\"data\">The string to update the checksum with</param>\r\n/ <remarks>The characters in the string are converted by the UTF-8 encoding</remarks>\r"
2018/06/19 20:09:35 "/ <summary>\r\n/ Updates the current checksum with the data from a string, using a specific encoding\r\n/ </summary>\r\n/ <param name=\"data\">The string to update the checksum with</param>\r\n/ <param name=\"encoding\">The encoding to use</param>\r"
2018/06/19 20:09:35 "/ <summary>\r\n/ Represents the method that will be called from a codec when new data\r\n/ are available.\r\n/ </summary>\r\n/ <paramref name=\"data\">The byte array containing the processed data</paramref>\r\n/ <paramref name=\"startIndex\">The index of the first processed byte in <c>data</c></paramref>\r\n/ <paramref name=\"count\">The number of processed bytes available</paramref>\r\n/ <remarks>On return from this method, the data may be overwritten, so grab it while you can.\r\n/ You cannot assume that startIndex will be zero.\r\n/ </remarks>\r"
2018/06/19 20:09:35 "/ <summary>\r\n/ Declares methods and events for implementing compressors/decompressors\r\n/ </summary>\r"
2018/06/19 20:09:35 "/ <summary>\r\n/ Occurs when more processed data are available.\r\n/ </summary>\r"
2018/06/19 20:09:35 "/ <summary>\r\n/ Adds more data to the codec to be processed.\r\n/ </summary>\r\n/ <param name=\"data\">Byte array containing the data to be added to the codec</param>\r\n/ <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>\r"
2018/06/19 20:09:35 "/ <summary>\r\n/ Adds more data to the codec to be processed.\r\n/ </summary>\r\n/ <param name=\"data\">Byte array containing the data to be added to the codec</param>\r\n/ <param name=\"offset\">The index of the first byte to add from <c>data</c></param>\r\n/ <param name=\"count\">The number of bytes to add</param>\r\n/ <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>\r"
2018/06/19 20:09:35 "/ <summary>\r\n/ Finishes up any pending data that needs to be processed and handled.\r\n/ </summary>\r"
2018/06/19 20:09:35 "/ <summary>\r\n/ Gets the checksum of the data that has been added so far\r\n/ </summary>\r"
2018/06/19 20:09:35 "/ <summary>\r\n/ Encapsulates general information about the ZLib library\r\n/ </summary>\r"
2018/06/19 20:09:35 " helper function that unpacks a bitsize mask\r"
2018/06/19 20:09:35 "/ <summary>\r\n/ Constructs an instance of the <c>Info</c> class.\r\n/ </summary>\r"
2018/06/19 20:09:35 "/ <summary>\r\n/ True if the library is compiled with debug info\r\n/ </summary>\r"
2018/06/19 20:09:35 "/ <summary>\r\n/ True if the library is compiled with assembly optimizations\r\n/ </summary>\r"
2018/06/19 20:09:35 "/ <summary>\r\n/ Gets the size of the unsigned int that was compiled into Zlib\r\n/ </summary>\r"
2018/06/19 20:09:35 "/ <summary>\r\n/ Gets the size of the unsigned long that was compiled into Zlib\r\n/ </summary>\r"
2018/06/19 20:09:35 "/ <summary>\r\n/ Gets the size of the pointers that were compiled into Zlib\r\n/ </summary>\r"
2018/06/19 20:09:35 "/ <summary>\r\n/ Gets the size of the z_off_t type that was compiled into Zlib\r\n/ </summary>\r"
2018/06/19 20:09:35 "/ <summary>\r\n/ Gets the version of ZLib as a string, e.g. \"1.2.1\"\r\n/ </summary>\r"
2018/06/19 20:09:35 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/dotzlib/DotZLib/DotZLib.cs": 25.862765ms
2018/06/19 20:09:35 Couldn't classify license(s)
2018/06/19 20:09:36 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/dotzlib/DotZLib/CircularBuffer.cs
2018/06/19 20:09:36 detected language: 8
2018/06/19 20:09:36 "\r\n � Copyright Henrik Ravn 2004\r\n\r\n Use, modification and distribution are subject to the Boost Software License, Version 1.0.\r\n (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\r\n\r"
2018/06/19 20:09:36 "/ <summary>\r\n/ This class implements a circular buffer\r\n/ </summary>\r"
2018/06/19 20:09:36 " no room\r"
2018/06/19 20:09:36 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/dotzlib/DotZLib/CircularBuffer.cs": 6.499578ms
2018/06/19 20:09:36 Couldn't classify license(s)
2018/06/19 20:09:37 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/dotzlib/DotZLib/DotZLib.csproj
2018/06/19 20:09:37 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/dotzlib/DotZLib/DotZLib.csproj": 15.996269ms
2018/06/19 20:09:37 Couldn't classify license(s)
2018/06/19 20:09:37 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/iostream2/zstream.h
2018/06/19 20:09:37 detected language: 4
2018/06/19 20:09:37 "\n *\n * Copyright (c) 1997\n * Christian Michelsen Research AS\n * Advanced Computing\n * Fantoftvegen 38, 5036 BERGEN, Norway\n * http://www.cmr.no\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Christian Michelsen Research AS makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n "
2018/06/19 20:09:37 "\n * zstream.h - C++ interface to the 'zlib' general purpose compression library\n * $Id: zstream.h 1.1 1997-06-25 12:00:56+02 tyge Exp tyge $\n "
2018/06/19 20:09:37 "  ----------------------------- izstream -----------------------------"
2018/06/19 20:09:37 " Opens a gzip (.gz) file for reading.\n         * open() can be used to read a file which is not in gzip format;\n         * in this case read() will directly read from the file without\n         * decompression. errno can be checked to distinguish two error\n         * cases (if errno is zero, the zlib error is Z_MEM_ERROR).\n         "
2018/06/19 20:09:37 " Flushes all pending input if necessary, closes the compressed file\n         * and deallocates all the (de)compression state. The return value is\n         * the zlib error number (see function error() below).\n         "
2018/06/19 20:09:37 " Binary read the given number of bytes from the compressed file.\n         "
2018/06/19 20:09:37 " Returns the error message for the last error which occurred on the\n         * given compressed file. errnum is set to zlib error number. If an\n         * error occurred in the file system and not in the compression library,\n         * errnum is set to Z_ERRNO and the application may consult errno\n         * to get the exact error code.\n         "
2018/06/19 20:09:37 "\n * Binary read the given (array of) object(s) from the compressed file.\n * If the input file was not in gzip format, read() copies the objects number\n * of bytes into the buffer.\n * returns the number of uncompressed bytes actually read\n * (0 for end of file, -1 for error).\n "
2018/06/19 20:09:37 "\n * Binary input with the '>' operator.\n "
2018/06/19 20:09:37 "\n * Read length of string + the string with the '>' operator.\n "
2018/06/19 20:09:37 " ----------------------------- ozstream -----------------------------"
2018/06/19 20:09:37 " Opens a gzip (.gz) file for writing.\n         * The compression level parameter should be in 0..9\n         * errno can be checked to distinguish two error cases\n         * (if errno is zero, the zlib error is Z_MEM_ERROR).\n         "
2018/06/19 20:09:37 " open from a FILE pointer.\n         "
2018/06/19 20:09:37 " Flushes all pending output if necessary, closes the compressed file\n         * and deallocates all the (de)compression state. The return value is\n         * the zlib error number (see function error() below).\n         "
2018/06/19 20:09:37 " Binary write the given number of bytes into the compressed file.\n         "
2018/06/19 20:09:37 " Flushes all pending output into the compressed file. The parameter\n         * _flush is as in the deflate() function. The return value is the zlib\n         * error number (see function gzerror below). flush() returns Z_OK if\n         * the flush_ parameter is Z_FINISH and all output could be flushed.\n         * flush() should be called only when strictly necessary because it can\n         * degrade compression.\n         "
2018/06/19 20:09:37 " Returns the error message for the last error which occurred on the\n         * given compressed file. errnum is set to zlib error number. If an\n         * error occurred in the file system and not in the compression library,\n         * errnum is set to Z_ERRNO and the application may consult errno\n         * to get the exact error code.\n         "
2018/06/19 20:09:37 "\n * Binary write the given (array of) object(s) into the compressed file.\n * returns the number of uncompressed bytes actually written\n * (0 in case of error).\n "
2018/06/19 20:09:37 "\n * Binary output with the '<' operator.\n "
2018/06/19 20:09:37 "\n * Write length of string + the string with the '<' operator.\n "
2018/06/19 20:09:37 "\n * Ascii write with the << operator;\n "
2018/06/19 20:09:37 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/iostream2/zstream.h": 19.876293ms
2018/06/19 20:09:37 Couldn't classify license(s)
2018/06/19 20:09:38 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/iostream2/zstream_test.cpp
2018/06/19 20:09:38 detected language: 4
2018/06/19 20:09:38 " read it back"
2018/06/19 20:09:38 " try ascii output; zcat temp.gz to see the results"
2018/06/19 20:09:38 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/iostream2/zstream_test.cpp": 718.065µs
2018/06/19 20:09:38 Couldn't classify license(s)
2018/06/19 20:09:39 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/amd64/amd64-match.S
2018/06/19 20:09:39 detected language: 2
2018/06/19 20:09:39 "\n * match.S -- optimized version of longest_match()\n * based on the similar work by Gilles Vollant, and Brian Raiter, written 1998\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the BSD License. Use by owners of Che Guevarra\n * parafernalia is prohibited, where possible, and highly discouraged\n * elsewhere.\n "
2018/06/19 20:09:39 " high word: current chain len low word: s->wmask "
2018/06/19 20:09:39 "\n * The 258 is a \"magic number, not a parameter -- changing it\n * breaks the hell loose\n "
2018/06/19 20:09:39 " stack frame offsets "
2018/06/19 20:09:39 "\n * On AMD64 the first argument of a function (in our case -- the pointer to\n * deflate_state structure) is passed in %rdi, hence our offsets below are\n * all off of that.\n "
2018/06/19 20:09:39 " you can check the structure offset by running\n\n#include <stdlib.h>\n#include <stdio.h>\n#include \"deflate.h\"\n\nvoid print_depl()\n{\ndeflate_state ds;\ndeflate_state *s=&ds;\nprintf(\"size pointer=%u\\n\",(int)sizeof(void*));\n\nprintf(\"#define dsWSize         (%3u)(%%rdi)\\n\",(int)(((char*)&(s->w_size))-((char*)s)));\nprintf(\"#define dsWMask         (%3u)(%%rdi)\\n\",(int)(((char*)&(s->w_mask))-((char*)s)));\nprintf(\"#define dsWindow        (%3u)(%%rdi)\\n\",(int)(((char*)&(s->window))-((char*)s)));\nprintf(\"#define dsPrev          (%3u)(%%rdi)\\n\",(int)(((char*)&(s->prev))-((char*)s)));\nprintf(\"#define dsMatchLen      (%3u)(%%rdi)\\n\",(int)(((char*)&(s->match_length))-((char*)s)));\nprintf(\"#define dsPrevMatch     (%3u)(%%rdi)\\n\",(int)(((char*)&(s->prev_match))-((char*)s)));\nprintf(\"#define dsStrStart      (%3u)(%%rdi)\\n\",(int)(((char*)&(s->strstart))-((char*)s)));\nprintf(\"#define dsMatchStart    (%3u)(%%rdi)\\n\",(int)(((char*)&(s->match_start))-((char*)s)));\nprintf(\"#define dsLookahead     (%3u)(%%rdi)\\n\",(int)(((char*)&(s->lookahead))-((char*)s)));\nprintf(\"#define dsPrevLen       (%3u)(%%rdi)\\n\",(int)(((char*)&(s->prev_length))-((char*)s)));\nprintf(\"#define dsMaxChainLen   (%3u)(%%rdi)\\n\",(int)(((char*)&(s->max_chain_length))-((char*)s)));\nprintf(\"#define dsGoodMatch     (%3u)(%%rdi)\\n\",(int)(((char*)&(s->good_match))-((char*)s)));\nprintf(\"#define dsNiceMatch     (%3u)(%%rdi)\\n\",(int)(((char*)&(s->nice_match))-((char*)s)));\n}\n\n"
2018/06/19 20:09:39 "\n  to compile for XCode 3.2 on MacOSX x86_64\n  - run \"gcc -g -c -DXCODE_MAC_X64_STRUCTURE amd64-match.S\"\n "
2018/06/19 20:09:39 " uInt longest_match(deflate_state *deflatestate, IPos curmatch) "
2018/06/19 20:09:39 "\n * Retrieve the function arguments. %curmatch will hold cur_match\n * throughout the entire function (passed via rsi on amd64).\n * rdi will hold the pointer to the deflate_state (first arg on amd64)\n "
2018/06/19 20:09:39 " uInt wmask = s->w_mask;\t\t\t\t\t\t\n unsigned chain_length = s->max_chain_length;\t\t\t\t\n if (s->prev_length >= s->good_match) {\t\t\t\t\n     chain_length >>= 2;\t\t\t\t\t\t\n }\t\t\t\t\t\t\t\t\t"
2018/06/19 20:09:39 " chainlen is decremented once beforehand so that the function can\t\n use the sign flag instead of the zero flag for the exit test.\t\n It is then shifted into the high word, to make room for the wmask\t\n value, which it will always accompany.\t\t\t\t"
2018/06/19 20:09:39 " if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;\t"
2018/06/19 20:09:39 " register Bytef *scan = s->window + s->strstart;\t\t\t"
2018/06/19 20:09:39 " Determine how many bytes the scan ptr is off from being\t\t\n dword-aligned.\t\t\t\t\t\t\t"
2018/06/19 20:09:39 " IPos limit = s->strstart > (IPos)MAX_DIST(s) ?\t\t\t\n     s->strstart - (IPos)MAX_DIST(s) : NIL;\t\t\t\t"
2018/06/19 20:09:39 " int best_len = s->prev_length;\t\t\t\t\t"
2018/06/19 20:09:39 " Store the sum of s->window + best_len in %windowbestlen locally, and in memory.\t"
2018/06/19 20:09:39 " register ush scan_start = *(ushf*)scan;\t\t\t\t\n register ush scan_end   = *(ushf*)(scan+best_len-1);\t\t\t\n Posf *prev = s->prev;\t\t\t\t\t\t"
2018/06/19 20:09:39 " Jump into the main loop.\t\t\t\t\t\t"
2018/06/19 20:09:39 " do {\n *     match = s->window + cur_match;\n *     if (*(ushf*)(match+best_len-1) != scan_end ||\n *         *(ushf*)match != scan_start) continue;\n *     [...]\n * } while ((cur_match = prev[cur_match & wmask]) > limit\n *          && --chain_length != 0);\n *\n * Here is the inner loop of the function. The function will spend the\n * majority of its time in this loop, and majority of that time will\n * be spent in the first ten instructions.\n "
2018/06/19 20:09:39 " Store the current value of chainlen.\t\t\t\t\t"
2018/06/19 20:09:39 " %scan is the string under scrutiny, and %prev to the string we\t\n are hoping to match it up with. In actuality, %esi and %edi are\t\n both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and %edx is\t\n initialized to -(MAX_MATCH_8 - scanalign).\t\t\t\t"
2018/06/19 20:09:39 " the prefetching below makes very little difference... "
2018/06/19 20:09:39 "\n * Test the strings for equality, 8 bytes at a time. At the end,\n * adjust %rdx so that it is offset to the exact byte that mismatched.\n *\n * It should be confessed that this loop usually does not represent\n * much of the total running time. Replacing it with a more\n * straightforward \"rep cmpsb\" would not drastically degrade\n * performance -- unrolling it, for example, makes no difference.\n "
2018/06/19 20:09:39 " works, but is 6-7% slower, than non-SSE... "
2018/06/19 20:09:39 " Preload the SSE registers "
2018/06/19 20:09:39 " Check the comparisions' results "
2018/06/19 20:09:39 " this is the only iteration of the loop with a possibility of having\n\t\t   incremented rdx by 0x108 (each loop iteration add 16*4 = 0x40 \n\t\t   and (0x40*4)+8=0x108 "
2018/06/19 20:09:39 "\n * This three-liner is tantalizingly simple, but bsf is a slow instruction,\n * and the complicated alternative down below is quite a bit faster. Sad...\n "
2018/06/19 20:09:39 " find the first non-zero bit \n divide by 8 to get the byte "
2018/06/19 20:09:39 " Check the first 4 bytes "
2018/06/19 20:09:39 " Calculate the length of the match. If it is longer than MAX_MATCH,\t\n then automatically accept it as the best possible match and leave.\t"
2018/06/19 20:09:39 " If the length of the match is not longer than the best match we\t\n have so far, then forget it and return to the lookup loop.\t\t"
2018/06/19 20:09:39 "         s->match_start = cur_match;\t\t\t\t\t\n         best_len = len;\t\t\t\t\t\t\n         if (len >= nice_match) break;\t\t\t\t\n         scan_end = *(ushf*)(scan+best_len-1);\t\t\t"
2018/06/19 20:09:39 " Accept the current string, with the maximum possible length.\t\t"
2018/06/19 20:09:39 " if ((uInt)best_len <= s->lookahead) return (uInt)best_len;\t\t\n return s->lookahead;\t\t\t\t\t\t\t"
2018/06/19 20:09:39 " Restore the registers and return from whence we came.\t\t\t"
2018/06/19 20:09:39 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/amd64/amd64-match.S": 17.222129ms
2018/06/19 20:09:39 Couldn't classify license(s)
2018/06/19 20:09:40 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/testzlib/testzlib.c
2018/06/19 20:09:40 detected language: 4
2018/06/19 20:09:40 " see http://msdn2.microsoft.com/library/twchhe95(en-us,vs.80).aspx for __rdtsc\r"
2018/06/19 20:09:40 "   printf(\"rdtsc = %I64x\\n\",__rdtsc());\r"
2018/06/19 20:09:40 " printf(\"rdtsc = %I64x\\n\",__rdtsc());\r"
2018/06/19 20:09:40 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/testzlib/testzlib.c": 1.478728ms
2018/06/19 20:09:40 Couldn't classify license(s)
2018/06/19 20:09:41 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/testzlib/testzlib.txt
2018/06/19 20:09:41 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/testzlib/testzlib.txt": 765.702µs
2018/06/19 20:09:41 Couldn't classify license(s)
2018/06/19 20:09:41 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/masmx86/readme.txt
2018/06/19 20:09:41 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/masmx86/readme.txt": 1.798591ms
2018/06/19 20:09:41 Couldn't classify license(s)
2018/06/19 20:09:42 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/masmx86/match686.asm
2018/06/19 20:09:42 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/masmx86/match686.asm": 45.121298ms
2018/06/19 20:09:43 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/masmx86/inffas32.asm
2018/06/19 20:09:43 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/masmx86/inffas32.asm": 50.093573ms
2018/06/19 20:09:43 Couldn't classify license(s)
2018/06/19 20:09:44 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/masmx86/bld_ml32.bat
2018/06/19 20:09:44 detected language: 3
2018/06/19 20:09:44 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/masmx86/bld_ml32.bat": 48.217µs
2018/06/19 20:09:44 Couldn't classify license(s)
2018/06/19 20:09:45 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/gcc_gvmat64/gvmat64.S
2018/06/19 20:09:45 detected language: 2
2018/06/19 20:09:45 "\r\n;uInt longest_match_x64(\r\n;    deflate_state *s,\r\n;    IPos cur_match);                             // current match \r\n\r\n; gvmat64.S -- Asm portion of the optimized longest_match for 32 bits x86_64\r\n;  (AMD64 on Athlon 64, Opteron, Phenom\r\n;     and Intel EM64T on Pentium 4 with EM64T, Pentium D, Core 2 Duo, Core I5/I7)\r\n; this file is translation from gvmat64.asm to GCC 4.x (for Linux, Mac XCode)\r\n; Copyright (C) 1995-2010 Jean-loup Gailly, Brian Raiter and Gilles Vollant.\r\n;\r\n; File written by Gilles Vollant, by converting to assembly the longest_match\r\n;  from Jean-loup Gailly in deflate.c of zLib and infoZip zip.\r\n;  and by taking inspiration on asm686 with masm, optimised assembly code\r\n;        from Brian Raiter, written 1998\r\n;\r\n;  This software is provided 'as-is', without any express or implied\r\n;  warranty.  In no event will the authors be held liable for any damages\r\n;  arising from the use of this software.\r\n;\r\n;  Permission is granted to anyone to use this software for any purpose,\r\n;  including commercial applications, and to alter it and redistribute it\r\n;  freely, subject to the following restrictions:\r\n;\r\n;  1. The origin of this software must not be misrepresented; you must not\r\n;     claim that you wrote the original software. If you use this software\r\n;     in a product, an acknowledgment in the product documentation would be\r\n;     appreciated but is not required.\r\n;  2. Altered source versions must be plainly marked as such, and must not be\r\n;     misrepresented as being the original software\r\n;  3. This notice may not be removed or altered from any source distribution.\r\n;\r\n;         http://www.zlib.net\r\n;         http://www.winimage.com/zLibDll\r\n;         http://www.muppetlabs.com/~breadbox/software/assembly.html\r\n;\r\n; to compile this file for zLib, I use option:\r\n;   gcc -c -arch x86_64 gvmat64.S\r\n\r\n\r\n;uInt longest_match(s, cur_match)\r\n;    deflate_state *s;\r\n;    IPos cur_match;                             // current match /\r\n;\r\n; with XCode for Mac, I had strange error with some jump on intel syntax\r\n; this is why BEFORE_JMP and AFTER_JMP are used\r\n "
2018/06/19 20:09:45 "\r\n; register used : rax,rbx,rcx,rdx,rsi,rdi,r8,r9,r10,r11,r12\r\n; free register :  r14,r15\r\n; register can be saved : rsp\r\n"
2018/06/19 20:09:45 "\r\n;  all the +4 offsets are due to the addition of pending_buf_size (in zlib\r\n;  in the deflate_state structure since the asm code was first written\r\n;  (if you compile with zlib 1.0.4 or older, remove the +4).\r\n;  Note : these value are good with a 8 bytes boundary pack structure\r\n"
2018/06/19 20:09:45 "\r\n;;; Offsets for fields in the deflate_state structure. These numbers\r\n;;; are calculated from the definition of deflate_state, with the\r\n;;; assumption that the compiler will dword-align the fields. (Thus,\r\n;;; changing the definition of deflate_state could easily cause this\r\n;;; program to crash horribly, without so much as a warning at\r\n;;; compile time. Sigh.)\r\n\r\n;  all the +zlib1222add offsets are due to the addition of fields\r\n;  in zlib in the deflate_state structure since the asm code was first written\r\n;  (if you compile with zlib 1.0.4 or older, use \"zlib1222add equ (-4)\").\r\n;  (if you compile with zlib between 1.0.5 and 1.2.2.1, use \"zlib1222add equ 0\").\r\n;  if you compile with zlib 1.2.2.2 or later , use \"zlib1222add equ 8\").\r\n"
2018/06/19 20:09:45 " you can check the structure offset by running\r\n\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n#include \"deflate.h\"\r\n\r\nvoid print_depl()\r\n{\r\ndeflate_state ds;\r\ndeflate_state *s=&ds;\r\nprintf(\"size pointer=%u\\n\",(int)sizeof(void*));\r\n\r\nprintf(\"#define dsWSize         %u\\n\",(int)(((char*)&(s->w_size))-((char*)s)));\r\nprintf(\"#define dsWMask         %u\\n\",(int)(((char*)&(s->w_mask))-((char*)s)));\r\nprintf(\"#define dsWindow        %u\\n\",(int)(((char*)&(s->window))-((char*)s)));\r\nprintf(\"#define dsPrev          %u\\n\",(int)(((char*)&(s->prev))-((char*)s)));\r\nprintf(\"#define dsMatchLen      %u\\n\",(int)(((char*)&(s->match_length))-((char*)s)));\r\nprintf(\"#define dsPrevMatch     %u\\n\",(int)(((char*)&(s->prev_match))-((char*)s)));\r\nprintf(\"#define dsStrStart      %u\\n\",(int)(((char*)&(s->strstart))-((char*)s)));\r\nprintf(\"#define dsMatchStart    %u\\n\",(int)(((char*)&(s->match_start))-((char*)s)));\r\nprintf(\"#define dsLookahead     %u\\n\",(int)(((char*)&(s->lookahead))-((char*)s)));\r\nprintf(\"#define dsPrevLen       %u\\n\",(int)(((char*)&(s->prev_length))-((char*)s)));\r\nprintf(\"#define dsMaxChainLen   %u\\n\",(int)(((char*)&(s->max_chain_length))-((char*)s)));\r\nprintf(\"#define dsGoodMatch     %u\\n\",(int)(((char*)&(s->good_match))-((char*)s)));\r\nprintf(\"#define dsNiceMatch     %u\\n\",(int)(((char*)&(s->nice_match))-((char*)s)));\r\n}\r\n"
2018/06/19 20:09:45 "; 0ffffffffh on infozip\r"
2018/06/19 20:09:45 "\r\n; windows:\r\n; parameter 1 in rcx(deflate state s), param 2 in rdx (cur match)\r\n\r\n; see http://weblogs.asp.net/oldnewthing/archive/2004/01/14/58579.aspx and\r\n; http://msdn.microsoft.com/library/en-us/kmarch/hh/kmarch/64bitAMD_8e951dd2-ee77-4728-8702-55ce4b5dd24a.xml.asp\r\n;\r\n; All registers must be preserved across the call, except for\r\n;   rax, rcx, rdx, r8, r9, r10, and r11, which are scratch.\r\n\r\n;\r\n; gcc on macosx-linux:\r\n; see http://www.x86-64.org/documentation/abi-0.99.pdf\r\n; param 1 in rdi, param 2 in rsi\r\n; rbx, rsp, rbp, r12 to r15 must be preserved\r\n\r\n;;; Save registers that the compiler may be using, and adjust esp to\r\n;;; make room for our stack frame.\r\n\r\n\r\n;;; Retrieve the function arguments. r8d will hold cur_match\r\n;;; throughout the entire function. edx will hold the pointer to the\r\n;;; deflate_state structure during the function's setup (before\r\n;;; entering the main loop.\r\n\r\n; ms: parameter 1 in rcx (deflate_state* s), param 2 in edx -> r8 (cur match)\r\n; mac: param 1 in rdi, param 2 rsi\r\n; this clear high 32 bits of r8, which can be garbage in both r8 and rdx\r\n"
2018/06/19 20:09:45 ";;; uInt wmask = s->w_mask;\r\n;;; unsigned chain_length = s->max_chain_length;\r\n;;; if (s->prev_length >= s->good_match) {\r\n;;;     chain_length >>= 2;\r\n;;; }\r"
2018/06/19 20:09:45 ";;; chainlen is decremented once beforehand so that the function can\r\n;;; use the sign flag instead of the zero flag for the exit test.\r\n;;; It is then shifted into the high word, to make room for the wmask\r\n;;; value, which it will always accompany.\r"
2018/06/19 20:09:45 ";;; on zlib only\r\n;;; if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;\r"
2018/06/19 20:09:45 ";;; register Bytef *scan = s->window + s->strstart;\r"
2018/06/19 20:09:45 ";;; Determine how many bytes the scan ptr is off from being\r\n;;; dword-aligned.\r"
2018/06/19 20:09:45 ";;; IPos limit = s->strstart > (IPos)MAX_DIST(s) ?\r\n;;;     s->strstart - (IPos)MAX_DIST(s) : NIL;\r"
2018/06/19 20:09:45 ";;; int best_len = s->prev_length;\r"
2018/06/19 20:09:45 ";;; Store the sum of s->window + best_len in esi locally, and in esi.\r"
2018/06/19 20:09:45 ";;; register ush scan_start = *(ushf*)scan;\r\n;;; register ush scan_end   = *(ushf*)(scan+best_len-1);\r\n;;; Posf *prev = s->prev;\r"
2018/06/19 20:09:45 ";;; Jump into the main loop.\r"
2018/06/19 20:09:45 "\r\n;;; do {\r\n;;;     match = s->window + cur_match;\r\n;;;     if (*(ushf*)(match+best_len-1) != scan_end ||\r\n;;;         *(ushf*)match != scan_start) continue;\r\n;;;     [...]\r\n;;; } while ((cur_match = prev[cur_match & wmask]) > limit\r\n;;;          && --chain_length != 0);\r\n;;;\r\n;;; Here is the inner loop of the function. The function will spend the\r\n;;; majority of its time in this loop, and majority of that time will\r\n;;; be spent in the first ten instructions.\r\n;;;\r\n;;; Within this loop:\r\n;;; ebx = scanend\r\n;;; r8d = curmatch\r\n;;; edx = chainlenwmask - i.e., ((chainlen << 16) | wmask)\r\n;;; esi = windowbestlen - i.e., (window + bestlen)\r\n;;; edi = prev\r\n;;; ebp = limit\r\n"
2018/06/19 20:09:45 ";;; Store the current value of chainlen.\r"
2018/06/19 20:09:45 "\r\n;;; Point edi to the string under scrutiny, and esi to the string we\r\n;;; are hoping to match it up with. In actuality, esi and edi are\r\n;;; both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and edx is\r\n;;; initialized to -(MAX_MATCH_8 - scanalign).\r\n"
2018/06/19 20:09:45 "; -(MAX_MATCH_8)\r\n;MAX_MATCH_8]\r\n;MAX_MATCH_8]\r"
2018/06/19 20:09:45 "\r\n;;; Test the strings for equality, 8 bytes at a time. At the end,\r\n;;; adjust rdx so that it is offset to the exact byte that mismatched.\r\n;;;\r\n;;; We already know at this point that the first three bytes of the\r\n;;; strings match each other, and they can be safely passed over before\r\n;;; starting the compare loop. So what this code does is skip over 0-3\r\n;;; bytes, as much as necessary in order to dword-align the edi\r\n;;; pointer. (rsi will still be misaligned three times out of four.)\r\n;;;\r\n;;; It should be confessed that this loop usually does not represent\r\n;;; much of the total running time. Replacing it with a more\r\n;;; straightforward \"rep cmpsb\" would not drastically degrade\r\n;;; performance.\r\n"
2018/06/19 20:09:45 ";;; Calculate the length of the match. If it is longer than MAX_MATCH,\r\n;;; then automatically accept it as the best possible match and leave.\r"
2018/06/19 20:09:45 "\r\n;;; If the length of the match is not longer than the best match we\r\n;;; have so far, then forget it and return to the lookup loop.\r\n;///////////////////////////////////\r\n"
2018/06/19 20:09:45 "\r\n;;;         s->match_start = cur_match;\r\n;;;         best_len = len;\r\n;;;         if (len >= nice_match) break;\r\n;;;         scan_end = *(ushf*)(scan+best_len-1);\r\n"
2018/06/19 20:09:45 ";;; Accept the current string, with the maximum possible length.\r"
2018/06/19 20:09:45 ";;; if ((uInt)best_len <= s->lookahead) return (uInt)best_len;\r\n;;; return s->lookahead;\r"
2018/06/19 20:09:45 ";;; Restore the stack and return from whence we came.\r"
2018/06/19 20:09:45 "        mov rsi,[save_rsi]\r\n        mov rdi,[save_rdi]\r"
2018/06/19 20:09:45 "; please don't remove this string !\r\n; Your can freely use gvmat64 in any free or commercial app\r\n; but it is far better don't remove the string in the binary!\r\n   db     0dh,0ah,\"asm686 with masm, optimised assembly code from Brian Raiter, written 1998, converted to amd 64 by Gilles Vollant 2005\",0dh,0ah,0\r"
2018/06/19 20:09:45 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/gcc_gvmat64/gvmat64.S": 41.463596ms
2018/06/19 20:09:45 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/iostream3/zfstream.cc
2018/06/19 20:09:45 detected language: 4
2018/06/19 20:09:45 "\n * A C++ I/O streams interface to the zlib gz* functions\n *\n * by Ludwig Schwardt <schwardt@sun.ac.za>\n * original version by Kevin Ruland <kevin@rodin.wustl.edu>\n *\n * This version is standard-compliant and compatible with gcc 3.x.\n "
2018/06/19 20:09:45 " for strcpy, strcat, strlen (mode strings)\n for BUFSIZ"
2018/06/19 20:09:45 " Internal buffer sizes (default and \"unbuffered\" versions)"
2018/06/19 20:09:45 "***************************************************************************"
2018/06/19 20:09:45 " Default constructor"
2018/06/19 20:09:45 " No buffers to start with"
2018/06/19 20:09:45 " Destructor"
2018/06/19 20:09:45 " Sync output buffer and close only if responsible for file\n (i.e. attached streams should be left open at this stage)"
2018/06/19 20:09:45 " Make sure internal buffer is deallocated"
2018/06/19 20:09:45 " Set compression level and strategy"
2018/06/19 20:09:45 " Open gzipped file"
2018/06/19 20:09:45 " Fail if file already open"
2018/06/19 20:09:45 " Don't support simultaneous read/write access (yet)"
2018/06/19 20:09:45 " Build mode string for gzopen and check it [27.8.1.3.2]"
2018/06/19 20:09:45 " Attempt to open file"
2018/06/19 20:09:45 " On success, allocate internal buffer and set flags"
2018/06/19 20:09:45 " Attach to gzipped file"
2018/06/19 20:09:45 " Fail if file already open"
2018/06/19 20:09:45 " Don't support simultaneous read/write access (yet)"
2018/06/19 20:09:45 " Build mode string for gzdopen and check it [27.8.1.3.2]"
2018/06/19 20:09:45 " Attempt to attach to file"
2018/06/19 20:09:45 " On success, allocate internal buffer and set flags"
2018/06/19 20:09:45 " Close gzipped file"
2018/06/19 20:09:45 " Fail immediately if no file is open"
2018/06/19 20:09:45 " Assume success"
2018/06/19 20:09:45 " Attempt to sync and close gzipped file"
2018/06/19 20:09:45 " File is now gone anyway (postcondition [27.8.1.3.8])"
2018/06/19 20:09:45 " Destroy internal buffer if it exists"
2018/06/19 20:09:45 " * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * "
2018/06/19 20:09:45 " Convert int open mode to mode string"
2018/06/19 20:09:45 " Check for valid flag combinations - see [27.8.1.3.2] (Table 92)\n Original zfstream hardcoded the compression level to maximum here...\n Double the time for less than 1% size improvement seems\n excessive though - keeping it at the default level\n To change back, just append \"9\" to the next three mode strings"
2018/06/19 20:09:45 " No read/write mode yet\n  if (testi && testo && !testt && !testa)\n    strcpy(c_mode, \"r+\");\n  if (testi && testo && testt && !testa)\n    strcpy(c_mode, \"w+\");"
2018/06/19 20:09:45 " Mode string should be empty for invalid combination of flags"
2018/06/19 20:09:45 " Determine number of characters in internal get buffer"
2018/06/19 20:09:45 " Calls to underflow will fail if file not opened for reading"
2018/06/19 20:09:45 " Make sure get area is in use"
2018/06/19 20:09:45 " Fill get area from gzipped file"
2018/06/19 20:09:45 " If something is left in the get area by chance, return it\n (this shouldn't normally happen, as underflow is only supposed\n to be called when gptr >= egptr, but it serves as error check)"
2018/06/19 20:09:45 " If the file hasn't been opened for reading, produce error"
2018/06/19 20:09:45 " Attempt to fill internal buffer from gzipped file\n (buffer must be guaranteed to exist...)"
2018/06/19 20:09:45 " Indicates error or EOF"
2018/06/19 20:09:45 " Reset get area"
2018/06/19 20:09:45 " Make all bytes read from file available as get area"
2018/06/19 20:09:45 " Return next character in get area"
2018/06/19 20:09:45 " Write put area to gzipped file"
2018/06/19 20:09:45 " Determine whether put area is in use"
2018/06/19 20:09:45 " Double-check pointer range"
2018/06/19 20:09:45 " Add extra character to buffer if not EOF"
2018/06/19 20:09:45 " Number of characters to write to file"
2018/06/19 20:09:45 " Overflow doesn't fail if nothing is to be written"
2018/06/19 20:09:45 " If the file hasn't been opened for writing, produce error"
2018/06/19 20:09:45 " If gzipped file won't accept all bytes written to it, fail"
2018/06/19 20:09:45 " Reset next pointer to point to pbase on success"
2018/06/19 20:09:45 " Write extra character to file if not EOF"
2018/06/19 20:09:45 " If the file hasn't been opened for writing, produce error"
2018/06/19 20:09:45 " Impromptu char buffer (allows \"unbuffered\" output)"
2018/06/19 20:09:45 " If gzipped file won't accept this character, fail"
2018/06/19 20:09:45 " If you got here, you have succeeded (even if c was EOF)\n The return value should therefore be non-EOF"
2018/06/19 20:09:45 " Assign new buffer"
2018/06/19 20:09:45 " First make sure stuff is sync'ed, for safety"
2018/06/19 20:09:45 " If buffering is turned off on purpose via setbuf(0,0), still allocate one...\n \"Unbuffered\" only really refers to put [27.8.1.4.10], while get needs at\n least a buffer of size 1 (very inefficient though, therefore make it bigger?)\n This follows from [27.5.2.4.3]/12 (gptr needs to point at something, it seems)"
2018/06/19 20:09:45 " Replace existing buffer (if any) with small internal buffer"
2018/06/19 20:09:45 " Replace existing buffer (if any) with external buffer"
2018/06/19 20:09:45 " Write put area to gzipped file (i.e. ensures that put area is empty)"
2018/06/19 20:09:45 " * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * "
2018/06/19 20:09:45 " Allocate internal buffer"
2018/06/19 20:09:45 " If internal buffer required, allocate one"
2018/06/19 20:09:45 " Check for buffered vs. \"unbuffered\""
2018/06/19 20:09:45 " Allocate internal buffer"
2018/06/19 20:09:45 " Get area starts empty and will be expanded by underflow as need arises"
2018/06/19 20:09:45 " Setup entire internal buffer as put area.\n The one-past-end pointer actually points to the last element of the buffer,\n so that overflow(c) can safely add the extra character c to the sequence.\n These pointers remain in place for the duration of the buffer"
2018/06/19 20:09:45 " Even in \"unbuffered\" case, (small?) get buffer is still required"
2018/06/19 20:09:45 " \"Unbuffered\" means no put buffer"
2018/06/19 20:09:45 " If buffer already allocated, reset buffer pointers just to make sure no\n stale chars are lying around"
2018/06/19 20:09:45 " Destroy internal buffer"
2018/06/19 20:09:45 " If internal buffer exists, deallocate it"
2018/06/19 20:09:45 " Preserve unbuffered status by zeroing size"
2018/06/19 20:09:45 " Reset buffer pointers to initial state if external buffer exists"
2018/06/19 20:09:45 "***************************************************************************"
2018/06/19 20:09:45 " Default constructor initializes stream buffer"
2018/06/19 20:09:45 " Initialize stream buffer and open file"
2018/06/19 20:09:45 " Initialize stream buffer and attach to file"
2018/06/19 20:09:45 " Open file and go into fail() state if unsuccessful"
2018/06/19 20:09:45 " Attach to file and go into fail() state if unsuccessful"
2018/06/19 20:09:45 " Close file"
2018/06/19 20:09:45 "***************************************************************************"
2018/06/19 20:09:45 " Default constructor initializes stream buffer"
2018/06/19 20:09:45 " Initialize stream buffer and open file"
2018/06/19 20:09:45 " Initialize stream buffer and attach to file"
2018/06/19 20:09:45 " Open file and go into fail() state if unsuccessful"
2018/06/19 20:09:45 " Attach to file and go into fail() state if unsuccessful"
2018/06/19 20:09:45 " Close file"
2018/06/19 20:09:45 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/iostream3/zfstream.cc": 20.829338ms
2018/06/19 20:09:45 Couldn't classify license(s)
2018/06/19 20:09:46 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/iostream3/test.cc
2018/06/19 20:09:46 detected language: 4
2018/06/19 20:09:46 "\n * Test program for gzifstream and gzofstream\n *\n * by Ludwig Schwardt <schwardt@sun.ac.za>\n * original version by Kevin Ruland <kevin@rodin.wustl.edu>\n "
2018/06/19 20:09:46 " for cout"
2018/06/19 20:09:46 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/iostream3/test.cc": 6.248102ms
2018/06/19 20:09:46 Couldn't classify license(s)
2018/06/19 20:09:47 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/iostream3/zfstream.h
2018/06/19 20:09:47 detected language: 4
2018/06/19 20:09:47 "\n * A C++ I/O streams interface to the zlib gz* functions\n *\n * by Ludwig Schwardt <schwardt@sun.ac.za>\n * original version by Kevin Ruland <kevin@rodin.wustl.edu>\n *\n * This version is standard-compliant and compatible with gcc 3.x.\n "
2018/06/19 20:09:47 " not iostream, since we don't need cin/cout"
2018/06/19 20:09:47 "***************************************************************************"
2018/06/19 20:09:47 "*\n *  @brief  Gzipped file stream buffer class.\n *\n *  This class implements basic_filebuf for gzipped files. It doesn't yet support\n *  seeking (allowed by zlib but slow/limited), putback and read/write access\n *  (tricky). Otherwise, it attempts to be a drop-in replacement for the standard\n *  file streambuf.\n"
2018/06/19 20:09:47 "  Default constructor."
2018/06/19 20:09:47 "  Destructor."
2018/06/19 20:09:47 "*\n   *  @brief  Set compression level and strategy on the fly.\n   *  @param  comp_level  Compression level (see zlib.h for allowed values)\n   *  @param  comp_strategy  Compression strategy (see zlib.h for allowed values)\n   *  @return  Z_OK on success, Z_STREAM_ERROR otherwise.\n   *\n   *  Unfortunately, these parameters cannot be modified separately, as the\n   *  previous zfstream version assumed. Since the strategy is seldom changed,\n   *  it can default and setcompression(level) then becomes like the old\n   *  setcompressionlevel(level).\n  "
2018/06/19 20:09:47 "*\n   *  @brief  Check if file is open.\n   *  @return  True if file is open.\n  "
2018/06/19 20:09:47 "*\n   *  @brief  Open gzipped file.\n   *  @param  name  File name.\n   *  @param  mode  Open mode flags.\n   *  @return  @c this on success, NULL on failure.\n  "
2018/06/19 20:09:47 "*\n   *  @brief  Attach to already open gzipped file.\n   *  @param  fd  File descriptor.\n   *  @param  mode  Open mode flags.\n   *  @return  @c this on success, NULL on failure.\n  "
2018/06/19 20:09:47 "*\n   *  @brief  Close gzipped file.\n   *  @return  @c this on success, NULL on failure.\n  "
2018/06/19 20:09:47 "*\n   *  @brief  Convert ios open mode int to mode string used by zlib.\n   *  @return  True if valid mode flag combination.\n  "
2018/06/19 20:09:47 "*\n   *  @brief  Number of characters available in stream buffer.\n   *  @return  Number of characters.\n   *\n   *  This indicates number of characters in get area of stream buffer.\n   *  These characters can be read without accessing the gzipped file.\n  "
2018/06/19 20:09:47 "*\n   *  @brief  Fill get area from gzipped file.\n   *  @return  First character in get area on success, EOF on error.\n   *\n   *  This actually reads characters from gzipped file to stream\n   *  buffer. Always buffered.\n  "
2018/06/19 20:09:47 "*\n   *  @brief  Write put area to gzipped file.\n   *  @param  c  Extra character to add to buffer contents.\n   *  @return  Non-EOF on success, EOF on error.\n   *\n   *  This actually writes characters in stream buffer to\n   *  gzipped file. With unbuffered output this is done one\n   *  character at a time.\n  "
2018/06/19 20:09:47 "*\n   *  @brief  Installs external stream buffer.\n   *  @param  p  Pointer to char buffer.\n   *  @param  n  Size of external buffer.\n   *  @return  @c this on success, NULL on failure.\n   *\n   *  Call setbuf(0,0) to enable unbuffered output.\n  "
2018/06/19 20:09:47 "*\n   *  @brief  Flush stream buffer to file.\n   *  @return  0 on success, -1 on error.\n   *\n   *  This calls underflow(EOF) to do the job.\n  "
2018/06/19 20:09:47 "\n Some future enhancements\n\n  virtual int_type uflow();\n  virtual int_type pbackfail(int_type c = traits_type::eof());\n  virtual pos_type\n  seekoff(off_type off,\n          std::ios_base::seekdir way,\n          std::ios_base::openmode mode = std::ios_base::in|std::ios_base::out);\n  virtual pos_type\n  seekpos(pos_type sp,\n          std::ios_base::openmode mode = std::ios_base::in|std::ios_base::out);"
2018/06/19 20:09:47 "*\n   *  @brief  Allocate internal buffer.\n   *\n   *  This function is safe to call multiple times. It will ensure\n   *  that a proper internal buffer exists if it is required. If the\n   *  buffer already exists or is external, the buffer pointers will be\n   *  reset to their original state.\n  "
2018/06/19 20:09:47 "*\n   *  @brief  Destroy internal buffer.\n   *\n   *  This function is safe to call multiple times. It will ensure\n   *  that the internal buffer is deallocated if it exists. In any\n   *  case, it will also reset the buffer pointers.\n  "
2018/06/19 20:09:47 "*\n   *  Underlying file pointer.\n  "
2018/06/19 20:09:47 "*\n   *  Mode in which file was opened.\n  "
2018/06/19 20:09:47 "*\n   *  @brief  True if this object owns file descriptor.\n   *\n   *  This makes the class responsible for closing the file\n   *  upon destruction.\n  "
2018/06/19 20:09:47 "*\n   *  @brief  Stream buffer.\n   *\n   *  For simplicity this remains allocated on the free store for the\n   *  entire life span of the gzfilebuf object, unless replaced by setbuf.\n  "
2018/06/19 20:09:47 "*\n   *  @brief  Stream buffer size.\n   *\n   *  Defaults to system default buffer size (typically 8192 bytes).\n   *  Modified by setbuf.\n  "
2018/06/19 20:09:47 "*\n   *  @brief  True if this object owns stream buffer.\n   *\n   *  This makes the class responsible for deleting the buffer\n   *  upon destruction.\n  "
2018/06/19 20:09:47 "***************************************************************************"
2018/06/19 20:09:47 "*\n *  @brief  Gzipped file input stream class.\n *\n *  This class implements ifstream for gzipped files. Seeking and putback\n *  is not supported yet.\n"
2018/06/19 20:09:47 "  Default constructor"
2018/06/19 20:09:47 "*\n   *  @brief  Construct stream on gzipped file to be opened.\n   *  @param  name  File name.\n   *  @param  mode  Open mode flags (forced to contain ios::in).\n  "
2018/06/19 20:09:47 "*\n   *  @brief  Construct stream on already open gzipped file.\n   *  @param  fd    File descriptor.\n   *  @param  mode  Open mode flags (forced to contain ios::in).\n  "
2018/06/19 20:09:47 "*\n   *  Obtain underlying stream buffer.\n  "
2018/06/19 20:09:47 "*\n   *  @brief  Check if file is open.\n   *  @return  True if file is open.\n  "
2018/06/19 20:09:47 "*\n   *  @brief  Open gzipped file.\n   *  @param  name  File name.\n   *  @param  mode  Open mode flags (forced to contain ios::in).\n   *\n   *  Stream will be in state good() if file opens successfully;\n   *  otherwise in state fail(). This differs from the behavior of\n   *  ifstream, which never sets the state to good() and therefore\n   *  won't allow you to reuse the stream for a second file unless\n   *  you manually clear() the state. The choice is a matter of\n   *  convenience.\n  "
2018/06/19 20:09:47 "*\n   *  @brief  Attach to already open gzipped file.\n   *  @param  fd  File descriptor.\n   *  @param  mode  Open mode flags (forced to contain ios::in).\n   *\n   *  Stream will be in state good() if attach succeeded; otherwise\n   *  in state fail().\n  "
2018/06/19 20:09:47 "*\n   *  @brief  Close gzipped file.\n   *\n   *  Stream will be in state fail() if close failed.\n  "
2018/06/19 20:09:47 "*\n   *  Underlying stream buffer.\n  "
2018/06/19 20:09:47 "***************************************************************************"
2018/06/19 20:09:47 "*\n *  @brief  Gzipped file output stream class.\n *\n *  This class implements ofstream for gzipped files. Seeking and putback\n *  is not supported yet.\n"
2018/06/19 20:09:47 "  Default constructor"
2018/06/19 20:09:47 "*\n   *  @brief  Construct stream on gzipped file to be opened.\n   *  @param  name  File name.\n   *  @param  mode  Open mode flags (forced to contain ios::out).\n  "
2018/06/19 20:09:47 "*\n   *  @brief  Construct stream on already open gzipped file.\n   *  @param  fd    File descriptor.\n   *  @param  mode  Open mode flags (forced to contain ios::out).\n  "
2018/06/19 20:09:47 "*\n   *  Obtain underlying stream buffer.\n  "
2018/06/19 20:09:47 "*\n   *  @brief  Check if file is open.\n   *  @return  True if file is open.\n  "
2018/06/19 20:09:47 "*\n   *  @brief  Open gzipped file.\n   *  @param  name  File name.\n   *  @param  mode  Open mode flags (forced to contain ios::out).\n   *\n   *  Stream will be in state good() if file opens successfully;\n   *  otherwise in state fail(). This differs from the behavior of\n   *  ofstream, which never sets the state to good() and therefore\n   *  won't allow you to reuse the stream for a second file unless\n   *  you manually clear() the state. The choice is a matter of\n   *  convenience.\n  "
2018/06/19 20:09:47 "*\n   *  @brief  Attach to already open gzipped file.\n   *  @param  fd  File descriptor.\n   *  @param  mode  Open mode flags (forced to contain ios::out).\n   *\n   *  Stream will be in state good() if attach succeeded; otherwise\n   *  in state fail().\n  "
2018/06/19 20:09:47 "*\n   *  @brief  Close gzipped file.\n   *\n   *  Stream will be in state fail() if close failed.\n  "
2018/06/19 20:09:47 "*\n   *  Underlying stream buffer.\n  "
2018/06/19 20:09:47 "***************************************************************************"
2018/06/19 20:09:47 "*\n *  @brief  Gzipped file output stream manipulator class.\n *\n *  This class defines a two-argument manipulator for gzofstream. It is used\n *  as base for the setcompression(int,int) manipulator.\n"
2018/06/19 20:09:47 " Allows insertor to peek at internals"
2018/06/19 20:09:47 " Constructor"
2018/06/19 20:09:47 " Underlying manipulator function"
2018/06/19 20:09:47 " Arguments for manipulator function"
2018/06/19 20:09:47 "***************************************************************************"
2018/06/19 20:09:47 " Manipulator function thunks through to stream buffer"
2018/06/19 20:09:47 " Manipulator constructor stores arguments"
2018/06/19 20:09:47 " Insertor applies underlying manipulator function to stream"
2018/06/19 20:09:47 " Insert this onto stream to simplify setting of compression level"
2018/06/19 20:09:47 " ZFSTREAM_H"
2018/06/19 20:09:47 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/iostream3/zfstream.h": 28.637449ms
2018/06/19 20:09:47 Couldn't classify license(s)
2018/06/19 20:09:48 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/iostream3/TODO
2018/06/19 20:09:48 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/iostream3/TODO": 1.183904ms
2018/06/19 20:09:48 Couldn't classify license(s)
2018/06/19 20:09:49 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/iostream3/README
2018/06/19 20:09:49 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/iostream3/README": 9.00997ms
2018/06/19 20:09:49 Couldn't classify license(s)
2018/06/19 20:09:49 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/delphi/zlibd32.mak
2018/06/19 20:09:50 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/delphi/zlibd32.mak": 4.417099ms
2018/06/19 20:09:50 Couldn't classify license(s)
2018/06/19 20:09:50 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/delphi/readme.txt
2018/06/19 20:09:50 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/delphi/readme.txt": 12.036573ms
2018/06/19 20:09:50 Couldn't classify license(s)
2018/06/19 20:09:51 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/delphi/ZLibConst.pas
2018/06/19 20:09:51 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/delphi/ZLibConst.pas": 756.745µs
2018/06/19 20:09:51 Couldn't classify license(s)
2018/06/19 20:09:52 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/delphi/ZLib.pas
2018/06/19 20:09:52 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/delphi/ZLib.pas": 48.45965ms
2018/06/19 20:09:52 Couldn't classify license(s)
2018/06/19 20:09:53 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/untgz/Makefile
2018/06/19 20:09:53 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/untgz/Makefile": 828.53µs
2018/06/19 20:09:53 Couldn't classify license(s)
2018/06/19 20:09:53 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/untgz/Makefile.msc
2018/06/19 20:09:53 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/untgz/Makefile.msc": 939.643µs
2018/06/19 20:09:53 Couldn't classify license(s)
2018/06/19 20:09:54 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/untgz/untgz.c
2018/06/19 20:09:54 detected language: 4
2018/06/19 20:09:54 "\n * untgz.c -- Display contents and extract files from a gzip'd TAR file\n *\n * written by Pedro A. Aranda Gutierrez <paag@tid.es>\n * adaptation to Unix by Jean-loup Gailly <jloup@gzip.org>\n * various fixes by Cosmin Truta <cosmint@cs.ubbcluj.ro>\n "
2018/06/19 20:09:54 " values used in typeflag field "
2018/06/19 20:09:54 " regular file \n regular file \n link \n reserved \n character special \n block special \n directory \n FIFO special \n reserved "
2018/06/19 20:09:54 " GNU tar extensions "
2018/06/19 20:09:54 " file names from dumped directory \n long link name \n long file name \n continuation of file from another volume \n file name that does not fit into main hdr \n sparse file \n tape/volume header "
2018/06/19 20:09:54 " tar header "
2018/06/19 20:09:54 " byte offset \n   0 \n 100 \n 108 \n 116 \n 124 \n 136 \n 148 \n 156 \n 157 \n 257 \n 263 \n 265 \n 297 \n 329 \n 337 \n 345 \n 500 "
2018/06/19 20:09:54 " return the file name of the TGZ archive \n or NULL if it does not exist "
2018/06/19 20:09:54 " error message for the filename "
2018/06/19 20:09:54 " convert octal digits to int \n on error return -1 "
2018/06/19 20:09:54 " convert time_t to string \n use the \"YYYY/MM/DD hh:mm:ss\" format "
2018/06/19 20:09:54 " set file time "
2018/06/19 20:09:54 " push file attributes "
2018/06/19 20:09:54 " restore file attributes "
2018/06/19 20:09:54 " match regular expression "
2018/06/19 20:09:54 " recursive mkdir \n abort on ENOENT; ignore other errors like \"directory already exists\" \n return 1 if OK \n        0 on error "
2018/06/19 20:09:54 " no arguments given (untgz tgzarchive) "
2018/06/19 20:09:54 " ignore this for the moment being "
2018/06/19 20:09:54 " tar file list or extract "
2018/06/19 20:09:54 "\n       * Always expect complete blocks to process\n       * the tar information.\n       "
2018/06/19 20:09:54 " force error exit \n force I/O cleanup "
2018/06/19 20:09:54 "\n       * If we have to get a tar header\n       "
2018/06/19 20:09:54 "\n           * if we met the end of the tar\n           * or the end-of-tar block,\n           * we are done\n           "
2018/06/19 20:09:54 "\n               * The file name is longer than SHORTNAMESIZE\n               "
2018/06/19 20:09:54 "\n           * Act according to the type flag\n           "
2018/06/19 20:09:54 " try creating directory "
2018/06/19 20:09:54 "\n       * Abandon if errors are found\n       "
2018/06/19 20:09:54 "\n   * Restore file modes and time stamps\n   "
2018/06/19 20:09:54 " ============================================================ "
2018/06/19 20:09:54 " ============================================================ "
2018/06/19 20:09:54 " disable argument globbing in MinGW "
2018/06/19 20:09:54 "\n *  Process the TGZ file\n "
2018/06/19 20:09:54 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/untgz/untgz.c": 6.4684ms
2018/06/19 20:09:54 Couldn't classify license(s)
2018/06/19 20:09:55 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/inflate86/inffast.S
2018/06/19 20:09:55 detected language: 2
2018/06/19 20:09:55 "\n * inffast.S is a hand tuned assembler version of:\n *\n * inffast.c -- fast decoding\n * Copyright (C) 1995-2003 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n *\n * Copyright (C) 2003 Chris Anderson <christop@charm.net>\n * Please use the copyright conditions above.\n *\n * This version (Jan-23-2003) of inflate_fast was coded and tested under\n * GNU/Linux on a pentium 3, using the gcc-3.2 compiler distribution.  On that\n * machine, I found that gzip style archives decompressed about 20% faster than\n * the gcc-3.2 -O3 -fomit-frame-pointer compiled version.  Your results will\n * depend on how large of a buffer is used for z_stream.next_in & next_out\n * (8K-32K worked best for my 256K cpu cache) and how much overhead there is in\n * stream processing I/O and crc32/addler32.  In my case, this routine used\n * 70% of the cpu time and crc32 used 20%.\n *\n * I am confident that this version will work in the general case, but I have\n * not tested a wide variety of datasets or a wide variety of platforms.\n *\n * Jan-24-2003 -- Added -DUSE_MMX define for slightly faster inflating.\n * It should be a runtime flag instead of compile time flag...\n *\n * Jan-26-2003 -- Added runtime check for MMX support with cpuid instruction.\n * With -DUSE_MMX, only MMX code is compiled.  With -DNO_MMX, only non-MMX code\n * is compiled.  Without either option, runtime detection is enabled.  Runtime\n * detection should work on all modern cpus and the recomended algorithm (flip\n * ID bit on eflags and then use the cpuid instruction) is used in many\n * multimedia applications.  Tested under win2k with gcc-2.95 and gas-2.12\n * distributed with cygwin3.  Compiling with gcc-2.95 -c inffast.S -o\n * inffast.obj generates a COFF object which can then be linked with MSVC++\n * compiled code.  Tested under FreeBSD 4.7 with gcc-2.95.\n *\n * Jan-28-2003 -- Tested Athlon XP... MMX mode is slower than no MMX (and\n * slower than compiler generated code).  Adjusted cpuid check to use the MMX\n * code only for Pentiums < P4 until I have more data on the P4.  Speed\n * improvment is only about 15% on the Athlon when compared with code generated\n * with MSVC++.  Not sure yet, but I think the P4 will also be slower using the\n * MMX mode because many of it's x86 ALU instructions execute in .5 cycles and\n * have less latency than MMX ops.  Added code to buffer the last 11 bytes of\n * the input stream since the MMX code grabs bits in chunks of 32, which\n * differs from the inffast.c algorithm.  I don't think there would have been\n * read overruns where a page boundary was crossed (a segfault), but there\n * could have been overruns when next_in ends on unaligned memory (unintialized\n * memory read).\n *\n * Mar-13-2003 -- P4 MMX is slightly slower than P4 NO_MMX.  I created a C\n * version of the non-MMX code so that it doesn't depend on zstrm and zstate\n * structure offsets which are hard coded in this file.  This was last tested\n * with zlib-1.2.0 which is currently in beta testing, newer versions of this\n * and inffas86.c can be found at http://www.eetbeetee.com/zlib/ and\n * http://www.charm.net/~christop/zlib/\n "
2018/06/19 20:09:55 "\n * if you have underscore linking problems (_inflate_fast undefined), try\n * using -DGAS_COFF\n "
2018/06/19 20:09:55 " windows object format "
2018/06/19 20:09:55 " ! GAS_COFF && ! GAS_ELF "
2018/06/19 20:09:55 " coff externals have underscores "
2018/06/19 20:09:55 " GAS_COFF "
2018/06/19 20:09:55 " mask[N] = ( 1 << N ) - 1 "
2018/06/19 20:09:55 " NO_MMX "
2018/06/19 20:09:55 "\n * struct z_stream offsets, in zlib.h\n "
2018/06/19 20:09:55 " strm->next_in \n strm->avail_in \n strm->next_out \n strm->avail_out \n strm->msg \n strm->state "
2018/06/19 20:09:55 "\n * struct inflate_state offsets, in inflate.h\n "
2018/06/19 20:09:55 " state->mode \n state->wsize \n state->write \n state->window \n state->hold \n state->bits \n state->lencode \n state->distcode \n state->lenbits \n state->distbits "
2018/06/19 20:09:55 "\n * inflate_fast's activation record\n "
2018/06/19 20:09:55 " how much local space for vars \n first arg: z_stream * (local_var_size + 24) \n second arg: unsigned int (local_var_size + 28) "
2018/06/19 20:09:55 "\n * offsets for local vars on stack\n "
2018/06/19 20:09:55 " unsigned char* \n unsigned char* \n unsigned int \n unsigned int \n unsigned char* \n unsigned char* \n char[ 12 ] \n unsigned int \n unsigned char* \n unsigned char* \n code* \n code* \n unsigned int \n unsigned int "
2018/06/19 20:09:55 "\n * typedef enum inflate_mode consts, in inflate.h\n "
2018/06/19 20:09:55 " state->mode flags enum-ed in inflate.h "
2018/06/19 20:09:55 " integer flag for run time control 1=check,2=mmx,3=no "
2018/06/19 20:09:55 " elf info "
2018/06/19 20:09:55 " RUN_TIME_MMX "
2018/06/19 20:09:55 " coff info: scl 2 = extern, type 32 = function "
2018/06/19 20:09:55 " save eflags (strm_sp, state_sp assumes this is 32 bits) "
2018/06/19 20:09:55 " in = strm->next_in;\n         * out = strm->next_out;\n         * last = in + strm->avail_in - 11;\n         * beg = out - (start - strm->avail_out);\n         * end = out + (strm->avail_out - 257);\n         "
2018/06/19 20:09:55 " avail_in += next_in \n avail_in -= 11 "
2018/06/19 20:09:55 " start -= avail_out \n start = -start \n start += next_out "
2018/06/19 20:09:55 " avail_out -= 257 \n avail_out += out "
2018/06/19 20:09:55 " wsize = state->wsize;\n         * write = state->write;\n         * window = state->window;\n         * hold = state->hold;\n         * bits = state->bits;\n         * lcode = state->lencode;\n         * dcode = state->distcode;\n         * lmask = ( 1 << state->lenbits ) - 1;\n         * dmask = ( 1 << state->distbits ) - 1;\n         "
2018/06/19 20:09:55 " if in < last "
2018/06/19 20:09:55 " ecx = &in[ avail_in ] \n ecx = avail_in "
2018/06/19 20:09:55 " eax = 12 - avail_in "
2018/06/19 20:09:55 " memcpy( buf, in, avail_in ) "
2018/06/19 20:09:55 " memset( &buf[ avail_in ], 0, 12 - avail_in ) \n in = buf \n last = in, do just one iteration "
2018/06/19 20:09:55 " align in_r on long boundary "
2018/06/19 20:09:55 "** Runtime MMX check **"
2018/06/19 20:09:55 " > 2 "
2018/06/19 20:09:55 " copy eflags to eax \n try toggling ID bit of eflags (bit 21)\n                                   * to see if cpu supports cpuid...\n                                   * ID bit method not supported by NexGen but\n                                   * bios may load a cpuid instruction and\n                                   * cpuid may be disabled on Cyrix 5-6x86 "
2018/06/19 20:09:55 " copy new eflags to edx \n test if ID bit is flipped \n not flipped if zero "
2018/06/19 20:09:55 " check for GenuineIntel in ebx,ecx,edx "
2018/06/19 20:09:55 " get cpu features "
2018/06/19 20:09:55 " check for Pentium family, is 0xf for P4 "
2018/06/19 20:09:55 " test if MMX feature is set (bit 23) "
2018/06/19 20:09:55 "** Non-MMX code **"
2018/06/19 20:09:55 " while (in < last && out < end)\n         "
2018/06/19 20:09:55 " if (out >= end) "
2018/06/19 20:09:55 " regs: %esi = in, %ebp = hold, %bl = bits, %edi = out\n         *\n         * do {\n         *   if (bits < 15) {\n         *     hold |= *((unsigned short *)in)++ << bits;\n         *     bits += 16\n         *   }\n         *   this = lcode[hold & lmask]\n         "
2018/06/19 20:09:55 " if (15 < bits) "
2018/06/19 20:09:55 " al = *(ushort *)in++ \n cl = bits, needs it for shifting \n bits += 16 "
2018/06/19 20:09:55 " hold |= *((ushort *)in)++ << bits "
2018/06/19 20:09:55 " edx = lmask \n ecx = lcode \n edx &= hold \n eax = lcode[hold & lmask] "
2018/06/19 20:09:55 " regs: %esi = in, %ebp = hold, %bl = bits, %edi = out\n         *\n         * dolen:\n         *    bits -= this.bits;\n         *    hold >>= this.bits\n         "
2018/06/19 20:09:55 " cl = this.bits \n bits -= this.bits \n hold >>= this.bits "
2018/06/19 20:09:55 " check if op is a literal\n         * if (op == 0) {\n         *    PUP(out) = this.val;\n         *  }\n         "
2018/06/19 20:09:55 " if (op != 0) 45.7% "
2018/06/19 20:09:55 " output this.val char "
2018/06/19 20:09:55 " regs: %esi = in, %ebp = hold, %bl = bits, %edi = out, %edx = len\n         *\n         * else if (op & 16) {\n         *   len = this.val\n         *   op &= 15\n         *   if (op) {\n         *     if (op > bits) {\n         *       hold |= *((unsigned short *)in)++ << bits;\n         *       bits += 16\n         *     }\n         *     len += hold & mask[op];\n         *     bits -= op;\n         *     hold >>= op;\n         *   }\n         "
2018/06/19 20:09:55 " len = this \n len = this.val "
2018/06/19 20:09:55 " if ((op & 16) == 0) 8% \n op &= 15 \n if (!op) "
2018/06/19 20:09:55 " if (op <= bits) "
2018/06/19 20:09:55 " stash op in ch, freeing cl "
2018/06/19 20:09:55 " al = *(ushort *)in++ \n cl = bits, needs it for shifting \n bits += 16 "
2018/06/19 20:09:55 " hold |= *((ushort *)in)++ << bits \n move op back to ecx "
2018/06/19 20:09:55 " eax &= hold "
2018/06/19 20:09:55 " len += hold & mask[op] "
2018/06/19 20:09:55 " save len "
2018/06/19 20:09:55 " regs: %esi = in, %ebp = hold, %bl = bits, %edi = out, %edx = dist\n         *\n         *   if (bits < 15) {\n         *     hold |= *((unsigned short *)in)++ << bits;\n         *     bits += 16\n         *   }\n         *   this = dcode[hold & dmask];\n         * dodist:\n         *   bits -= this.bits;\n         *   hold >>= this.bits;\n         *   op = this.op;\n         "
2018/06/19 20:09:55 " if (15 < bits) "
2018/06/19 20:09:55 " al = *(ushort *)in++ \n cl = bits, needs it for shifting \n bits += 16 "
2018/06/19 20:09:55 " hold |= *((ushort *)in)++ << bits "
2018/06/19 20:09:55 " edx = dmask \n ecx = dcode \n edx &= hold \n eax = dcode[hold & dmask] "
2018/06/19 20:09:55 " dist = this \n dist = this.val "
2018/06/19 20:09:55 " bits -= this.bits \n hold >>= this.bits "
2018/06/19 20:09:55 " if (op & 16) {\n         *   dist = this.val\n         *   op &= 15\n         *   if (op > bits) {\n         *     hold |= *((unsigned short *)in)++ << bits;\n         *     bits += 16\n         *   }\n         *   dist += hold & mask[op];\n         *   bits -= op;\n         *   hold >>= op;\n         "
2018/06/19 20:09:55 " cl = this.op "
2018/06/19 20:09:55 " if ((op & 16) == 0) "
2018/06/19 20:09:55 " op &= 15 "
2018/06/19 20:09:55 " if (op <= bits) 97.6% "
2018/06/19 20:09:55 " stash op in ch, freeing cl "
2018/06/19 20:09:55 " al = *(ushort *)in++ \n cl = bits, needs it for shifting \n bits += 16 "
2018/06/19 20:09:55 " hold |= *((ushort *)in)++ << bits \n move op back to ecx "
2018/06/19 20:09:55 " (1 << op) - 1 "
2018/06/19 20:09:55 " eax &= hold "
2018/06/19 20:09:55 " dist += hold & ((1 << op) - 1) "
2018/06/19 20:09:55 " regs: %esi = from, %ebp = hold, %bl = bits, %edi = out, %edx = dist\n         *       %ecx = nbytes\n         *\n         * nbytes = out - beg;\n         * if (dist <= nbytes) {\n         *   from = out - dist;\n         *   do {\n         *     PUP(out) = PUP(from);\n         *   } while (--len > 0) {\n         * }\n         "
2018/06/19 20:09:55 " save in so from can use it's reg "
2018/06/19 20:09:55 " nbytes = out - beg "
2018/06/19 20:09:55 " if (dist > nbytes) 4.2% "
2018/06/19 20:09:55 " from = out - dist "
2018/06/19 20:09:55 " move in back to %esi, toss from "
2018/06/19 20:09:55 " else if ((op & 64) == 0) {\n         *   this = lcode[this.val + (hold & mask[op])];\n         * }\n         "
2018/06/19 20:09:55 " if ((op & 64) != 0) "
2018/06/19 20:09:55 " eax &= hold \n eax += this.val \n edx = lcode \n eax = lcode[val + (hold&mask[op])] "
2018/06/19 20:09:55 " else if ((op & 64) == 0) {\n         *   this = dcode[this.val + (hold & mask[op])];\n         * }\n         "
2018/06/19 20:09:55 " if ((op & 64) != 0) "
2018/06/19 20:09:55 " eax &= hold \n eax += this.val \n edx = dcode \n eax = dcode[val + (hold&mask[op])] "
2018/06/19 20:09:55 " regs: %esi = from, %ebp = hold, %bl = bits, %edi = out, %edx = dist\n         *       %ecx = nbytes\n         *\n         * else {\n         *   if (dist > wsize) {\n         *     invalid distance\n         *   }\n         *   from = window;\n         *   nbytes = dist - nbytes;\n         *   if (write == 0) {\n         *     from += wsize - nbytes;\n         "
2018/06/19 20:09:55 " prepare for dist compare \n nbytes = -nbytes \n from = window "
2018/06/19 20:09:55 " if (dist > wsize) "
2018/06/19 20:09:55 " nbytes = dist - nbytes "
2018/06/19 20:09:55 " if (write != 0) "
2018/06/19 20:09:55 " from += wsize - nbytes "
2018/06/19 20:09:55 " regs: %esi = from, %ebp = hold, %bl = bits, %edi = out, %edx = dist\n         *       %ecx = nbytes, %eax = len\n         *\n         *     if (nbytes < len) {\n         *       len -= nbytes;\n         *       do {\n         *         PUP(out) = PUP(from);\n         *       } while (--nbytes);\n         *       from = out - dist;\n         *     }\n         *   }\n         "
2018/06/19 20:09:55 " if (nbytes >= len) "
2018/06/19 20:09:55 " len -= nbytes "
2018/06/19 20:09:55 " from = out - dist "
2018/06/19 20:09:55 " if (nbytes >= len) "
2018/06/19 20:09:55 " len -= nbytes "
2018/06/19 20:09:55 " from = out - dist "
2018/06/19 20:09:55 " regs: %esi = from, %ebp = hold, %bl = bits, %edi = out, %edx = dist\n         *       %ecx = nbytes, %eax = write, %eax = len\n         *\n         *   else if (write < nbytes) {\n         *     from += wsize + write - nbytes;\n         *     nbytes -= write;\n         *     if (nbytes < len) {\n         *       len -= nbytes;\n         *       do {\n         *         PUP(out) = PUP(from);\n         *       } while (--nbytes);\n         *       from = window;\n         *       nbytes = write;\n         *       if (nbytes < len) {\n         *         len -= nbytes;\n         *         do {\n         *           PUP(out) = PUP(from);\n         *         } while(--nbytes);\n         *         from = out - dist;\n         *       }\n         *     }\n         *   }\n         "
2018/06/19 20:09:55 " if (write >= nbytes) "
2018/06/19 20:09:55 " from += wsize + write - nbytes \n nbytes -= write "
2018/06/19 20:09:55 " if (nbytes >= len) "
2018/06/19 20:09:55 " len -= nbytes "
2018/06/19 20:09:55 " from = window \n nbytes = write "
2018/06/19 20:09:55 " if (nbytes >= len) "
2018/06/19 20:09:55 " len -= nbytes "
2018/06/19 20:09:55 " from = out - dist "
2018/06/19 20:09:55 " regs: %esi = from, %ebp = hold, %bl = bits, %edi = out, %edx = dist\n         *       %ecx = nbytes, %eax = write, %eax = len\n         *\n         *   else {\n         *     from += write - nbytes;\n         *     if (nbytes < len) {\n         *       len -= nbytes;\n         *       do {\n         *         PUP(out) = PUP(from);\n         *       } while (--nbytes);\n         *       from = out - dist;\n         *     }\n         *   }\n         "
2018/06/19 20:09:55 " from += write - nbytes "
2018/06/19 20:09:55 " if (nbytes >= len) "
2018/06/19 20:09:55 " len -= nbytes "
2018/06/19 20:09:55 " from = out - dist "
2018/06/19 20:09:55 " regs: %esi = from, %esi = in, %ebp = hold, %bl = bits, %edi = out\n         *       %eax = len\n         *\n         *     while (len > 0) {\n         *       PUP(out) = PUP(from);\n         *       len--;\n         *     }\n         *   }\n         * } while (in < last && out < end);\n         "
2018/06/19 20:09:55 " move in back to %esi, toss from "
2018/06/19 20:09:55 " NO_MMX || RUN_TIME_MMX "
2018/06/19 20:09:55 "** MMX code **"
2018/06/19 20:09:55 " ebx = lcode "
2018/06/19 20:09:55 " while (in < last && out < end)\n         "
2018/06/19 20:09:55 " if (out >= end) "
2018/06/19 20:09:55 " hold_mm >>= last bit length "
2018/06/19 20:09:55 " if (32 < bits) "
2018/06/19 20:09:55 " hold_mm |= *((uint *)in)++ << bits "
2018/06/19 20:09:55 " eax = lcode[hold & lmask] "
2018/06/19 20:09:55 " ecx = this.bits "
2018/06/19 20:09:55 " bits -= this.bits "
2018/06/19 20:09:55 " if (op != 0) 45.7% "
2018/06/19 20:09:55 " output this.val char "
2018/06/19 20:09:55 " len = this \n len = this.val "
2018/06/19 20:09:55 " if ((op & 16) == 0) 8% \n op &= 15 \n if (!op) "
2018/06/19 20:09:55 " hold_mm >>= last bit length "
2018/06/19 20:09:55 " len += hold & mask[op] "
2018/06/19 20:09:55 " hold_mm >>= last bit length "
2018/06/19 20:09:55 " if (32 < bits) "
2018/06/19 20:09:55 " hold_mm |= *((uint *)in)++ << bits "
2018/06/19 20:09:55 " ebx = dcode "
2018/06/19 20:09:55 " eax = dcode[hold & lmask] "
2018/06/19 20:09:55 " ecx = this.bits "
2018/06/19 20:09:55 " dist  = this.val \n bits -= this.bits "
2018/06/19 20:09:55 " if ((op & 16) == 0) "
2018/06/19 20:09:55 " op &= 15 "
2018/06/19 20:09:55 " hold_mm >>= last bit length \n save bit length of current op \n get the next bits on input stream \n bits -= op bits \n ecx   = hold & mask[op] \n dist += hold & mask[op] "
2018/06/19 20:09:55 " save in so from can use it's reg "
2018/06/19 20:09:55 " nbytes = out - beg "
2018/06/19 20:09:55 " if (dist > nbytes) 4.2% "
2018/06/19 20:09:55 " from = out - dist "
2018/06/19 20:09:55 " move in back to %esi, toss from \n move lcode back to %ebx, toss dist "
2018/06/19 20:09:55 " move lcode back to %ebx, toss dist "
2018/06/19 20:09:55 " if ((op & 64) != 0) "
2018/06/19 20:09:55 " hold_mm >>= last bit length "
2018/06/19 20:09:55 " eax = lcode[hold & lmask] "
2018/06/19 20:09:55 " if ((op & 64) != 0) "
2018/06/19 20:09:55 " hold_mm >>= last bit length "
2018/06/19 20:09:55 " ecx = dcode "
2018/06/19 20:09:55 " eax = lcode[hold & lmask] "
2018/06/19 20:09:55 " prepare for dist compare \n nbytes = -nbytes \n from = window "
2018/06/19 20:09:55 " if (dist > wsize) "
2018/06/19 20:09:55 " nbytes = dist - nbytes "
2018/06/19 20:09:55 " if (write != 0) "
2018/06/19 20:09:55 " from += wsize - nbytes "
2018/06/19 20:09:55 " if (nbytes >= len) "
2018/06/19 20:09:55 " len -= nbytes "
2018/06/19 20:09:55 " from = out - dist "
2018/06/19 20:09:55 " if (nbytes >= len) "
2018/06/19 20:09:55 " len -= nbytes "
2018/06/19 20:09:55 " from = out - dist "
2018/06/19 20:09:55 " if (write >= nbytes) "
2018/06/19 20:09:55 " from += wsize + write - nbytes \n nbytes -= write "
2018/06/19 20:09:55 " if (nbytes >= len) "
2018/06/19 20:09:55 " len -= nbytes "
2018/06/19 20:09:55 " from = window \n nbytes = write "
2018/06/19 20:09:55 " if (nbytes >= len) "
2018/06/19 20:09:55 " len -= nbytes "
2018/06/19 20:09:55 " from = out - dist "
2018/06/19 20:09:55 " from += write - nbytes "
2018/06/19 20:09:55 " if (nbytes >= len) "
2018/06/19 20:09:55 " len -= nbytes "
2018/06/19 20:09:55 " from = out - dist "
2018/06/19 20:09:55 " move in back to %esi, toss from \n move lcode back to %ebx, toss dist "
2018/06/19 20:09:55 " USE_MMX || RUN_TIME_MMX "
2018/06/19 20:09:55 "** USE_MMX, NO_MMX, and RUNTIME_MMX from here on **"
2018/06/19 20:09:55 " else {\n         *   strm->msg = \"invalid distance code\";\n         *   state->mode = BAD;\n         * }\n         "
2018/06/19 20:09:55 " else if (op & 32) {\n         *   state->mode = TYPE;\n         *   break;\n         * }\n         "
2018/06/19 20:09:55 " if ((op & 32) == 0) "
2018/06/19 20:09:55 " else {\n         *   strm->msg = \"invalid literal/length code\";\n         *   state->mode = BAD;\n         * }\n         "
2018/06/19 20:09:55 " strm->msg = \"invalid distance too far back\";\n         * state->mode = BAD;\n         "
2018/06/19 20:09:55 " from_r has in's reg, put in back "
2018/06/19 20:09:55 " set strm->msg = %ecx, strm->state->mode = %edx "
2018/06/19 20:09:55 " if (msg != NULL) "
2018/06/19 20:09:55 " strm->msg = msg "
2018/06/19 20:09:55 " state = strm->state \n state->mode = edx (BAD | TYPE) "
2018/06/19 20:09:55 "\n * Regs:\n *\n * bits = %ebp when mmx, and in %ebx when non-mmx\n * hold = %hold_mm when mmx, and in %ebp when non-mmx\n * in   = %esi\n * out  = %edi\n "
2018/06/19 20:09:55 " RUN_TIME_MMX "
2018/06/19 20:09:55 " len = bits >> 3;\n         * in -= len;\n         * bits -= len << 3;\n         * hold &= (1U << bits) - 1;\n         * state->hold = hold;\n         * state->bits = bits;\n         * strm->next_in = in;\n         * strm->next_out = out;\n         "
2018/06/19 20:09:55 " if buf != last "
2018/06/19 20:09:55 " in -= buf "
2018/06/19 20:09:55 " last = strm->next_in \n in += strm->next_in "
2018/06/19 20:09:55 " last = &strm->next_in[ avail_in - 11 ] "
2018/06/19 20:09:55 " RUN_TIME_MMX "
2018/06/19 20:09:55 " hold_mm >>= last bit length "
2018/06/19 20:09:55 " USE_MMX || RUN_TIME_MMX "
2018/06/19 20:09:55 " strm->avail_in = in < last ? 11 + (last - in) : 11 - (in - last) "
2018/06/19 20:09:55 " if (in >= last) "
2018/06/19 20:09:55 " last -= in \n last += 11 "
2018/06/19 20:09:55 " in -= last \n in = -in \n in += 11 "
2018/06/19 20:09:55 " strm->avail_out = out < end ? 257 + (end - out) : 257 - (out - end)"
2018/06/19 20:09:55 " if (out >= end) "
2018/06/19 20:09:55 " end -= out \n end += 257 "
2018/06/19 20:09:55 " out -= end \n out = -out \n out += 257 "
2018/06/19 20:09:55 " elf info "
2018/06/19 20:09:55 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/inflate86/inffast.S": 52.303955ms
2018/06/19 20:09:55 Couldn't classify license(s)
2018/06/19 20:09:56 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/inflate86/inffas86.c
2018/06/19 20:09:56 detected language: 4
2018/06/19 20:09:56 " inffas86.c is a hand tuned assembler version of\n *\n * inffast.c -- fast decoding\n * Copyright (C) 1995-2003 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n *\n * Copyright (C) 2003 Chris Anderson <christop@charm.net>\n * Please use the copyright conditions above.\n *\n * Dec-29-2003 -- I added AMD64 inflate asm support.  This version is also\n * slightly quicker on x86 systems because, instead of using rep movsb to copy\n * data, it uses rep movsw, which moves data in 2-byte chunks instead of single\n * bytes.  I've tested the AMD64 code on a Fedora Core 1 + the x86_64 updates\n * from http://fedora.linux.duke.edu/fc1_x86_64\n * which is running on an Athlon 64 3000+ / Gigabyte GA-K8VT800M system with\n * 1GB ram.  The 64-bit version is about 4% faster than the 32-bit version,\n * when decompressing mozilla-source-1.3.tar.gz.\n *\n * Mar-13-2003 -- Most of this is derived from inffast.S which is derived from\n * the gcc -S output of zlib-1.2.0/inffast.c.  Zlib-1.2.0 is in beta release at\n * the moment.  I have successfully compiled and tested this code with gcc2.96,\n * gcc3.2, icc5.0, msvc6.0.  It is very close to the speed of inffast.S\n * compiled with gcc -DNO_MMX, but inffast.S is still faster on the P3 with MMX\n * enabled.  I will attempt to merge the MMX code into this version.  Newer\n * versions of this and inffast.S can be found at\n * http://www.eetbeetee.com/zlib/ and http://www.charm.net/~christop/zlib/\n "
2018/06/19 20:09:56 " Mark Adler's comments from inffast.c: "
2018/06/19 20:09:56 "\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state->mode == LEN\n        strm->avail_in >= 6\n        strm->avail_out >= 258\n        start >= strm->avail_out\n        state->bits < 8\n\n   On return, state->mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm->avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm->avail_out >= 258 for each loop to avoid checking for\n      output space.\n "
2018/06/19 20:09:56 " inflate()'s starting value for strm->avail_out "
2018/06/19 20:09:56 " 64   32                               x86  x86_64 \n ar offset                              register \n  0    0 \n esp save \n  8    4 \n ebp save \n 16    8 \n esi rsi  local strm->next_in \n 24   12 \n     r9   while in < last \n 32   16 \n edi rdi  local strm->next_out \n 40   20 \n          inflate()'s init next_out \n 48   24 \n     r10  while out < end \n 56   28 \n          size of window, wsize!=0 \n 64   32 \n ebp rbp  local strm->lencode \n 72   36 \n     r11  local strm->distcode \n 80   40 \n edx rdx  local strm->hold \n 88   44 \n ebx rbx  local strm->bits \n 92   48 \n          window size \n 96   52 \n          window write index \n100   56 \n     r12  mask for lcode \n104   60 \n     r13  mask for dcode \n108   64 \n     r14  match length \n112   68 \n     r15  match distance \n116   72 \n          set when state chng"
2018/06/19 20:09:56 " copy state to local variables "
2018/06/19 20:09:56 " decode literals and length/distances until end-of-block or not enough\n       input data or output space "
2018/06/19 20:09:56 " align in on 1/2 hold size boundary "
2018/06/19 20:09:56 " save regs rbp and rsp "
2018/06/19 20:09:56 " make rsp point to &ar \n rsi  = in \n rdi  = out \n r9   = last \n r10  = end \n rbp  = lcode \n r11  = dcode \n rdx  = hold \n ebx  = bits \n r12d = lmask \n r13d = dmask \n r14d = len \n r15d = dist "
2018/06/19 20:09:56 " if only one decode left "
2018/06/19 20:09:56 " r8 = lmask "
2018/06/19 20:09:56 " eax = *(uint *)in++ \n cl = bits, needs it for shifting \n bits += 32 "
2018/06/19 20:09:56 " hold |= *((uint *)in)++ << bits "
2018/06/19 20:09:56 " r8 = lmask "
2018/06/19 20:09:56 " if (32 < bits) "
2018/06/19 20:09:56 " eax = *(uint *)in++ \n cl = bits, needs it for shifting \n bits += 32 "
2018/06/19 20:09:56 " hold |= *((uint *)in)++ << bits "
2018/06/19 20:09:56 " r8 &= hold \n eax = lcode[hold & lmask] "
2018/06/19 20:09:56 " cl = this.bits \n bits -= this.bits \n hold >>= this.bits "
2018/06/19 20:09:56 " if (op != 0) 45.7% "
2018/06/19 20:09:56 " r8 = lmask \n output this.val char "
2018/06/19 20:09:56 " r8 &= hold \n eax = lcode[hold & lmask] "
2018/06/19 20:09:56 " cl = this.bits \n bits -= this.bits \n hold >>= this.bits "
2018/06/19 20:09:56 " if (op != 0) 45.7% "
2018/06/19 20:09:56 " output this.val char "
2018/06/19 20:09:56 " len = this \n len = this.val "
2018/06/19 20:09:56 " if ((op & 16) == 0) 8% \n op &= 15 \n if (!op) "
2018/06/19 20:09:56 " eax &= hold "
2018/06/19 20:09:56 " len += hold & mask[op] "
2018/06/19 20:09:56 " r8 = dmask "
2018/06/19 20:09:56 " if (32 < bits) "
2018/06/19 20:09:56 " eax = *(uint *)in++ \n cl = bits, needs it for shifting \n bits += 32 "
2018/06/19 20:09:56 " hold |= *((uint *)in)++ << bits "
2018/06/19 20:09:56 " r8 &= hold \n eax = dcode[hold & dmask] "
2018/06/19 20:09:56 " dist = this \n dist = this.val "
2018/06/19 20:09:56 " bits -= this.bits \n hold >>= this.bits \n cl = this.op "
2018/06/19 20:09:56 " if ((op & 16) == 0) "
2018/06/19 20:09:56 " op &= 15 "
2018/06/19 20:09:56 " (1 << op) - 1 \n eax &= hold "
2018/06/19 20:09:56 " dist += hold & ((1 << op) - 1) "
2018/06/19 20:09:56 " save in so from can use it's reg "
2018/06/19 20:09:56 " nbytes = out - beg "
2018/06/19 20:09:56 " if (dist > nbytes) 4.2% "
2018/06/19 20:09:56 " ecx = len "
2018/06/19 20:09:56 " from = out - dist "
2018/06/19 20:09:56 " if len % 2 == 0 "
2018/06/19 20:09:56 " move in back to %rsi, toss from "
2018/06/19 20:09:56 " move in back to %rsi, toss from "
2018/06/19 20:09:56 " if dist 1, is a memset "
2018/06/19 20:09:56 " if out == beg, outside window "
2018/06/19 20:09:56 " ecx = len "
2018/06/19 20:09:56 " if ((op & 64) != 0) "
2018/06/19 20:09:56 " eax &= hold \n eax += len \n eax = lcode[val+(hold&mask[op])]"
2018/06/19 20:09:56 " if ((op & 64) != 0) "
2018/06/19 20:09:56 " eax &= hold \n eax += dist \n eax = dcode[val+(hold&mask[op])]"
2018/06/19 20:09:56 " ecx = nbytes \n eax = wsize, prepare for dist cmp \n nbytes = -nbytes "
2018/06/19 20:09:56 " if (dist > wsize) "
2018/06/19 20:09:56 " nbytes = dist - nbytes "
2018/06/19 20:09:56 " if (write != 0) "
2018/06/19 20:09:56 " from  = window \n eax  -= nbytes \n from += wsize - nbytes "
2018/06/19 20:09:56 " eax = len "
2018/06/19 20:09:56 " if (nbytes >= len) "
2018/06/19 20:09:56 " eax -= nbytes "
2018/06/19 20:09:56 " from = &out[ -dist ] "
2018/06/19 20:09:56 " eax = write "
2018/06/19 20:09:56 " if (write >= nbytes) "
2018/06/19 20:09:56 " from  = wsize \n from += window \n from += write \n from -= nbytes \n nbytes -= write "
2018/06/19 20:09:56 " eax = len "
2018/06/19 20:09:56 " if (nbytes >= len) "
2018/06/19 20:09:56 " len -= nbytes "
2018/06/19 20:09:56 " from = window \n nbytes = write "
2018/06/19 20:09:56 " if (nbytes >= len) "
2018/06/19 20:09:56 " len -= nbytes "
2018/06/19 20:09:56 " from = out - dist "
2018/06/19 20:09:56 " rsi = window "
2018/06/19 20:09:56 " from += write - nbytes "
2018/06/19 20:09:56 " eax = len "
2018/06/19 20:09:56 " if (nbytes >= len) "
2018/06/19 20:09:56 " len -= nbytes "
2018/06/19 20:09:56 " from = out - dist \n if (nbytes >= len) "
2018/06/19 20:09:56 " ecx = len "
2018/06/19 20:09:56 " move in back to %esi, toss from "
2018/06/19 20:09:56 " put in, out, bits, and hold back into ar and pop esp \n in \n out \n bits \n hold \n restore rbp and rsp "
2018/06/19 20:09:56 " save esp, ebp "
2018/06/19 20:09:56 " esi = in \n edi = out \n edx = hold \n ebx = bits \n ebp = lcode "
2018/06/19 20:09:56 " out < end "
2018/06/19 20:09:56 " in < last "
2018/06/19 20:09:56 " if (15 < bits) "
2018/06/19 20:09:56 " al = *(ushort *)in++ \n cl = bits, needs it for shifting \n bits += 16 "
2018/06/19 20:09:56 " hold |= *((ushort *)in)++ << bits "
2018/06/19 20:09:56 " eax = lmask \n eax &= hold \n eax = lcode[hold & lmask] "
2018/06/19 20:09:56 " cl = this.bits \n bits -= this.bits \n hold >>= this.bits "
2018/06/19 20:09:56 " if (op != 0) 45.7% "
2018/06/19 20:09:56 " output this.val char "
2018/06/19 20:09:56 " len = this \n len = this.val \n save len "
2018/06/19 20:09:56 " if ((op & 16) == 0) 8% \n op &= 15 \n if (!op) "
2018/06/19 20:09:56 " if (op <= bits) "
2018/06/19 20:09:56 " stash op in ch, freeing cl "
2018/06/19 20:09:56 " al = *(ushort *)in++ \n cl = bits, needs it for shifting \n bits += 16 "
2018/06/19 20:09:56 " hold |= *((ushort *)in)++ << bits \n move op back to ecx "
2018/06/19 20:09:56 " eax &= hold "
2018/06/19 20:09:56 " len += hold & mask[op] "
2018/06/19 20:09:56 " if (15 < bits) "
2018/06/19 20:09:56 " al = *(ushort *)in++ \n cl = bits, needs it for shifting \n bits += 16 "
2018/06/19 20:09:56 " hold |= *((ushort *)in)++ << bits "
2018/06/19 20:09:56 " eax = dmask \n ecx = dcode \n eax &= hold "
2018/06/19 20:09:56 " dist = this \n dist = this.val "
2018/06/19 20:09:56 " bits -= this.bits \n hold >>= this.bits \n cl = this.op "
2018/06/19 20:09:56 " if ((op & 16) == 0) "
2018/06/19 20:09:56 " op &= 15 "
2018/06/19 20:09:56 " if (op <= bits) 97.6% "
2018/06/19 20:09:56 " stash op in ch, freeing cl "
2018/06/19 20:09:56 " al = *(ushort *)in++ \n cl = bits, needs it for shifting \n bits += 16 "
2018/06/19 20:09:56 " hold |= *((ushort *)in)++ << bits \n move op back to ecx "
2018/06/19 20:09:56 " (1 << op) - 1 \n eax &= hold "
2018/06/19 20:09:56 " dist += hold & ((1 << op) - 1) "
2018/06/19 20:09:56 " save in so from can use it's reg "
2018/06/19 20:09:56 " nbytes = out - beg "
2018/06/19 20:09:56 " if (dist > nbytes) 4.2% "
2018/06/19 20:09:56 " ecx = len "
2018/06/19 20:09:56 " from = out - dist "
2018/06/19 20:09:56 " if len % 2 == 0 "
2018/06/19 20:09:56 " move in back to %esi, toss from \n ebp = lcode "
2018/06/19 20:09:56 " move in back to %esi, toss from \n ebp = lcode "
2018/06/19 20:09:56 " if dist 1, is a memset "
2018/06/19 20:09:56 " out == beg, if outside window "
2018/06/19 20:09:56 " ecx = len "
2018/06/19 20:09:56 " ebp = lcode "
2018/06/19 20:09:56 " if ((op & 64) != 0) "
2018/06/19 20:09:56 " eax &= hold \n eax += len \n eax = lcode[val+(hold&mask[op])]"
2018/06/19 20:09:56 " if ((op & 64) != 0) "
2018/06/19 20:09:56 " eax &= hold \n eax += dist \n ecx = dcode \n eax = dcode[val+(hold&mask[op])]"
2018/06/19 20:09:56 " eax = wsize \n nbytes = -nbytes \n from = window "
2018/06/19 20:09:56 " if (dist > wsize) "
2018/06/19 20:09:56 " nbytes = dist - nbytes "
2018/06/19 20:09:56 " if (write != 0) "
2018/06/19 20:09:56 " from += wsize - nbytes "
2018/06/19 20:09:56 " eax = len "
2018/06/19 20:09:56 " if (nbytes >= len) "
2018/06/19 20:09:56 " len -= nbytes "
2018/06/19 20:09:56 " from = out - dist "
2018/06/19 20:09:56 " eax = write "
2018/06/19 20:09:56 " if (write >= nbytes) "
2018/06/19 20:09:56 " from += wsize \n from += write \n from -= nbytes \n nbytes -= write "
2018/06/19 20:09:56 " eax = len "
2018/06/19 20:09:56 " if (nbytes >= len) "
2018/06/19 20:09:56 " len -= nbytes "
2018/06/19 20:09:56 " from = window \n nbytes = write "
2018/06/19 20:09:56 " if (nbytes >= len) "
2018/06/19 20:09:56 " len -= nbytes "
2018/06/19 20:09:56 " from = out - dist "
2018/06/19 20:09:56 " from += write - nbytes "
2018/06/19 20:09:56 " eax = len "
2018/06/19 20:09:56 " if (nbytes >= len) "
2018/06/19 20:09:56 " len -= nbytes "
2018/06/19 20:09:56 " from = out - dist \n if (nbytes >= len) "
2018/06/19 20:09:56 " move in back to %esi, toss from \n ebp = lcode "
2018/06/19 20:09:56 " put in, out, bits, and hold back into ar and pop esp \n save in \n save out \n save bits \n save hold \n restore esp, ebp "
2018/06/19 20:09:56 " save esp, ebp "
2018/06/19 20:09:56 " esi = in \n edi = out \n edx = hold \n ebx = bits \n ebp = lcode "
2018/06/19 20:09:56 " if (15 < bits) "
2018/06/19 20:09:56 " al = *(ushort *)in++ \n cl = bits, needs it for shifting \n bits += 16 "
2018/06/19 20:09:56 " hold |= *((ushort *)in)++ << bits "
2018/06/19 20:09:56 " eax = lmask \n eax &= hold \n eax = lcode[hold & lmask] "
2018/06/19 20:09:56 " cl = this.bits \n bits -= this.bits \n hold >>= this.bits "
2018/06/19 20:09:56 " if (op != 0) 45.7% "
2018/06/19 20:09:56 " output this.val char "
2018/06/19 20:09:56 " len = this \n len = this.val \n save len "
2018/06/19 20:09:56 " if ((op & 16) == 0) 8% \n op &= 15 \n if (!op) "
2018/06/19 20:09:56 " if (op <= bits) "
2018/06/19 20:09:56 " stash op in ch, freeing cl "
2018/06/19 20:09:56 " al = *(ushort *)in++ \n cl = bits, needs it for shifting \n bits += 16 "
2018/06/19 20:09:56 " hold |= *((ushort *)in)++ << bits \n move op back to ecx "
2018/06/19 20:09:56 " eax &= hold "
2018/06/19 20:09:56 " len += hold & mask[op] "
2018/06/19 20:09:56 " if (15 < bits) "
2018/06/19 20:09:56 " al = *(ushort *)in++ \n cl = bits, needs it for shifting \n bits += 16 "
2018/06/19 20:09:56 " hold |= *((ushort *)in)++ << bits "
2018/06/19 20:09:56 " eax = dmask \n ecx = dcode \n eax &= hold \n eax = dcode[hold & dmask] "
2018/06/19 20:09:56 " dist = this \n dist = this.val "
2018/06/19 20:09:56 " bits -= this.bits \n hold >>= this.bits \n cl = this.op "
2018/06/19 20:09:56 " if ((op & 16) == 0) "
2018/06/19 20:09:56 " op &= 15 "
2018/06/19 20:09:56 " if (op <= bits) 97.6% "
2018/06/19 20:09:56 " stash op in ch, freeing cl "
2018/06/19 20:09:56 " al = *(ushort *)in++ \n cl = bits, needs it for shifting \n bits += 16 "
2018/06/19 20:09:56 " hold |= *((ushort *)in)++ << bits \n move op back to ecx "
2018/06/19 20:09:56 " (1 << op) - 1 \n eax &= hold "
2018/06/19 20:09:56 " dist += hold & ((1 << op) - 1) "
2018/06/19 20:09:56 " save in so from can use it's reg "
2018/06/19 20:09:56 " nbytes = out - beg "
2018/06/19 20:09:56 " if (dist > nbytes) 4.2% "
2018/06/19 20:09:56 " ecx = len "
2018/06/19 20:09:56 " from = out - dist "
2018/06/19 20:09:56 " move in back to %esi, toss from \n ebp = lcode "
2018/06/19 20:09:56 " move in back to %esi, toss from \n ebp = lcode "
2018/06/19 20:09:56 " if dist 1, is a memset "
2018/06/19 20:09:56 " out == beg, if outside window "
2018/06/19 20:09:56 " ecx = len "
2018/06/19 20:09:56 " memset out with from[-1] "
2018/06/19 20:09:56 " ebp = lcode "
2018/06/19 20:09:56 " if ((op & 64) != 0) "
2018/06/19 20:09:56 " eax &= hold \n eax += len \n eax = lcode[val+(hold&mask[op])]"
2018/06/19 20:09:56 " if ((op & 64) != 0) "
2018/06/19 20:09:56 " eax &= hold \n eax += dist \n ecx = dcode \n eax = dcode[val+(hold&mask[op])]"
2018/06/19 20:09:56 " eax = wsize \n nbytes = -nbytes \n from = window "
2018/06/19 20:09:56 " if (dist > wsize) "
2018/06/19 20:09:56 " nbytes = dist - nbytes "
2018/06/19 20:09:56 " if (write != 0) "
2018/06/19 20:09:56 " from += wsize - nbytes "
2018/06/19 20:09:56 " eax = len "
2018/06/19 20:09:56 " if (nbytes >= len) "
2018/06/19 20:09:56 " len -= nbytes "
2018/06/19 20:09:56 " from = out - dist "
2018/06/19 20:09:56 " eax = write "
2018/06/19 20:09:56 " if (write >= nbytes) "
2018/06/19 20:09:56 " from += wsize \n from += write \n from -= nbytes \n nbytes -= write "
2018/06/19 20:09:56 " eax = len "
2018/06/19 20:09:56 " if (nbytes >= len) "
2018/06/19 20:09:56 " len -= nbytes "
2018/06/19 20:09:56 " from = window \n nbytes = write "
2018/06/19 20:09:56 " if (nbytes >= len) "
2018/06/19 20:09:56 " len -= nbytes "
2018/06/19 20:09:56 " from = out - dist "
2018/06/19 20:09:56 " from += write - nbytes "
2018/06/19 20:09:56 " eax = len "
2018/06/19 20:09:56 " if (nbytes >= len) "
2018/06/19 20:09:56 " len -= nbytes "
2018/06/19 20:09:56 " from = out - dist "
2018/06/19 20:09:56 " move in back to %esi, toss from \n ebp = lcode "
2018/06/19 20:09:56 " put in, out, bits, and hold back into ar and pop esp \n save in \n save out \n save bits \n save hold \n restore esp, ebp "
2018/06/19 20:09:56 " return unused bytes (on entry, bits < 8, so in won't go too far back) "
2018/06/19 20:09:56 " update state and return "
2018/06/19 20:09:56 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/inflate86/inffas86.c": 38.864919ms
2018/06/19 20:09:56 Couldn't classify license(s)
2018/06/19 20:09:57 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/blast/test.pk
2018/06/19 20:09:57 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/blast/test.pk": 479.859µs
2018/06/19 20:09:57 Couldn't classify license(s)
2018/06/19 20:09:58 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/blast/Makefile
2018/06/19 20:09:58 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/blast/Makefile": 698.051µs
2018/06/19 20:09:58 Couldn't classify license(s)
2018/06/19 20:09:58 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/blast/blast.c
2018/06/19 20:09:58 detected language: 4
2018/06/19 20:09:58 " blast.c\n * Copyright (C) 2003, 2012, 2013 Mark Adler\n * For conditions of distribution and use, see copyright notice in blast.h\n * version 1.3, 24 Aug 2013\n *\n * blast.c decompresses data compressed by the PKWare Compression Library.\n * This function provides functionality similar to the explode() function of\n * the PKWare library, hence the name \"blast\".\n *\n * This decompressor is based on the excellent format description provided by\n * Ben Rudiak-Gould in comp.compression on August 13, 2001.  Interestingly, the\n * example Ben provided in the post is incorrect.  The distance 110001 should\n * instead be 111000.  When corrected, the example byte stream becomes:\n *\n *    00 04 82 24 25 8f 80 7f\n *\n * which decompresses to \"AIAIAIAIAIAIA\" (without the quotes).\n "
2018/06/19 20:09:58 "\n * Change history:\n *\n * 1.0  12 Feb 2003     - First version\n * 1.1  16 Feb 2003     - Fixed distance check for > 4 GB uncompressed data\n * 1.2  24 Oct 2012     - Add note about using binary mode in stdio\n *                      - Fix comparisons of differently signed integers\n * 1.3  24 Aug 2013     - Return unused input from blast()\n *                      - Fix test code to correctly report unused input\n *                      - Enable the provision of initial input to blast()\n "
2018/06/19 20:09:58 " for NULL \n for setjmp(), longjmp(), and jmp_buf \n prototype for blast() "
2018/06/19 20:09:58 " for local function definitions \n maximum code length \n maximum window size "
2018/06/19 20:09:58 " input and output state "
2018/06/19 20:09:58 " input state \n input function provided by user \n opaque information passed to infun() \n next input location \n available input at in \n bit buffer \n number of bits in bit buffer "
2018/06/19 20:09:58 " input limit error return state for bits() and decode() "
2018/06/19 20:09:58 " output state \n output function provided by user \n opaque information passed to outfun() \n index of next write location in out[] \n true to check distances (for first 4K) \n output buffer and sliding window "
2018/06/19 20:09:58 "\n * Return need bits from the input stream.  This always leaves less than\n * eight bits in the buffer.  bits() works properly for need == 0.\n *\n * Format notes:\n *\n * - Bits are stored in bytes from the least significant bit to the most\n *   significant bit.  Therefore bits are dropped from the bottom of the bit\n *   buffer, using shift right, and new bytes are appended to the top of the\n *   bit buffer, using shift left.\n "
2018/06/19 20:09:58 " bit accumulator "
2018/06/19 20:09:58 " load at least need bits into val "
2018/06/19 20:09:58 " out of input "
2018/06/19 20:09:58 " load eight bits "
2018/06/19 20:09:58 " drop need bits and update buffer, always zero to seven bits left "
2018/06/19 20:09:58 " return need bits, zeroing the bits above that "
2018/06/19 20:09:58 "\n * Huffman code decoding tables.  count[1..MAXBITS] is the number of symbols of\n * each length, which for a canonical code are stepped through in order.\n * symbol[] are the symbol values in canonical order, where the number of\n * entries is the sum of the counts in count[].  The decoding process can be\n * seen in the function decode() below.\n "
2018/06/19 20:09:58 " number of symbols of each length \n canonically ordered symbols "
2018/06/19 20:09:58 "\n * Decode a code from the stream s using huffman table h.  Return the symbol or\n * a negative value if there is an error.  If all of the lengths are zero, i.e.\n * an empty code, or if the code is incomplete and an invalid code is received,\n * then -9 is returned after reading MAXBITS bits.\n *\n * Format notes:\n *\n * - The codes as stored in the compressed data are bit-reversed relative to\n *   a simple integer ordering of codes of the same lengths.  Hence below the\n *   bits are pulled from the compressed data one at a time and used to\n *   build the code value reversed from what is in the stream in order to\n *   permit simple integer comparisons for decoding.\n *\n * - The first code for the shortest length is all ones.  Subsequent codes of\n *   the same length are simply integer decrements of the previous code.  When\n *   moving up a length, a one bit is appended to the code.  For a complete\n *   code, the last code of the longest length will be all zeros.  To support\n *   this ordering, the bits pulled during decoding are inverted to apply the\n *   more \"natural\" ordering starting with all zeros and incrementing.\n "
2018/06/19 20:09:58 " current number of bits in code \n len bits being decoded \n first code of length len \n number of codes of length len \n index of first code of length len in symbol table \n bits from stream \n bits left in next or left to process \n next number of codes "
2018/06/19 20:09:58 " invert code "
2018/06/19 20:09:58 " if length len, return symbol "
2018/06/19 20:09:58 " else update for next length "
2018/06/19 20:09:58 " out of input "
2018/06/19 20:09:58 " ran out of codes "
2018/06/19 20:09:58 "\n * Given a list of repeated code lengths rep[0..n-1], where each byte is a\n * count (high four bits + 1) and a code length (low four bits), generate the\n * list of code lengths.  This compaction reduces the size of the object code.\n * Then given the list of code lengths length[0..n-1] representing a canonical\n * Huffman code for n symbols, construct the tables required to decode those\n * codes.  Those tables are the number of codes of each length, and the symbols\n * sorted by length, retaining their original order within each length.  The\n * return value is zero for a complete code set, negative for an over-\n * subscribed code set, and positive for an incomplete code set.  The tables\n * can be used if the return value is zero or positive, but they cannot be used\n * if the return value is negative.  If the return value is zero, it is not\n * possible for decode() using that table to return an error--any stream of\n * enough bits will resolve to a symbol.  If the return value is positive, then\n * it is possible for decode() using that table to return an error for received\n * codes past the end of the incomplete lengths.\n "
2018/06/19 20:09:58 " current symbol when stepping through length[] \n current length when stepping through h->count[] \n number of possible codes left of current length \n offsets in symbol table for each length \n code lengths "
2018/06/19 20:09:58 " convert compact repeat counts into symbol bit length list "
2018/06/19 20:09:58 " count number of codes of each length "
2018/06/19 20:09:58 " assumes lengths are within bounds \n no codes! \n complete, but decode() will fail "
2018/06/19 20:09:58 " check for an over-subscribed or incomplete set of lengths \n one possible code of zero length "
2018/06/19 20:09:58 " one more bit, double codes left \n deduct count from possible codes \n over-subscribed--return negative \n left > 0 means incomplete "
2018/06/19 20:09:58 " generate offsets into symbol table for each length for sorting "
2018/06/19 20:09:58 "\n     * put symbols in table sorted by length, by symbol order within each\n     * length\n     "
2018/06/19 20:09:58 " return zero for complete set, positive for incomplete set "
2018/06/19 20:09:58 "\n * Decode PKWare Compression Library stream.\n *\n * Format notes:\n *\n * - First byte is 0 if literals are uncoded or 1 if they are coded.  Second\n *   byte is 4, 5, or 6 for the number of extra bits in the distance code.\n *   This is the base-2 logarithm of the dictionary size minus six.\n *\n * - Compressed data is a combination of literals and length/distance pairs\n *   terminated by an end code.  Literals are either Huffman coded or\n *   uncoded bytes.  A length/distance pair is a coded length followed by a\n *   coded distance to represent a string that occurs earlier in the\n *   uncompressed data that occurs again at the current location.\n *\n * - A bit preceding a literal or length/distance pair indicates which comes\n *   next, 0 for literals, 1 for length/distance.\n *\n * - If literals are uncoded, then the next eight bits are the literal, in the\n *   normal bit order in the stream, i.e. no bit-reversal is needed. Similarly,\n *   no bit reversal is needed for either the length extra bits or the distance\n *   extra bits.\n *\n * - Literal bytes are simply written to the output.  A length/distance pair is\n *   an instruction to copy previously uncompressed bytes to the output.  The\n *   copy is from distance bytes back in the output stream, copying for length\n *   bytes.\n *\n * - Distances pointing before the beginning of the output data are not\n *   permitted.\n *\n * - Overlapped copies, where the length is greater than the distance, are\n *   allowed and common.  For example, a distance of one and a length of 518\n *   simply copies the last byte 518 times.  A distance of four and a length of\n *   twelve copies the last four bytes three times.  A simple forward copy\n *   ignoring whether the length is greater than the distance or not implements\n *   this correctly.\n "
2018/06/19 20:09:58 " true if literals are coded \n log2(dictionary size) - 6 \n decoded symbol, extra bits for distance \n length for copy \n distance for copy \n copy counter \n copy pointers \n build tables once \n litcode memory \n lencode memory \n distcode memory \n length code \n length code \n distance code \n bit lengths of literal codes "
2018/06/19 20:09:58 " bit lengths of length codes 0..15 "
2018/06/19 20:09:58 " bit lengths of distance codes 0..63 "
2018/06/19 20:09:58 " base for length codes "
2018/06/19 20:09:58 " extra bits for length codes "
2018/06/19 20:09:58 " set up decoding tables (once--might not be thread-safe) "
2018/06/19 20:09:58 " read header "
2018/06/19 20:09:58 " decode literals and length/distance pairs "
2018/06/19 20:09:58 " get length "
2018/06/19 20:09:58 " end code "
2018/06/19 20:09:58 " get distance "
2018/06/19 20:09:58 " distance too far back "
2018/06/19 20:09:58 " copy length bytes from distance bytes back "
2018/06/19 20:09:58 " get literal and write it "
2018/06/19 20:09:58 " See comments in blast.h "
2018/06/19 20:09:58 " input/output state \n return value "
2018/06/19 20:09:58 " initialize input state "
2018/06/19 20:09:58 " initialize output state "
2018/06/19 20:09:58 " return if bits() or decode() tries to read past available input \n if came back here via longjmp(), \n  then skip decomp(), return error "
2018/06/19 20:09:58 " decompress "
2018/06/19 20:09:58 " return unused input "
2018/06/19 20:09:58 " write any leftover output and update the error code if needed "
2018/06/19 20:09:58 " Example of how to use blast() "
2018/06/19 20:09:58 " Decompress a PKWare Compression Library stream from stdin to stdout "
2018/06/19 20:09:58 " decompress to stdout "
2018/06/19 20:09:58 " count any leftover bytes "
2018/06/19 20:09:58 " return blast() error code "
2018/06/19 20:09:58 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/blast/blast.c": 61.214778ms
2018/06/19 20:09:58 Couldn't classify license(s)
2018/06/19 20:09:59 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/blast/test.txt
2018/06/19 20:09:59 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/blast/test.txt": 552.625µs
2018/06/19 20:09:59 Couldn't classify license(s)
2018/06/19 20:10:00 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/blast/blast.h
2018/06/19 20:10:00 detected language: 4
2018/06/19 20:10:00 " blast.h -- interface for blast.c\n  Copyright (C) 2003, 2012, 2013 Mark Adler\n  version 1.3, 24 Aug 2013\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the author be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n\n  Mark Adler    madler@alumni.caltech.edu\n "
2018/06/19 20:10:00 "\n * blast() decompresses the PKWare Data Compression Library (DCL) compressed\n * format.  It provides the same functionality as the explode() function in\n * that library.  (Note: PKWare overused the \"implode\" verb, and the format\n * used by their library implode() function is completely different and\n * incompatible with the implode compression method supported by PKZIP.)\n *\n * The binary mode for stdio functions should be used to assure that the\n * compressed data is not corrupted when read or written.  For example:\n * fopen(..., \"rb\") and fopen(..., \"wb\").\n "
2018/06/19 20:10:00 " Definitions for input/output functions passed to blast().  See below for\n * what the provided functions need to do.\n "
2018/06/19 20:10:00 " Decompress input to output using the provided infun() and outfun() calls.\n * On success, the return value of blast() is zero.  If there is an error in\n * the source data, i.e. it is not in the proper format, then a negative value\n * is returned.  If there is not enough input available or there is not enough\n * output space, then a positive error is returned.\n *\n * The input function is invoked: len = infun(how, &buf), where buf is set by\n * infun() to point to the input buffer, and infun() returns the number of\n * available bytes there.  If infun() returns zero, then blast() returns with\n * an input error.  (blast() only asks for input if it needs it.)  inhow is for\n * use by the application to pass an input descriptor to infun(), if desired.\n *\n * If left and in are not NULL and *left is not zero when blast() is called,\n * then the *left bytes are *in are consumed for input before infun() is used.\n *\n * The output function is invoked: err = outfun(how, buf, len), where the bytes\n * to be written are buf[0..len-1].  If err is not zero, then blast() returns\n * with an output error.  outfun() is always called with len <= 4096.  outhow\n * is for use by the application to pass an output descriptor to outfun(), if\n * desired.\n *\n * If there is any unused input, *left is set to the number of bytes that were\n * read and *in points to them.  Otherwise *left is set to zero and *in is set\n * to NULL.  If left or in are NULL, then they are not set.\n *\n * The return codes are:\n *\n *   2:  ran out of input before completing decompression\n *   1:  output error before completing decompression\n *   0:  successful decompression\n *  -1:  literal flag not zero or one\n *  -2:  dictionary size not in 4..6\n *  -3:  distance is too far back\n *\n * At the bottom of blast.c is an example program that uses blast() that can be\n * compiled to produce a command-line decompression filter by defining TEST.\n "
2018/06/19 20:10:00 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/blast/blast.h": 13.316991ms
2018/06/19 20:10:01 Classifying license(s): /zlib-1.2.11.tar.gz/contrib/blast/README
2018/06/19 20:10:01 Finished Classifying License "/zlib-1.2.11.tar.gz/contrib/blast/README": 532.925µs
2018/06/19 20:10:01 Couldn't classify license(s)
2018/06/19 20:10:01 Classifying license(s): /zlib-1.2.11.tar.gz/zlib2ansi
2018/06/19 20:10:01 Finished Classifying License "/zlib-1.2.11.tar.gz/zlib2ansi": 13.85448ms
2018/06/19 20:10:01 Couldn't classify license(s)
2018/06/19 20:10:02 Classifying license(s): /zlib-1.2.11.tar.gz/uncompr.c
2018/06/19 20:10:02 detected language: 4
2018/06/19 20:10:02 " uncompr.c -- decompress a memory buffer\n * Copyright (C) 1995-2003, 2010, 2014, 2016 Jean-loup Gailly, Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n "
2018/06/19 20:10:02 " @(#) $Id$ "
2018/06/19 20:10:02 " ===========================================================================\n     Decompresses the source buffer into the destination buffer.  *sourceLen is\n   the byte length of the source buffer. Upon entry, *destLen is the total size\n   of the destination buffer, which must be large enough to hold the entire\n   uncompressed data. (The size of the uncompressed data must have been saved\n   previously by the compressor and transmitted to the decompressor by some\n   mechanism outside the scope of this compression library.) Upon exit,\n   *destLen is the size of the decompressed data and *sourceLen is the number\n   of source bytes consumed. Upon return, source + *sourceLen points to the\n   first unused input byte.\n\n     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not enough\n   memory, Z_BUF_ERROR if there was not enough room in the output buffer, or\n   Z_DATA_ERROR if the input data was corrupted, including if the input data is\n   an incomplete zlib stream.\n"
2018/06/19 20:10:02 " for detection of incomplete stream when *destLen == 0 "
2018/06/19 20:10:02 Finished Classifying License "/zlib-1.2.11.tar.gz/uncompr.c": 3.124661ms
2018/06/19 20:10:02 Couldn't classify license(s)
2018/06/19 20:10:03 Classifying license(s): /zlib-1.2.11.tar.gz/README
2018/06/19 20:10:03 Finished Classifying License "/zlib-1.2.11.tar.gz/README": 20.473267ms
2018/06/19 20:10:04 Classifying license(s): /zlib-1.2.11.tar.gz/inftrees.h
2018/06/19 20:10:04 detected language: 4
2018/06/19 20:10:04 " inftrees.h -- header to use inftrees.c\n * Copyright (C) 1995-2005, 2010 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n "
2018/06/19 20:10:04 " WARNING: this file should *not* be used by applications. It is\n   part of the implementation of the compression library and is\n   subject to change. Applications should only use zlib.h.\n "
2018/06/19 20:10:04 " Structure for decoding tables.  Each entry provides either the\n   information needed to do the operation requested by the code that\n   indexed that table entry, or it provides a pointer to another\n   table that indexes more bits of the code.  op indicates whether\n   the entry is a pointer to another table, a literal, a length or\n   distance, an end-of-block, or an invalid code.  For a table\n   pointer, the low four bits of op is the number of index bits of\n   that table.  For a length or distance, the low four bits of op\n   is the number of extra bits to get after the code.  bits is\n   the number of bits in this code or part of the code to drop off\n   of the bit buffer.  val is the actual byte to output in the case\n   of a literal, the base length or distance, or the offset from\n   the current table to the next table.  Each entry is four bytes. "
2018/06/19 20:10:04 " operation, extra bits, table bits \n bits in this part of the code \n offset in table or code value "
2018/06/19 20:10:04 " op values as set by inflate_table():\n    00000000 - literal\n    0000tttt - table link, tttt != 0 is the number of table index bits\n    0001eeee - length or distance, eeee is the number of extra bits\n    01100000 - end of block\n    01000000 - invalid code\n "
2018/06/19 20:10:04 " Maximum size of the dynamic table.  The maximum number of code structures is\n   1444, which is the sum of 852 for literal/length codes and 592 for distance\n   codes.  These values were found by exhaustive searches using the program\n   examples/enough.c found in the zlib distribtution.  The arguments to that\n   program are the number of symbols, the initial root table size, and the\n   maximum bit length of a code.  \"enough 286 9 15\" for literal/length codes\n   returns returns 852, and \"enough 30 6 15\" for distance codes returns 592.\n   The initial root table size (9 or 6) is found in the fifth argument of the\n   inflate_table() calls in inflate.c and infback.c.  If the root table size is\n   changed, then these maximum sizes would be need to be recalculated and\n   updated. "
2018/06/19 20:10:04 " Type of code to build for inflate_table() "
2018/06/19 20:10:04 Finished Classifying License "/zlib-1.2.11.tar.gz/inftrees.h": 19.844299ms
2018/06/19 20:10:04 Couldn't classify license(s)
